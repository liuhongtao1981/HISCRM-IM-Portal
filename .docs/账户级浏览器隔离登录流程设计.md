# 账户级浏览器隔离登录流程设计

## 📋 核心设计理念

### 1. 账户级浏览器隔离

每个账户拥有独立的：
- ✅ **Browser 进程** - 完全独立的浏览器实例
- ✅ **指纹配置** - Canvas、WebGL、Audio 等指纹
- ✅ **Cookie 存储** - 持久化登录状态
- ✅ **LocalStorage** - 本地存储数据
- ✅ **代理配置** - 独立的 IP 地址

### 2. 目录结构

```
packages/worker/data/browser/
  └── {worker_id}/
      ├── fingerprints/
      │   ├── account-123_fingerprint.json  ← 账户1的指纹配置
      │   └── account-456_fingerprint.json  ← 账户2的指纹配置
      └── storage/
          ├── account-123_storage.json      ← 账户1的 Cookie/Storage
          └── account-456_storage.json      ← 账户2的 Cookie/Storage
```

## 🔄 登录流程设计

### 阶段 1: 初始化账户浏览器

```javascript
// 步骤1: Worker 收到登录请求
handleLoginRequest({ account_id, session_id, platform, proxy })
  ↓
// 步骤2: 获取平台实例
const platformInstance = platformManager.getPlatform(platform)
  ↓
// 步骤3: 检查账户浏览器实例
const browser = browserManager.getBrowserForAccount(account_id)
  ↓
// 如果不存在，创建新的浏览器实例
if (!browser) {
  browser = await browserManager.launchBrowserForAccount(account_id, { proxy })
  // 生成并保存指纹配置
  // 创建独立的 Browser Context
}
```

### 阶段 2: 智能识别登录方式

```javascript
// 平台脚本检测登录界面类型
const loginMethod = await platform.detectLoginMethod(page)

返回值:
- 'qrcode'   → 二维码登录
- 'sms'      → 手机短信验证
- 'password' → 密码登录
- 'logged_in' → 已登录状态
```

**实现逻辑**:

```javascript
// DouyinPlatform.detectLoginMethod()
async detectLoginMethod(page) {
  await page.goto('https://www.douyin.com/', { waitUntil: 'networkidle' });
  
  // 检查是否已登录
  const userInfo = await page.$('.user-info');
  if (userInfo) {
    return { type: 'logged_in', data: await this.getUserInfo(page) };
  }
  
  // 检查二维码
  const qrcode = await page.$('.qrcode-img');
  if (qrcode) {
    return { type: 'qrcode', element: qrcode };
  }
  
  // 检查短信验证
  const smsInput = await page.$('input[placeholder*="手机号"]');
  if (smsInput) {
    return { type: 'sms', element: smsInput };
  }
  
  // 检查密码登录
  const passwordInput = await page.$('input[type="password"]');
  if (passwordInput) {
    return { type: 'password', elements: { username, password } };
  }
  
  return { type: 'unknown' };
}
```

### 阶段 3: 处理不同登录方式

#### 3.1 二维码登录

```javascript
async handleQRCodeLogin(page, accountId, sessionId) {
  logger.info(`[QRCode Login] Starting for account ${accountId}`);
  
  // 1. 定位二维码元素
  const qrElement = await page.waitForSelector('.qrcode-img', { 
    timeout: 10000 
  });
  
  // 2. 截取二维码图片
  const qrImage = await qrElement.screenshot();
  const qrBase64 = qrImage.toString('base64');
  
  // 3. 获取过期时间（如果页面有显示）
  let expiresAt = Date.now() + 300000; // 默认5分钟
  try {
    const expiryText = await page.$eval('.qr-expire-time', el => el.textContent);
    // 解析过期时间...
  } catch (e) {
    // 使用默认值
  }
  
  // 4. 发送二维码到 Master → Admin Web
  this.workerBridge.sendLoginStatus(accountId, sessionId, 'qrcode_ready', {
    qr_code_data: `data:image/png;base64,${qrBase64}`,
    expires_at: Math.floor(expiresAt / 1000),
    login_method: 'qrcode',
  });
  
  // 5. 启动心跳监控（等待用户扫码）
  const loginSuccess = await this.waitForLogin(page, accountId, sessionId, {
    timeout: 300000, // 5分钟
    checkInterval: 2000, // 每2秒检查一次
  });
  
  return loginSuccess;
}
```

#### 3.2 短信验证码登录

```javascript
async handleSMSLogin(page, accountId, sessionId) {
  logger.info(`[SMS Login] Starting for account ${accountId}`);
  
  // 1. 检测手机号输入框
  const phoneInput = await page.waitForSelector('input[placeholder*="手机号"]');
  
  // 2. 通知 Web 端需要输入手机号
  this.workerBridge.sendLoginStatus(accountId, sessionId, 'sms_input_required', {
    login_method: 'sms',
    step: 'phone_number',
    message: '请输入手机号',
  });
  
  // 3. 等待 Web 端用户输入手机号
  const phoneNumber = await this.waitForUserInput(sessionId, 'phone_number', {
    timeout: 120000, // 2分钟
  });
  
  // 4. 在页面输入手机号
  await phoneInput.fill(phoneNumber);
  
  // 5. 点击"获取验证码"按钮
  const getSMSButton = await page.$('button:has-text("获取验证码")');
  await getSMSButton.click();
  
  // 6. 等待验证码输入框出现
  await page.waitForSelector('input[placeholder*="验证码"]');
  
  // 7. 通知 Web 端需要输入验证码
  this.workerBridge.sendLoginStatus(accountId, sessionId, 'sms_input_required', {
    login_method: 'sms',
    step: 'verification_code',
    message: `验证码已发送至 ${phoneNumber}`,
  });
  
  // 8. 等待 Web 端用户输入验证码
  const verificationCode = await this.waitForUserInput(sessionId, 'verification_code', {
    timeout: 120000,
  });
  
  // 9. 在页面输入验证码
  const codeInput = await page.$('input[placeholder*="验证码"]');
  await codeInput.fill(verificationCode);
  
  // 10. 点击"登录"按钮
  const loginButton = await page.$('button:has-text("登录")');
  await loginButton.click();
  
  // 11. 等待登录成功
  const loginSuccess = await this.waitForLogin(page, accountId, sessionId, {
    timeout: 30000,
  });
  
  return loginSuccess;
}
```

### 阶段 4: 心跳检测登录状态（框架方法）

```javascript
/**
 * 心跳检测登录状态
 * 这是一个通用的框架方法，所有平台都可以使用
 */
async waitForLogin(page, accountId, sessionId, options = {}) {
  const {
    timeout = 300000,        // 默认5分钟超时
    checkInterval = 2000,    // 默认每2秒检查一次
    checkMethod = 'auto',    // 'auto' | 'element' | 'cookie' | 'url'
  } = options;
  
  logger.info(`[Login Monitor] Starting for account ${accountId}, timeout: ${timeout}ms`);
  
  const startTime = Date.now();
  let lastStatus = null;
  
  return new Promise((resolve, reject) => {
    const checkTimer = setInterval(async () => {
      try {
        // 检查是否超时
        if (Date.now() - startTime > timeout) {
          clearInterval(checkTimer);
          this.workerBridge.sendLoginStatus(accountId, sessionId, 'timeout', {
            message: '登录超时，请重试',
          });
          reject(new Error('Login timeout'));
          return;
        }
        
        // 执行登录状态检查
        const loginStatus = await this.checkLoginStatus(page, checkMethod);
        
        if (loginStatus.isLoggedIn) {
          // 登录成功！
          clearInterval(checkTimer);
          
          logger.info(`[Login Monitor] Login successful for account ${accountId}`);
          
          // 保存登录状态（Cookie、Storage）
          await this.saveLoginState(page, accountId);
          
          // 通知 Master → Admin Web
          this.workerBridge.sendLoginStatus(accountId, sessionId, 'success', {
            user_info: loginStatus.userInfo,
            timestamp: Date.now(),
          });
          
          resolve(true);
          
        } else if (loginStatus.status !== lastStatus) {
          // 状态变化，通知前端
          lastStatus = loginStatus.status;
          
          if (loginStatus.status === 'scanning') {
            this.workerBridge.sendLoginStatus(accountId, sessionId, 'scanning', {
              message: '正在扫码中...',
            });
          }
        }
        
      } catch (error) {
        logger.error(`[Login Monitor] Check failed for account ${accountId}:`, error);
        clearInterval(checkTimer);
        
        this.workerBridge.sendLoginStatus(accountId, sessionId, 'failed', {
          error_message: error.message,
        });
        
        reject(error);
      }
    }, checkInterval);
  });
}

/**
 * 检查登录状态的多种方法
 */
async checkLoginStatus(page, method = 'auto') {
  // 方法1: 检查特定元素（最常用）
  if (method === 'auto' || method === 'element') {
    const userInfo = await page.$('.user-info, .user-avatar, [data-e2e="user-info"]');
    if (userInfo) {
      const userData = await this.extractUserInfo(page);
      return { isLoggedIn: true, status: 'logged_in', userInfo: userData };
    }
  }
  
  // 方法2: 检查 Cookie
  if (method === 'auto' || method === 'cookie') {
    const cookies = await page.context().cookies();
    const sessionCookie = cookies.find(c => 
      c.name.includes('session') || 
      c.name.includes('token') ||
      c.name.includes('sid')
    );
    
    if (sessionCookie && sessionCookie.value) {
      return { isLoggedIn: true, status: 'logged_in' };
    }
  }
  
  // 方法3: 检查 URL 变化
  if (method === 'auto' || method === 'url') {
    const currentUrl = page.url();
    if (!currentUrl.includes('/login') && !currentUrl.includes('/passport')) {
      // URL 不再是登录页，可能已登录
      const userInfo = await page.$('.user-info, .user-avatar');
      if (userInfo) {
        return { isLoggedIn: true, status: 'logged_in' };
      }
    }
  }
  
  // 方法4: 检查是否在扫码中
  const scanningHint = await page.$('.qr-scanning, .scan-success');
  if (scanningHint) {
    return { isLoggedIn: false, status: 'scanning' };
  }
  
  // 方法5: 检查是否过期
  const expiredHint = await page.$('.qr-expired, .expired-tip');
  if (expiredHint) {
    return { isLoggedIn: false, status: 'expired' };
  }
  
  return { isLoggedIn: false, status: 'pending' };
}
```

### 阶段 5: 保存登录状态

```javascript
async saveLoginState(page, accountId) {
  logger.info(`[Storage] Saving login state for account ${accountId}`);
  
  // 1. 保存 Storage State（包含 Cookies、LocalStorage、SessionStorage）
  const storageStatePath = this.browserManager.getStorageStatePath(accountId);
  await page.context().storageState({ path: storageStatePath });
  
  logger.info(`[Storage] Saved storage state to ${storageStatePath}`);
  
  // 2. 提取用户信息（可选）
  const userInfo = await this.extractUserInfo(page);
  if (userInfo) {
    const userInfoPath = path.join(
      this.browserManager.config.dataDir,
      'user-info',
      `${accountId}_user.json`
    );
    fs.writeFileSync(userInfoPath, JSON.stringify(userInfo, null, 2));
    logger.info(`[Storage] Saved user info for account ${accountId}`);
  }
  
  return true;
}

async extractUserInfo(page) {
  try {
    // 根据不同平台提取用户信息
    const userInfo = await page.evaluate(() => {
      // 尝试从页面中提取用户信息
      const avatar = document.querySelector('.user-avatar img')?.src;
      const nickname = document.querySelector('.user-nickname')?.textContent;
      const uid = document.querySelector('[data-user-id]')?.dataset.userId;
      
      return { avatar, nickname, uid };
    });
    
    return userInfo;
  } catch (error) {
    logger.warn('Failed to extract user info:', error);
    return null;
  }
}
```

## 🎯 Web 端界面设计

### 1. 统一的登录模态框

```javascript
// LoginModal.jsx
const LoginModal = ({ visible, onCancel, loginData }) => {
  const { login_method, qr_code_data, step, message } = loginData || {};
  
  // 二维码登录
  if (login_method === 'qrcode') {
    return (
      <Modal visible={visible} onCancel={onCancel}>
        <QRCodeDisplay 
          qrData={qr_code_data}
          expiresAt={loginData.expires_at}
        />
      </Modal>
    );
  }
  
  // 短信验证登录
  if (login_method === 'sms') {
    if (step === 'phone_number') {
      return (
        <Modal visible={visible} onCancel={onCancel}>
          <PhoneNumberInput 
            onSubmit={(phone) => handlePhoneSubmit(phone)}
          />
        </Modal>
      );
    }
    
    if (step === 'verification_code') {
      return (
        <Modal visible={visible} onCancel={onCancel}>
          <VerificationCodeInput 
            phoneNumber={loginData.phone_number}
            onSubmit={(code) => handleCodeSubmit(code)}
          />
        </Modal>
      );
    }
  }
  
  return null;
};
```

### 2. Socket.IO 事件处理

```javascript
// socketContext.js

// 监听登录状态更新
socket.on('login:status:update', (data) => {
  const { account_id, session_id, status, ...extraData } = data;
  
  switch (status) {
    case 'qrcode_ready':
      // 显示二维码
      setLoginModalData({
        visible: true,
        login_method: 'qrcode',
        qr_code_data: extraData.qr_code_data,
        expires_at: extraData.expires_at,
      });
      break;
      
    case 'sms_input_required':
      // 显示短信输入框
      setLoginModalData({
        visible: true,
        login_method: 'sms',
        step: extraData.step,
        message: extraData.message,
      });
      break;
      
    case 'scanning':
      // 更新提示文字
      message.info('正在扫码中...');
      break;
      
    case 'success':
      // 登录成功
      message.success('登录成功！');
      setLoginModalData({ visible: false });
      refreshAccounts();
      break;
      
    case 'failed':
    case 'timeout':
      // 登录失败
      message.error(extraData.error_message || '登录失败');
      setLoginModalData({ visible: false });
      break;
  }
});

// 发送用户输入（手机号、验证码）
const submitUserInput = (sessionId, inputType, value) => {
  socket.emit('master:login:user_input', {
    session_id: sessionId,
    input_type: inputType,  // 'phone_number' | 'verification_code'
    value: value,
  });
};
```

## 📊 数据流图

```
用户点击"登录"
    ↓
Web: socket.emit('master:login:start', { account_id, worker_id })
    ↓
Master: 创建 login_sessions 记录
    ↓
Master: workerSocket.emit('master:login:start', { account_id, platform, proxy })
    ↓
Worker: 检查/创建账户浏览器实例
    ↓
Worker: platformInstance.startLogin()
    ↓
Platform: detectLoginMethod() → 'qrcode' | 'sms'
    ↓
─────────────────────────────────────────────
│ 分支1: 二维码登录                          │
├─────────────────────────────────────────────┤
│ Platform: handleQRCodeLogin()              │
│   ↓                                        │
│ Platform: 截取二维码 → sendLoginStatus()   │
│   ↓                                        │
│ Master: adminSocket.emit('login:status:update')│
│   ↓                                        │
│ Web: 显示二维码模态框                      │
│   ↓                                        │
│ Platform: waitForLogin() 心跳检测          │
│   ↓                                        │
│ User: 扫码确认                             │
│   ↓                                        │
│ Platform: checkLoginStatus() → logged_in   │
│   ↓                                        │
│ Platform: saveLoginState() 保存 Cookie     │
│   ↓                                        │
│ Platform: sendLoginStatus('success')       │
│   ↓                                        │
│ Web: 显示"登录成功"                        │
─────────────────────────────────────────────
│ 分支2: 短信验证登录                        │
├─────────────────────────────────────────────┤
│ Platform: handleSMSLogin()                 │
│   ↓                                        │
│ Platform: sendLoginStatus('sms_input_required', step='phone_number')│
│   ↓                                        │
│ Web: 显示手机号输入框                      │
│   ↓                                        │
│ User: 输入手机号                           │
│   ↓                                        │
│ Web: socket.emit('master:login:user_input')│
│   ↓                                        │
│ Worker: 收到输入 → 填充到页面             │
│   ↓                                        │
│ Platform: 点击"获取验证码"                 │
│   ↓                                        │
│ Platform: sendLoginStatus('sms_input_required', step='verification_code')│
│   ↓                                        │
│ Web: 显示验证码输入框                      │
│   ↓                                        │
│ User: 输入验证码                           │
│   ↓                                        │
│ Platform: 填充验证码 → 点击登录           │
│   ↓                                        │
│ Platform: waitForLogin() → logged_in       │
│   ↓                                        │
│ Web: 显示"登录成功"                        │
─────────────────────────────────────────────
```

## 🔧 核心优势

### 1. 账户完全隔离
- ✅ 每个账户独立的 Browser 进程
- ✅ 独立的指纹配置（不会相互影响）
- ✅ 独立的 Cookie 存储
- ✅ 支持不同的代理配置

### 2. 框架级通用方法
- ✅ `detectLoginMethod()` - 智能识别登录方式
- ✅ `waitForLogin()` - 通用的登录心跳检测
- ✅ `checkLoginStatus()` - 多种方式检测登录状态
- ✅ `saveLoginState()` - 自动保存登录状态

### 3. 支持多种登录方式
- ✅ 二维码扫码登录
- ✅ 手机短信验证登录
- ✅ 账号密码登录（如果平台支持）
- ✅ Cookie 导入登录

### 4. 用户体验优化
- ✅ 实时状态更新
- ✅ 统一的登录模态框
- ✅ 智能识别登录方式，无需用户选择
- ✅ 详细的进度提示

## 📝 下一步实施计划

1. **修改 `PlatformBase`** - 添加通用登录框架方法
2. **实现 `DouyinPlatform`** - 实现抖音的登录检测逻辑
3. **创建 `LoginStatusMonitor`** - 独立的心跳检测类
4. **更新 Web 端组件** - 支持多登录方式的统一模态框
5. **测试账户隔离** - 验证多账户同时登录的隔离性

---

**文档创建时间**: 2025-10-16  
**维护人员**: Development Team
