# 监控刷新时间配置说明

**最后更新**: 2025-10-13

---

## 🎯 快速回答

### 当前配置

| 项目 | 默认值 | 可配置范围 | 说明 |
|------|--------|-----------|------|
| **评论刷新** | 30秒 | 10-300秒 | 与私信使用相同间隔 |
| **私信刷新** | 30秒 | 10-300秒 | 与评论使用相同间隔 |

**关键点**:
- ✅ 评论和私信**使用同一个刷新间隔**（`monitor_interval`）
- ✅ 每次刷新会**同时检测**评论和私信
- ✅ 每个账户可以**独立配置**刷新间隔

---

## 📊 详细说明

### 1. 配置位置

#### 数据库默认值
```sql
-- packages/master/src/database/schema.sql:15
CREATE TABLE IF NOT EXISTS accounts (
  ...
  monitor_interval INTEGER DEFAULT 30,  -- 默认30秒
  ...
);
```

#### 模型默认值
```javascript
// packages/shared/models/Account.js:73
this.monitor_interval = data.monitor_interval || 30;  // 默认30秒
```

#### 限流器默认值
```javascript
// packages/worker/src/handlers/rate-limiter.js:26
this.defaultInterval = 30;  // 默认30秒间隔
```

### 2. 监控任务执行流程

```javascript
// packages/worker/src/handlers/monitor-task.js:106-158

async execute() {
  // 每次执行会同时检测评论和私信

  // 1. 爬取评论
  const rawComments = await this.crawler.crawlComments(this.account);

  // 2. 解析评论
  const parsedComments = this.commentParser.parse(rawComments);

  // 3. 过滤新评论
  const newComments = this.cacheHandler.filterNew(...);

  // 4. 爬取私信 (在同一次执行中)
  const rawDMs = await this.crawler.crawlDirectMessages(this.account);

  // 5. 解析私信
  const parsedDMs = this.dmParser.parse(rawDMs);

  // 6. 过滤新私信
  const newDMs = this.cacheHandler.filterNew(...);

  // 7. 上报新消息
  if (newComments.length > 0 || newDMs.length > 0) {
    this.messageReporter.reportAll(this.account.id, {
      comments: newComments,
      directMessages: newDMs,
    });
  }
}
```

**执行特点**:
- ✅ 评论和私信在**同一次循环**中检测
- ✅ 使用**相同的时间间隔**
- ✅ 一次执行包含完整的检测流程

### 3. 定时执行机制

```javascript
// packages/worker/src/handlers/monitor-task.js:40-71

async start() {
  // 立即执行一次
  this.execute();

  // 设置定时执行
  const intervalMs = this.account.monitor_interval * 1000;  // 转换为毫秒
  this.intervalId = setInterval(() => {
    this.execute();
  }, intervalMs);

  logger.info(`Monitor task started with ${this.account.monitor_interval}s interval`);
}
```

**示例**: 如果 `monitor_interval = 30`
```
0秒:  执行一次 (立即)
30秒: 执行第二次
60秒: 执行第三次
90秒: 执行第四次
...
```

---

## ⚙️ 配置方式

### 1. 添加账户时配置

#### Web管理后台
```javascript
// packages/admin-web/src/pages/AccountsPage.js:266
<Form.Item name="monitor_interval" label="监控间隔（秒）" initialValue={30}>
  <Input type="number" placeholder="监控间隔" />
</Form.Item>
```

#### 桌面客户端
```javascript
// packages/desktop-client/src/renderer/components/AddAccountDialog.jsx:134-138
<FormItem
  label="监控间隔(秒)"
  name="monitor_interval"
  rules={[
    { required: true, message: '请输入监控间隔' },
    { type: 'number', min: 10, max: 300, message: '监控间隔必须在10-300秒之间' },
  ]}
>
  <Input type="number" placeholder="30" />
</FormItem>
```

### 2. 更新账户配置

#### API方式
```bash
# PUT /api/accounts/:id
curl -X PUT http://localhost:3000/api/accounts/acc-123 \
  -H "Content-Type: application/json" \
  -d '{
    "monitor_interval": 60
  }'
```

#### 程序内更新
```javascript
// packages/worker/src/handlers/monitor-task.js:165-178

updateAccount(updates) {
  const oldInterval = this.account.monitor_interval;

  Object.assign(this.account, updates);

  // 如果监控间隔改变,重启任务
  if (updates.monitor_interval && updates.monitor_interval !== oldInterval) {
    logger.info(`Restarting task due to interval change: ${oldInterval}s -> ${updates.monitor_interval}s`);

    this.stop().then(() => {
      this.start();
    });
  }
}
```

**特点**:
- ✅ 支持动态修改
- ✅ 修改后自动重启任务
- ✅ 新间隔立即生效

---

## 🔒 限制和验证

### 1. 范围限制

#### 模型验证
```javascript
// packages/shared/models/Account.js:105-107
if (this.monitor_interval < 10 || this.monitor_interval > 300) {
  errors.push('Monitor interval must be 10-300 seconds');
}
```

#### 表单验证
```javascript
// packages/desktop-client/src/renderer/components/AddAccountDialog.jsx:138
{ type: 'number', min: 10, max: 300, message: '监控间隔必须在10-300秒之间' }
```

### 2. 限制说明

| 限制类型 | 值 | 原因 |
|---------|-----|------|
| **最小间隔** | 10秒 | 防止频繁请求触发平台限流 |
| **最大间隔** | 300秒(5分钟) | 确保及时性,避免消息延迟过大 |
| **推荐值** | 30秒 | 平衡实时性和资源消耗 |

### 3. 平台限流保护

```javascript
// packages/worker/src/handlers/rate-limiter.js

class RateLimiter {
  // 默认30秒间隔
  defaultInterval = 30;

  // 最小间隔10秒
  minInterval = 10;

  // 最大间隔300秒
  maxInterval = 300;

  // 检测到限流时自动增加间隔
  async checkRateLimit(accountId, response) {
    if (this.isRateLimited(response)) {
      const currentInterval = this.intervals.get(accountId) || this.defaultInterval;
      const newInterval = Math.min(currentInterval * 2, this.maxInterval);

      this.updateInterval(accountId, newInterval);
      logger.warn(`Rate limited! Increased interval to ${newInterval}s`);
    }
  }
}
```

**自动调整逻辑**:
```
检测到限流 → 间隔翻倍
30秒 → 60秒 → 120秒 → 240秒 → 300秒(最大)
        ↓
    恢复正常 → 逐步降低回30秒
```

---

## 📈 实时性分析

### 不同间隔的效果

| 间隔 | 延迟范围 | 资源占用 | 适用场景 |
|------|---------|---------|---------|
| **10秒** | 0-10秒 | 高 | 高价值账户,需要极快响应 |
| **30秒** | 0-30秒 | 中 | **推荐**,平衡实时性和资源 |
| **60秒** | 0-60秒 | 低 | 普通账户,可接受延迟 |
| **120秒** | 0-120秒 | 很低 | 低优先级账户 |
| **300秒** | 0-300秒 | 极低 | 备用账户,仅需定期检查 |

### 资源消耗估算

假设10个账户:

| 间隔 | 每小时请求次数 | CPU占用 | 内存占用 |
|------|---------------|---------|---------|
| 10秒 | 36,000次 | ~15% | ~2.5GB |
| 30秒 | 12,000次 | ~8% | ~2.2GB |
| 60秒 | 6,000次 | ~5% | ~2.1GB |

**说明**: 内存主要由Browser进程占用(~200MB/账户),与间隔关系不大

---

## 🧪 测试验证

### 测试1: 验证刷新间隔

```javascript
// 启动Worker后查看日志
Worker进程启动:
✓ Browser manager initialized
✓ Task runner started

监控任务启动 (account-123):
Monitor task started with 30s interval

执行日志:
[10:00:00] Executing monitor task (count: 1) - 立即执行
[10:00:30] Executing monitor task (count: 2) - 30秒后
[10:01:00] Executing monitor task (count: 3) - 60秒后
[10:01:30] Executing monitor task (count: 4) - 90秒后
```

### 测试2: 修改刷新间隔

```bash
# 1. 初始配置30秒
curl http://localhost:3000/api/accounts/acc-123
# 返回: { "monitor_interval": 30 }

# 2. 修改为60秒
curl -X PUT http://localhost:3000/api/accounts/acc-123 \
  -d '{"monitor_interval": 60}'

# 3. 观察日志
Worker日志:
Restarting task due to interval change: 30s -> 60s
Stopping monitor task for account acc-123
Monitor task stopped
Starting monitor task with 60s interval
Monitor task started with 60s interval
```

### 测试3: 验证同时检测

```javascript
// 查看单次执行日志
[10:00:00] Executing monitor task (count: 1)
[10:00:02] Crawling comments...
[10:00:05] Found 3 raw comments
[10:00:05] Parsing comments...
[10:00:05] Filtering new comments... (2 new)
[10:00:06] Crawling direct messages...  // ← 同一次执行
[10:00:08] Found 1 raw DM
[10:00:08] Parsing DMs...
[10:00:08] Filtering new DMs... (1 new)
[10:00:09] Reporting 2 comments and 1 DM
[10:00:09] Monitor execution completed
```

---

## 💡 最佳实践

### 1. 推荐配置

| 账户类型 | 推荐间隔 | 原因 |
|---------|---------|------|
| **VIP客户** | 10-15秒 | 需要极快响应 |
| **普通账户** | 30秒 | 平衡实时性和资源 |
| **低优先级** | 60-120秒 | 降低资源消耗 |
| **备用账户** | 180-300秒 | 仅定期检查 |

### 2. 性能优化建议

#### 方案1: 分级监控
```javascript
// 高优先级账户: 10秒
account_vip.monitor_interval = 10;

// 普通账户: 30秒
account_normal.monitor_interval = 30;

// 低优先级账户: 60秒
account_low.monitor_interval = 60;
```

#### 方案2: 动态调整
```javascript
// 工作时间: 30秒
if (isBusinessHours()) {
  account.monitor_interval = 30;
}

// 非工作时间: 120秒
else {
  account.monitor_interval = 120;
}
```

#### 方案3: 智能间隔
```javascript
// 根据消息频率自动调整
if (highMessageRate) {
  // 消息频繁 → 缩短间隔
  account.monitor_interval = 15;
} else if (lowMessageRate) {
  // 消息稀少 → 延长间隔
  account.monitor_interval = 60;
}
```

### 3. 避免的配置

❌ **过小的间隔 (<10秒)**
```javascript
// 危险! 可能触发平台限流
account.monitor_interval = 5;  // ❌ 不推荐
```

❌ **所有账户使用相同的最小间隔**
```javascript
// 危险! 资源消耗过大
accounts.forEach(acc => {
  acc.monitor_interval = 10;  // ❌ 不推荐
});
```

❌ **频繁修改间隔**
```javascript
// 低效! 每次修改都会重启任务
setInterval(() => {
  account.monitor_interval = Math.random() * 100;  // ❌ 不推荐
}, 10000);
```

---

## 🔧 故障排查

### 问题1: 消息延迟过大

**症状**: 实际消息10分钟前发送,现在才收到

**可能原因**:
1. `monitor_interval` 设置过大 (如300秒)
2. Worker进程卡顿
3. 爬虫执行时间过长

**解决方案**:
```javascript
// 1. 检查当前间隔
GET /api/accounts/:id
// 返回: { "monitor_interval": 300 }  ← 间隔过大!

// 2. 调整为更短的间隔
PUT /api/accounts/:id
{ "monitor_interval": 30 }

// 3. 观察Worker日志
// 确认任务正常执行
```

### 问题2: 频繁触发限流

**症状**: 日志中频繁出现 "Rate limited" 警告

**可能原因**:
1. `monitor_interval` 设置过小 (<10秒)
2. 多个账户同时请求
3. 平台限流策略变化

**解决方案**:
```javascript
// 1. 增加监控间隔
PUT /api/accounts/:id
{ "monitor_interval": 60 }

// 2. 检查RateLimiter自动调整
// Worker日志会显示:
// "Rate limited! Increased interval to 60s"

// 3. 等待限流恢复 (通常5-30分钟)
```

### 问题3: 任务不执行

**症状**: Worker启动,但监控任务没有执行

**可能原因**:
1. 账户未分配到Worker
2. 账户状态为 'paused'
3. Worker与Master连接断开

**排查步骤**:
```javascript
// 1. 检查账户分配状态
GET /api/accounts/:id
// 返回: { "assigned_worker_id": null }  ← 未分配!

// 2. 检查账户状态
// 返回: { "status": "paused" }  ← 已暂停!

// 3. 检查Worker连接
// Worker日志应显示:
// "✓ Connected to master"
// "✓ Registered with master (3 accounts assigned)"
```

---

## 📚 相关文档

- [监控任务处理器源码](../packages/worker/src/handlers/monitor-task.js)
- [账户模型定义](../packages/shared/models/Account.js)
- [限流器实现](../packages/worker/src/handlers/rate-limiter.js)
- [数据库Schema](../packages/master/src/database/schema.sql)
- [多Browser架构详解](./architecture/多Browser架构详解.md)

---

## 🎉 总结

### 核心要点

1. **统一间隔**: 评论和私信使用**同一个刷新间隔** (`monitor_interval`)
2. **默认值**: 30秒 (平衡实时性和资源消耗)
3. **可配置**: 10-300秒范围,每个账户独立配置
4. **同时检测**: 每次刷新会同时爬取评论和私信
5. **动态调整**: 支持运行时修改,自动重启任务

### 快速配置

```javascript
// 推荐配置 (30秒)
{
  "account_name": "测试账户",
  "platform": "douyin",
  "monitor_interval": 30  // ← 评论和私信都是30秒
}

// VIP账户 (10秒)
{
  "monitor_interval": 10  // 更快响应
}

// 低优先级 (120秒)
{
  "monitor_interval": 120  // 降低资源消耗
}
```

---

**文档版本**: 1.0.0
**最后更新**: 2025-10-13
**维护者**: 开发团队
