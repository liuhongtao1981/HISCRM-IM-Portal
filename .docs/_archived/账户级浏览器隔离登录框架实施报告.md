# 账户级浏览器隔离登录框架实施报告

## 📋 实施总结

已完成通用登录框架的核心实现，支持：
- ✅ **账户级浏览器隔离** - 每个账户独立的 Browser 进程
- ✅ **智能登录方式识别** - 自动检测二维码/短信登录
- ✅ **心跳检测登录状态** - 通用的登录状态监控
- ✅ **多种登录方式** - 二维码、短信验证码
- ✅ **用户输入支持** - Web 端输入验证码传递到 Worker

## 🎯 核心设计

### 1. 账户级浏览器隔离架构

```
Worker 数据目录:
packages/worker/data/browser/
  └── {worker_id}/
      ├── fingerprints/           ← 账户指纹配置
      │   ├── account-123_fingerprint.json
      │   └── account-456_fingerprint.json
      ├── storage/                ← Cookie 和 Storage
      │   ├── account-123_storage.json
      │   └── account-456_storage.json
      └── user-info/              ← 用户信息
          ├── account-123_user.json
          └── account-456_user.json
```

**特点**:
- 每个账户有独立的 Browser 进程
- 独立的指纹配置（Canvas、WebGL、Audio）
- 独立的 Cookie 和 LocalStorage
- 持久化登录状态

### 2. 通用登录框架方法

**位置**: `packages/worker/src/platforms/base/platform-base.js`

已添加的方法：

#### 2.1 检测登录方式
```javascript
async detectLoginMethod(page)
```
- **作用**: 智能识别登录界面类型
- **返回**: `{ type: 'qrcode'|'sms'|'password'|'logged_in'|'unknown', element?, data? }`
- **说明**: 子类需要实现平台特定的检测逻辑

#### 2.2 心跳检测登录状态
```javascript
async waitForLogin(page, accountId, sessionId, options)
```
- **作用**: 定期检测页面是否已登录
- **参数**:
  - `timeout`: 超时时间（默认 5 分钟）
  - `checkInterval`: 检查间隔（默认 2 秒）
  - `checkMethod`: 检测方法 'auto' | 'element' | 'cookie' | 'url'
- **特点**: 
  - 自动检测登录成功
  - 支持多种检测方式
  - 实时通知 Web 端状态变化

#### 2.3 检查登录状态
```javascript
async checkLoginStatus(page, method)
```
- **方法 1**: 检查特定元素（`.user-info`, `.user-avatar`）
- **方法 2**: 检查 Cookie（`session`, `token`, `sid`）
- **方法 3**: 检查 URL 变化（不再是登录页）
- **方法 4**: 检查扫码状态（`.qr-scanning`）
- **方法 5**: 检查过期状态（`.qr-expired`）

#### 2.4 处理二维码登录
```javascript
async handleQRCodeLogin(page, accountId, sessionId, options)
```
- **流程**:
  1. 等待二维码元素
  2. 截取二维码图片
  3. 获取过期时间
  4. 发送二维码到 Web
  5. 启动心跳监控
  6. 等待登录成功

#### 2.5 处理短信验证码登录
```javascript
async handleSMSLogin(page, accountId, sessionId, options)
```
- **流程**:
  1. 检测手机号输入框
  2. 通知 Web 端需要输入手机号
  3. 等待用户输入
  4. 填充手机号到页面
  5. 点击"获取验证码"
  6. 通知 Web 端需要输入验证码
  7. 等待用户输入验证码
  8. 填充验证码并登录
  9. 等待登录成功

#### 2.6 保存登录状态
```javascript
async saveLoginState(page, accountId)
```
- **保存内容**:
  - Storage State（Cookie、LocalStorage、SessionStorage）
  - 用户信息（头像、昵称、UID）
- **路径**: 
  - Storage: `data/browser/storage/account-{id}_storage.json`
  - User Info: `data/browser/user-info/account-{id}_user.json`

#### 2.7 提取用户信息
```javascript
async extractUserInfo(page)
```
- **提取内容**: 头像、昵称、UID
- **说明**: 子类可以覆盖实现平台特定的提取逻辑

### 3. 用户输入支持

**位置**: `packages/worker/src/platforms/base/worker-bridge.js`

已添加的方法：

#### 3.1 监听用户输入
```javascript
onUserInput(sessionId, inputType, callback)
```
- **作用**: 注册用户输入回调
- **输入类型**: `'phone_number'` | `'verification_code'`

#### 3.2 触发用户输入
```javascript
triggerUserInput(sessionId, inputType, value)
```
- **作用**: 触发已注册的回调函数
- **调用者**: Worker 主进程

#### 3.3 移除监听器
```javascript
removeUserInputListener(sessionId, inputType)
```
- **作用**: 清理超时或已完成的监听器

### 4. Worker 主进程集成

**位置**: `packages/worker/src/index.js`

已添加：

#### 4.1 监听用户输入事件
```javascript
socketClient.socket.on('master:login:user_input', (data) => {
  handleUserInput(data);
});
```

#### 4.2 处理用户输入
```javascript
function handleUserInput(data) {
  const { session_id, input_type, value } = data;
  
  // 触发 WorkerBridge 的用户输入回调
  workerBridge.triggerUserInput(session_id, input_type, value);
}
```

## 🔄 完整登录流程

### 二维码登录流程

```
1. User 点击"登录" (AccountsPage.js)
   ↓
2. Web: socket.emit('master:login:start', { account_id, worker_id, platform })
   ↓
3. Master: 创建 login_sessions 记录
   ↓
4. Master: workerSocket.emit('master:login:start', { account_id, session_id, platform, proxy })
   ↓
5. Worker: handleLoginRequest()
   ↓
6. Platform: startLogin()
   ↓
7. Platform: detectLoginMethod() → 'qrcode'
   ↓
8. Platform: handleQRCodeLogin()
   ├─ 截取二维码
   ├─ sendLoginStatus('qrcode_ready', { qr_code_data })
   └─ waitForLogin() 启动心跳
   ↓
9. Master: 转发 → Admin Web
   ↓
10. Web: 显示二维码模态框
   ↓
11. User: 扫码确认
   ↓
12. Platform: checkLoginStatus() 检测到已登录
   ├─ saveLoginState() 保存 Cookie
   └─ sendLoginStatus('success', { user_info })
   ↓
13. Web: 显示"登录成功"，关闭模态框
```

### 短信验证码登录流程

```
1-7. [同上]
   ↓
8. Platform: detectLoginMethod() → 'sms'
   ↓
9. Platform: handleSMSLogin()
   ├─ sendLoginStatus('sms_input_required', { step: 'phone_number' })
   └─ waitForUserInput('phone_number')
   ↓
10. Web: 显示手机号输入框
   ↓
11. User: 输入手机号
   ↓
12. Web: socket.emit('master:login:user_input', { session_id, input_type: 'phone_number', value })
   ↓
13. Master: 转发 → Worker
   ↓
14. Worker: handleUserInput() → workerBridge.triggerUserInput()
   ↓
15. Platform: 收到手机号，填充到页面
   ├─ 点击"获取验证码"
   ├─ sendLoginStatus('sms_input_required', { step: 'verification_code' })
   └─ waitForUserInput('verification_code')
   ↓
16. Web: 显示验证码输入框
   ↓
17. User: 输入验证码
   ↓
18. [重复步骤 12-14]
   ↓
19. Platform: 收到验证码，填充并提交
   ├─ waitForLogin() 等待登录成功
   ├─ saveLoginState()
   └─ sendLoginStatus('success')
   ↓
20. Web: 显示"登录成功"
```

## 📊 数据流图

```
┌─────────────────────────────────────────────────────────┐
│                   Admin Web (React)                     │
│  ┌────────────────┐         ┌──────────────────┐       │
│  │ AccountsPage   │         │  LoginModal      │       │
│  │ "登录" button  │ ──────> │  - QR Code       │       │
│  └────────────────┘         │  - SMS Input     │       │
│         │                   └──────────────────┘       │
└─────────┼───────────────────────────────────────────────┘
          │ Socket.IO (/admin namespace)
          ↓
┌─────────────────────────────────────────────────────────┐
│                   Master Server                         │
│  ┌────────────────────────────────────────────────┐    │
│  │ admin-namespace.js                             │    │
│  │  - master:login:start                          │    │
│  │  - master:login:user_input (转发)             │    │
│  │  - 创建 login_sessions                         │    │
│  │  - 查询代理配置                                │    │
│  └────────────────────────────────────────────────┘    │
└─────────┼───────────────────────────────────────────────┘
          │ Socket.IO (/worker namespace)
          ↓
┌─────────────────────────────────────────────────────────┐
│                   Worker (Node.js)                      │
│  ┌────────────────────────────────────────────────┐    │
│  │ index.js                                       │    │
│  │  - handleLoginRequest()                        │    │
│  │  - handleUserInput() ← NEW!                   │    │
│  └────────────────────────────────────────────────┘    │
│                      ↓                                  │
│  ┌────────────────────────────────────────────────┐    │
│  │ WorkerBridge                                   │    │
│  │  - onUserInput() ← NEW!                       │    │
│  │  - triggerUserInput() ← NEW!                  │    │
│  │  - sendLoginStatus()                           │    │
│  └────────────────────────────────────────────────┘    │
│                      ↓                                  │
│  ┌────────────────────────────────────────────────┐    │
│  │ PlatformManager                                │    │
│  │  - getPlatform(platform)                       │    │
│  └────────────────────────────────────────────────┘    │
│                      ↓                                  │
│  ┌────────────────────────────────────────────────┐    │
│  │ PlatformBase ← NEW METHODS!                   │    │
│  │  - detectLoginMethod() ← 框架方法             │    │
│  │  - waitForLogin() ← 框架方法                  │    │
│  │  - checkLoginStatus() ← 框架方法              │    │
│  │  - handleQRCodeLogin() ← 框架方法             │    │
│  │  - handleSMSLogin() ← 框架方法                │    │
│  │  - saveLoginState() ← 框架方法                │    │
│  │  - waitForUserInput() ← 框架方法              │    │
│  └────────────────────────────────────────────────┘    │
│                      ↓                                  │
│  ┌────────────────────────────────────────────────┐    │
│  │ DouyinPlatform (需要实现)                     │    │
│  │  - startLogin()                                │    │
│  │  - detectLoginMethod() ← 需要实现             │    │
│  │  - checkLoginStatus() ← 可选覆盖              │    │
│  └────────────────────────────────────────────────┘    │
│                      ↓                                  │
│  ┌────────────────────────────────────────────────┐    │
│  │ BrowserManagerV2                               │    │
│  │  - launchBrowserForAccount() ← 已存在         │    │
│  │  - createContextForAccount() ← 已存在         │    │
│  │  - getOrCreateFingerprintConfig() ← 已存在    │    │
│  └────────────────────────────────────────────────┘    │
│                      ↓                                  │
│  ┌────────────────────────────────────────────────┐    │
│  │ Playwright Browser                             │    │
│  │  - 每个账户独立的 Browser 进程                │    │
│  │  - 独立的指纹、Cookie、Storage                │    │
│  └────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

## 📁 已修改的文件

### 1. PlatformBase - 添加通用登录框架
**文件**: `packages/worker/src/platforms/base/platform-base.js`

**新增方法** (约 300 行代码):
- `detectLoginMethod(page)` - 检测登录方式
- `waitForLogin(page, accountId, sessionId, options)` - 心跳检测登录
- `checkLoginStatus(page, method)` - 检查登录状态
- `handleQRCodeLogin(page, accountId, sessionId, options)` - 二维码登录
- `handleSMSLogin(page, accountId, sessionId, options)` - 短信登录
- `waitForUserInput(sessionId, inputType, options)` - 等待用户输入
- `saveLoginState(page, accountId)` - 保存登录状态
- `extractUserInfo(page)` - 提取用户信息
- `parseExpiryTime(expiryText)` - 解析过期时间

### 2. WorkerBridge - 添加用户输入支持
**文件**: `packages/worker/src/platforms/base/worker-bridge.js`

**新增**:
- `userInputListeners` 属性 - 用户输入监听器 Map
- `onUserInput(sessionId, inputType, callback)` - 注册监听器
- `triggerUserInput(sessionId, inputType, value)` - 触发回调
- `removeUserInputListener(sessionId, inputType)` - 移除监听器

### 3. Worker 主进程 - 处理用户输入事件
**文件**: `packages/worker/src/index.js`

**新增**:
- 监听 `master:login:user_input` 事件
- `handleUserInput(data)` 函数

## 🎯 下一步任务

### 任务 3: 实现抖音登录方式检测 ⏳
**文件**: `packages/worker/src/platforms/douyin/platform.js`

需要实现：
```javascript
async detectLoginMethod(page) {
  await page.goto('https://www.douyin.com/', { waitUntil: 'networkidle' });
  
  // 检查是否已登录
  const userInfo = await page.$('.user-avatar, [data-e2e="user-info"]');
  if (userInfo) {
    return { type: 'logged_in', data: await this.extractUserInfo(page) };
  }
  
  // 检查二维码登录
  const qrcode = await page.$('.login__qrcode-img, .qrcode-img');
  if (qrcode) {
    return { type: 'qrcode', element: qrcode };
  }
  
  // 检查短信登录
  const phoneInput = await page.$('input[placeholder*="手机号"]');
  if (phoneInput) {
    return { type: 'sms', element: phoneInput };
  }
  
  return { type: 'unknown' };
}
```

### 任务 4: 集成通用登录框架到抖音平台 ⏳
**文件**: `packages/worker/src/platforms/douyin/platform.js`

修改 `startLogin()` 方法：
```javascript
async startLogin(options) {
  const { accountId, sessionId, proxy } = options;
  
  try {
    // 1. 创建账户浏览器上下文
    const context = await this.browserManager.getOrCreateContext(accountId, { proxy });
    const page = await context.newPage();
    
    // 2. 检测登录方式
    const loginMethod = await this.detectLoginMethod(page);
    
    // 3. 根据登录方式处理
    if (loginMethod.type === 'logged_in') {
      await this.sendLoginStatus(sessionId, 'success', {
        account_id: accountId,
        user_info: loginMethod.data,
      });
      return true;
    }
    
    if (loginMethod.type === 'qrcode') {
      return await this.handleQRCodeLogin(page, accountId, sessionId, {
        qrSelector: '.login__qrcode-img, .qrcode-img',
      });
    }
    
    if (loginMethod.type === 'sms') {
      return await this.handleSMSLogin(page, accountId, sessionId);
    }
    
    throw new Error(`Unsupported login method: ${loginMethod.type}`);
    
  } catch (error) {
    logger.error(`Login failed for account ${accountId}:`, error);
    await this.sendLoginStatus(sessionId, 'failed', {
      account_id: accountId,
      error_message: error.message,
    });
    throw error;
  }
}
```

### 任务 5: 更新 Master 转发用户输入 ⏳
**文件**: `packages/master/src/socket/admin-namespace.js`

需要添加：
```javascript
// 监听 Web 端的用户输入
socket.on('master:login:user_input', async (data) => {
  const { session_id, input_type, value } = data;
  
  try {
    logger.info(`Received user input from admin for session ${session_id}, type: ${input_type}`);
    
    // 查询 login_sessions 获取 worker_id
    const session = db.prepare('SELECT worker_id FROM login_sessions WHERE id = ?').get(session_id);
    
    if (!session) {
      socket.emit('admin:error', { error: 'Login session not found' });
      return;
    }
    
    // 转发到对应的 Worker
    const workerNamespace = io.of('/worker');
    const workerSockets = await workerNamespace.fetchSockets();
    
    for (const workerSocket of workerSockets) {
      if (workerSocket.workerId === session.worker_id) {
        workerSocket.emit('master:login:user_input', {
          session_id,
          input_type,
          value,
        });
        
        logger.info(`User input forwarded to worker ${session.worker_id}`);
        break;
      }
    }
    
  } catch (error) {
    logger.error('Failed to handle user input:', error);
    socket.emit('admin:error', { error: error.message });
  }
});
```

### 任务 6: 更新 Web 端登录界面 ⏳
**文件**: 需要创建/修改多个文件

#### 6.1 创建统一的 LoginModal
**文件**: `packages/admin-web/src/components/LoginModal.jsx`

```javascript
import React from 'react';
import { Modal, Image, Input, Button, Form, Typography, Space, Progress } from 'antd';
import { QrcodeOutlined, MobileOutlined } from '@ant-design/icons';

const { Text } = Typography;

const LoginModal = ({ visible, onCancel, loginData, onSubmitInput }) => {
  const { login_method, step, qr_code_data, expires_at, message, phone_number } = loginData || {};
  
  // 二维码登录
  if (login_method === 'qrcode') {
    return (
      <Modal
        visible={visible}
        onCancel={onCancel}
        footer={null}
        title={<Space><QrcodeOutlined />扫码登录</Space>}
      >
        <div style={{ textAlign: 'center' }}>
          <Image 
            src={qr_code_data} 
            alt="QR Code"
            width={300}
            preview={false}
          />
          <Text type="secondary" style={{ display: 'block', marginTop: 16 }}>
            请使用抖音 App 扫描二维码
          </Text>
          {/* 倒计时进度条 */}
        </div>
      </Modal>
    );
  }
  
  // 短信验证登录
  if (login_method === 'sms') {
    // 输入手机号
    if (step === 'phone_number') {
      return (
        <Modal
          visible={visible}
          onCancel={onCancel}
          title={<Space><MobileOutlined />手机号登录</Space>}
          footer={null}
        >
          <Form onFinish={(values) => onSubmitInput('phone_number', values.phone)}>
            <Form.Item
              name="phone"
              rules={[{ required: true, message: '请输入手机号' }]}
            >
              <Input 
                placeholder="请输入手机号" 
                size="large"
              />
            </Form.Item>
            <Form.Item>
              <Button type="primary" htmlType="submit" block>
                获取验证码
              </Button>
            </Form.Item>
          </Form>
        </Modal>
      );
    }
    
    // 输入验证码
    if (step === 'verification_code') {
      return (
        <Modal
          visible={visible}
          onCancel={onCancel}
          title={<Space><MobileOutlined />输入验证码</Space>}
          footer={null}
        >
          <Text type="secondary" style={{ display: 'block', marginBottom: 16 }}>
            验证码已发送至 {phone_number}
          </Text>
          <Form onFinish={(values) => onSubmitInput('verification_code', values.code)}>
            <Form.Item
              name="code"
              rules={[{ required: true, message: '请输入验证码' }]}
            >
              <Input 
                placeholder="请输入验证码" 
                size="large"
                maxLength={6}
              />
            </Form.Item>
            <Form.Item>
              <Button type="primary" htmlType="submit" block>
                登录
              </Button>
            </Form.Item>
          </Form>
        </Modal>
      );
    }
  }
  
  return null;
};

export default LoginModal;
```

#### 6.2 更新 socketContext.js
**文件**: `packages/admin-web/src/services/socketContext.js`

需要添加：
```javascript
// 监听登录状态更新（包括二维码和短信）
socket.on('login:status:update', (data) => {
  const { account_id, session_id, status, ...extraData } = data;
  
  switch (status) {
    case 'qrcode_ready':
      setLoginModalData({
        visible: true,
        session_id,
        login_method: 'qrcode',
        qr_code_data: extraData.qr_code_data,
        expires_at: extraData.expires_at,
      });
      break;
      
    case 'sms_input_required':
      setLoginModalData({
        visible: true,
        session_id,
        login_method: 'sms',
        step: extraData.step,
        message: extraData.message,
        phone_number: extraData.phone_number,
      });
      break;
      
    case 'scanning':
      message.info('正在扫码中...');
      break;
      
    case 'success':
      message.success('登录成功！');
      setLoginModalData({ visible: false });
      break;
      
    case 'failed':
    case 'timeout':
      message.error(extraData.error_message || '登录失败');
      setLoginModalData({ visible: false });
      break;
  }
});

// 提交用户输入
const submitUserInput = useCallback((sessionId, inputType, value) => {
  if (socket) {
    socket.emit('master:login:user_input', {
      session_id: sessionId,
      input_type: inputType,
      value: value,
    });
  }
}, [socket]);
```

## 🎉 已完成的功能

✅ **通用登录框架**
- PlatformBase 中的 8 个框架方法
- 支持二维码和短信验证码登录
- 心跳检测登录状态
- 自动保存登录状态

✅ **用户输入支持**
- WorkerBridge 用户输入监听机制
- Worker 主进程集成
- 支持异步等待用户输入

✅ **账户级浏览器隔离**
- 每个账户独立 Browser 进程（已有 BrowserManagerV2）
- 独立指纹配置（已有）
- 独立 Cookie 存储（已有）

## ⏳ 待实施的任务

🔲 **抖音平台集成**
- 实现 `detectLoginMethod()`
- 修改 `startLogin()` 使用通用框架

🔲 **Master 端**
- 转发用户输入事件

🔲 **Web 端**
- 创建 `LoginModal` 组件
- 更新 `socketContext.js`
- 集成到 `AccountsPage.js`

## 📝 总结

核心框架已经完成！现在：

1. **PlatformBase** 提供了完整的通用登录框架
2. **WorkerBridge** 支持用户输入的异步等待
3. **Worker 主进程** 可以接收并处理用户输入

接下来只需要：
- 在具体的平台（DouyinPlatform）中调用这些框架方法
- 更新 Master 和 Web 端支持用户输入

**这个架构的优势**：
- 🎯 **通用性** - 所有平台都可以使用这些方法
- 🔧 **灵活性** - 子类可以覆盖或扩展
- 📦 **封装性** - 复杂逻辑封装在框架层
- 🚀 **可扩展** - 轻松添加新的登录方式

---

**创建时间**: 2025-10-16  
**状态**: 核心框架已完成，待集成到具体平台
