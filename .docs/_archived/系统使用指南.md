# HisCrm-IM 系统使用指南

**版本**: 1.0.0
**日期**: 2025-10-12
**适用人员**: 系统管理员、开发人员、运维人员

---

## 目录

1. [系统架构](#系统架构)
2. [快速启动](#快速启动)
3. [账号登录](#账号登录)
4. [代理配置](#代理配置)
5. [监控运维](#监控运维)
6. [错误处理](#错误处理)
7. [API文档](#api文档)
8. [故障排查](#故障排查)

---

## 系统架构

### 组件说明

```
┌─────────────┐
│  管理后台   │ (浏览器访问)
└──────┬──────┘
       │ Socket.IO (/admin)
       │
┌──────▼──────┐
│  主控服务器  │ (Master - 端口3000)
│  - 任务调度  │
│  - 账号管理  │
│  - 登录管理  │
└──────┬──────┘
       │ Socket.IO (/worker)
       │
┌──────▼──────┐
│  工作节点   │ (Worker - 可多个)
│  - 浏览器   │
│  - 爬虫     │
│  - 登录     │
└─────────────┘
```

### 数据库

- **Master**: `data/master.db` (SQLite)
  - accounts (账号表)
  - workers (Worker节点表)
  - login_sessions (登录会话表)
  - comments (评论表)
  - direct_messages (私信表)
  - notifications (通知队列表)
  - proxies (代理服务器表)

- **Worker**: 无数据库,状态保存在文件
  - `data/browser/账号ID_state.json` (浏览器状态)

---

## 快速启动

### 环境要求

- **Node.js**: 18.x LTS
- **操作系统**: Windows 11 / Linux / macOS
- **浏览器**: Chromium (Playwright 自动下载)

### 安装依赖

```bash
# 根目录安装
npm install
```

### 启动服务

#### 方式一: 分别启动 (开发环境)

```bash
# 终端 1: 启动 Master
cd packages/master
npm start

# 终端 2: 启动 Worker
cd packages/worker
npm start
```

#### 方式二: 使用 PM2 (生产环境)

```bash
# 安装 PM2
npm install -g pm2

# 启动 Master
pm2 start packages/master/src/index.js --name "hiscrm-master"

# 启动 Worker (可启动多个)
pm2 start packages/worker/src/index.js --name "hiscrm-worker-1"

# 查看状态
pm2 list

# 查看日志
pm2 logs
```

---

## 账号登录

### 1. 添加账号

```bash
# 使用 API 添加账号
curl -X POST http://localhost:3000/api/accounts \
  -H "Content-Type: application/json" \
  -d '{
    "platform": "douyin",
    "account_name": "测试账号",
    "account_id": "test-account-001",
    "login_status": "not_logged_in",
    "monitor_interval": 30
  }'
```

或直接插入数据库:

```sql
INSERT INTO accounts (
  id, platform, account_name, account_id,
  credentials, status, login_status,
  monitor_interval, created_at, updated_at
) VALUES (
  'acc-' || lower(hex(randomblob(16))),
  'douyin',
  '测试账号',
  'test-account-001',
  '{}',
  'active',
  'not_logged_in',
  30,
  unixepoch(),
  unixepoch()
);
```

### 2. 发起登录

**前端代码示例**:

```javascript
// 连接到 Master
const socket = io('http://localhost:3000/admin');

// 认证
socket.emit('admin:auth', {
  username: 'admin',
  password: 'admin123'
});

// 发起登录
socket.emit('admin:login:start', {
  account_id: 'acc-xxx',
  session_id: `session-${Date.now()}`
});

// 监听二维码
socket.on('login:qrcode:ready', (data) => {
  // 显示二维码
  const img = document.createElement('img');
  img.src = `data:image/png;base64,${data.qr_code_data}`;
  document.body.appendChild(img);
});

// 监听二维码刷新
socket.on('login:qrcode:refreshed', (data) => {
  console.log('二维码已刷新,第', data.refresh_count, '次');
  // 更新显示的二维码
});

// 监听登录成功
socket.on('login:success', (data) => {
  console.log('登录成功!');
});

// 监听登录失败
socket.on('login:failed', (data) => {
  console.error('登录失败:', data.error_message);
});
```

### 3. 登录流程

```
1. 用户点击"登录"
   → Master 创建登录会话
   → Master 分配 Worker
   → Worker 打开浏览器
   → Worker 访问抖音首页

2. 等待二维码
   → Worker 截取二维码
   → Worker 发送到 Master
   → Master 推送到管理后台

3. 显示二维码,用户扫描
   → Worker 轮询登录状态

4a. 扫码成功
    → Worker 检测到登录
    → Worker 保存 Cookies
    → Worker 通知 Master
    → Master 更新数据库

4b. 二维码过期 (150秒)
    → Worker 检测过期
    → Worker 刷新页面
    → Worker 重新截取二维码
    → Worker 发送新二维码
    (最多刷新 3 次)

4c. 登录超时 (5分钟)
    → Worker 停止轮询
    → Worker 通知失败
```

### 4. 登录状态

| 状态 | 说明 |
|------|------|
| `not_logged_in` | 未登录 |
| `logging_in` | 登录中 |
| `logged_in` | 已登录 |
| `login_failed` | 登录失败 |
| `cookies_expired` | Cookies过期 |

---

## 代理配置

### 1. 添加代理

```sql
-- 添加主代理
INSERT INTO proxies (
  id, name, server, protocol,
  username, password, status,
  success_rate, created_at, updated_at
) VALUES (
  'proxy-001',
  '主代理服务器',
  '127.0.0.1:8080',
  'http',
  'proxy_user',
  'proxy_password',
  'active',
  1.0,
  unixepoch(),
  unixepoch()
);

-- 绑定代理到账号
UPDATE accounts
SET proxy_id = 'proxy-001'
WHERE id = 'acc-xxx';
```

### 2. 代理协议

- **HTTP**: `http://proxy-server:port`
- **HTTPS**: `https://proxy-server:port`
- **SOCKS5**: `socks5://proxy-server:port`

### 3. 代理降级策略

系统会自动按以下顺序尝试:

```
1. 主代理 (Primary Proxy)
   ↓ 失败
2. 备用代理 (Fallback Proxy)
   ↓ 失败
3. 直连 (Direct Connection)
```

**健康检查**:
- 超时时间: 10秒
- 测试URL: https://www.baidu.com
- 缓存时间: 5分钟

---

## 监控运维

### 1. 日志查看

```bash
# Master 日志
cd packages/master
npm start | tee master.log

# Worker 日志
cd packages/worker
npm start | tee worker.log

# PM2 日志
pm2 logs hiscrm-master
pm2 logs hiscrm-worker-1
```

### 2. 日志级别

- `debug`: 详细调试信息
- `info`: 一般信息
- `warn`: 警告信息
- `error`: 错误信息

### 3. 监控指标

```bash
# Worker 在线数量
curl http://localhost:3000/api/workers | jq '.[] | select(.status=="online") | .id'

# 账号状态分布
curl http://localhost:3000/api/accounts | jq 'group_by(.login_status) | map({status: .[0].login_status, count: length})'

# 登录会话状态
curl http://localhost:3000/api/login-sessions
```

### 4. 数据库备份

```bash
# 备份数据库
cp packages/master/data/master.db packages/master/data/master.db.backup-$(date +%Y%m%d-%H%M%S)

# 定时备份 (crontab)
0 2 * * * /path/to/backup-script.sh
```

### 5. 清理过期数据

```sql
-- 清理 7 天前的通知
DELETE FROM notifications
WHERE is_sent = 1
AND sent_at < unixepoch() - 7*24*3600;

-- 清理失败的登录会话
DELETE FROM login_sessions
WHERE status = 'failed'
AND created_at < unixepoch() - 24*3600;
```

---

## 错误处理

### 1. 错误类型

系统定义了 18 种错误类型:

| 错误类型 | 说明 | 是否重试 |
|---------|------|---------|
| `network_error` | 网络连接失败 | ✅ 是 |
| `network_timeout` | 网络超时 | ✅ 是 |
| `proxy_error` | 代理连接失败 | ✅ 是 |
| `timeout_error` | 操作超时 | ✅ 是 |
| `qr_code_expired` | 二维码过期 | ✅ 是 (自动刷新) |
| `page_error` | 页面错误 | ⚠️ 视情况 |
| `browser_crashed` | 浏览器崩溃 | ❌ 否 |
| `login_timeout` | 登录超时 | ❌ 否 |

### 2. 重试策略

系统使用**指数退避 + 随机抖动**:

```javascript
// 延迟计算公式
延迟 = 基础延迟 × 2^(尝试次数 - 1) × (1 ± 20% 随机抖动)

// 预定义策略
网络请求:   3次重试, 基础延迟 1秒,  最大延迟 10秒
页面加载:   3次重试, 基础延迟 2秒,  最大延迟 15秒
元素查找:   5次重试, 基础延迟 500ms, 最大延迟 3秒
```

**重试示例**:
```
尝试 1: 立即执行
尝试 2: 延迟 ~1秒 (0.8-1.2秒)
尝试 3: 延迟 ~2秒 (1.6-2.4秒)
尝试 4: 延迟 ~4秒 (3.2-4.8秒)
```

### 3. 二维码刷新

- **检测周期**: 每 2 秒检查一次
- **过期时间**: 150 秒 (2分30秒)
- **最大刷新次数**: 3 次

**刷新流程**:
1. 检测到过期
2. 停止当前轮询
3. 刷新页面
4. 重新截取二维码
5. 发送新二维码
6. 重新开始轮询

---

## API文档

### 1. 账号管理

#### 获取所有账号

```http
GET /api/accounts
```

#### 添加账号

```http
POST /api/accounts
Content-Type: application/json

{
  "platform": "douyin",
  "account_name": "新账号",
  "account_id": "new-account-001",
  "monitor_interval": 30
}
```

#### 更新账号

```http
PUT /api/accounts/:id
Content-Type: application/json

{
  "account_name": "更新的名称",
  "status": "active"
}
```

#### 删除账号

```http
DELETE /api/accounts/:id
```

### 2. Worker管理

#### 获取所有Worker

```http
GET /api/workers
```

### 3. Socket.IO 事件

#### Admin Namespace (`/admin`)

**客户端 → 服务器**:
```javascript
// 认证
socket.emit('admin:auth', {
  username: 'admin',
  password: 'admin123'
});

// 发起登录
socket.emit('admin:login:start', {
  account_id: 'acc-xxx',
  session_id: 'session-xxx'
});
```

**服务器 → 客户端**:
```javascript
// 二维码就绪
socket.on('login:qrcode:ready', (data) => {
  // data.qr_code_data (Base64图片)
});

// 二维码刷新
socket.on('login:qrcode:refreshed', (data) => {
  // data.refresh_count (刷新次数)
});

// 登录成功
socket.on('login:success', (data) => {
  // data.cookies_valid_until (有效期)
});

// 登录失败
socket.on('login:failed', (data) => {
  // data.error_message (错误信息)
  // data.error_type (错误类型)
});
```

---

## 故障排查

### 1. Master 无法启动

**症状**: Master 启动失败或崩溃

**解决方法**:
```bash
# 检查端口占用
netstat -ano | findstr 3000

# 修改端口
PORT=3001 npm start

# 检查数据库
sqlite3 packages/master/data/master.db "PRAGMA integrity_check;"
```

### 2. Worker 无法连接

**症状**: Worker 显示 "Connection failed"

**解决方法**:
```bash
# 检查 Master 是否运行
curl http://localhost:3000/api/workers

# 测试连接
telnet localhost 3000
```

### 3. 浏览器启动失败

**症状**: Worker 日志显示 "Failed to launch browser"

**解决方法**:
```bash
# 安装 Playwright 浏览器
npx playwright install chromium

# Linux 安装系统依赖
npx playwright install-deps
```

### 4. 二维码无法显示

**症状**: 登录时没有收到二维码

**解决方法**:
```javascript
// 开启可见浏览器调试
// packages/worker/src/browser/browser-manager.js
headless: false

// 增加等待时间
this.POPUP_WAIT_TIME = 10000;  // 从5秒增加到10秒
```

### 5. 代理连接失败

**症状**: 日志显示 "Proxy connection failed"

**解决方法**:
```bash
# 测试代理连接
curl -x http://proxy_user:proxy_pass@127.0.0.1:8080 https://www.baidu.com

# 检查代理配置格式
# 确保: protocol://server:port
```

---

## 常见问题 FAQ

### Q1: 如何部署多个 Worker?

**A**:
```bash
# 使用 PM2
pm2 start src/index.js --name worker-1
pm2 start src/index.js --name worker-2
```

### Q2: 如何查看账号登录状态?

**A**:
```bash
# 使用 API
curl http://localhost:3000/api/accounts/acc-xxx | jq '.login_status'
```

### Q3: 如何手动触发重新登录?

**A**:
```bash
# 更新账号状态
curl -X PUT http://localhost:3000/api/accounts/acc-xxx \
  -H "Content-Type: application/json" \
  -d '{"login_status": "not_logged_in"}'

# 然后通过管理后台发起登录
```

### Q4: 支持哪些社交媒体平台?

**A**:
- ✅ 抖音 (Douyin)
- ⏸️ 其他平台待开发

### Q5: 如何备份数据?

**A**:
```bash
# 备份
tar -czf hiscrm-backup-$(date +%Y%m%d).tar.gz \
  packages/master/data/ \
  packages/worker/data/

# 恢复
tar -xzf hiscrm-backup-20251012.tar.gz
```

---

## 配置文件

### Master 配置 (`packages/master/src/config.js`)

```javascript
module.exports = {
  PORT: 3000,
  HOST: '0.0.0.0',
  DATABASE_PATH: './data/master.db',
  WORKER_HEARTBEAT_TIMEOUT: 30000,  // 30秒
  LOGIN_SESSION_TIMEOUT: 300000,  // 5分钟
  QR_CODE_LIFETIME: 150000,  // 2分30秒
  ADMIN_USERNAME: 'admin',
  ADMIN_PASSWORD: 'admin123',
};
```

### Worker 配置 (`packages/worker/src/config.js`)

```javascript
module.exports = {
  MASTER_URL: 'http://localhost:3000',
  WORKER_ID: `worker-${randomId()}`,
  BROWSER_HEADLESS: true,
  HEARTBEAT_INTERVAL: 10000,  // 10秒
  RETRY_MAX_ATTEMPTS: 3,
  RETRY_BASE_DELAY: 1000,
};
```

---

## 性能优化建议

### 1. 数据库优化

```sql
-- 创建索引
CREATE INDEX IF NOT EXISTS idx_comments_account_detected
  ON comments(account_id, detected_at);

-- 定期 VACUUM
VACUUM;
```

### 2. Worker 负载均衡

```javascript
// 根据 Worker 负载分配账号
const workers = await getWorkers();
workers.sort((a, b) => a.assigned_accounts - b.assigned_accounts);
const assignedWorker = workers[0];
```

### 3. 缓存策略

```javascript
// 代理健康状态缓存
this.CACHE_DURATION = 5 * 60 * 1000;  // 5分钟
```

---

## 安全建议

### 1. 密码管理

```bash
# 使用环境变量
export ADMIN_PASSWORD=$(openssl rand -base64 32)
```

### 2. IP 白名单

```javascript
const allowedIPs = ['127.0.0.1', '192.168.1.100'];

app.use((req, res, next) => {
  const clientIP = req.ip || req.connection.remoteAddress;
  if (!allowedIPs.includes(clientIP)) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  next();
});
```

---

## 联系支持

- **文档**: 查看 `.docs/` 目录下的其他文档
- **问题反馈**: GitHub Issues
- **技术支持**: support@your-company.com

---

**文档版本**: 1.0.0
**最后更新**: 2025-10-12
**维护者**: 开发团队
