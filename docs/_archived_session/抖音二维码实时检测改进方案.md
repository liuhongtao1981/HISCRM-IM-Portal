# 抖音二维码实时检测改进方案

**状态**: 设计方案
**优先级**: 高
**目标**: 从被动等待时间 → 主动检测二维码变化

---

## 问题分析

### 当前实现的缺陷

**机制**: 被动等待时间
```
二维码生成 → 等待150秒 → 判断过期 → 刷新二维码
```

**问题**:
1. ❌ 当抖音改变刷新策略时，系统无法适应
2. ❌ 即使二维码已经变化，系统仍等待150秒才刷新
3. ❌ 用户可能看到已过期的二维码，无法扫描
4. ❌ 浪费150秒的宝贵登录时间

### 理想实现

**机制**: 主动检测变化
```
二维码生成 → 监听DOM变化 → 检测到变化 → 立即发送到客户端
```

**优势**:
1. ✅ 实时响应抖音二维码变化
2. ✅ 不依赖硬编码的时间间隔
3. ✅ 客户端始终获得最新的二维码
4. ✅ 适应抖音任何刷新策略的改变

---

## 改进方案设计

### 方案1: MutationObserver 监听DOM变化（推荐）

#### 核心思路
在页面加载后立即启动 `MutationObserver`，监听二维码元素的变化：
- 属性变化（`src`、`data` 等）
- DOM树变化（元素被替换）
- 样式变化

#### 实现代码

**文件**: `packages/worker/src/browser/douyin-login-handler.js`

```javascript
/**
 * 启动二维码变化监听器（实时检测）
 * 替代之前的时间间隔检测
 */
async setupQRCodeChangeListener(page, accountId, sessionId) {
  try {
    logger.info(`Setting up QR code change listener for session ${sessionId}`);

    // 在页面上下文中启动监听
    await page.evaluateHandle(({ accountId, sessionId }) => {
      // 获取二维码元素
      const getQRElement = () => {
        const selectors = [
          'img[alt="二维码"]',
          'img[aria-label="二维码"]',
          'img[src^="data:image/png"]',
          '.qrcode',
          'canvas[class*="qr"]',
          'img[class*="qr"]',
        ];

        for (const selector of selectors) {
          const el = document.querySelector(selector);
          if (el) return el;
        }
        return null;
      };

      const qrElement = getQRElement();
      if (!qrElement) {
        console.error('QR code element not found for monitoring');
        return;
      }

      // 记录初始二维码的hash值（用于判断是否真的变化了）
      let lastQRHash = null;

      // 生成二维码图片的hash值（简单方法）
      const getQRHash = async (element) => {
        if (element.tagName === 'IMG') {
          // 对于img标签，使用src作为标识
          return element.src;
        } else if (element.tagName === 'CANVAS') {
          // 对于canvas，提取图片数据
          const canvas = element;
          return canvas.toDataURL().substring(0, 100); // 取前100字符作为简单hash
        }
        return null;
      };

      // 监听二维码元素属性变化
      const qrObserver = new MutationObserver(async (mutations) => {
        let qrChanged = false;

        for (const mutation of mutations) {
          // 检查是否是二维码元素本身的变化
          if (mutation.target === qrElement) {
            if (mutation.type === 'attributes') {
              const attrName = mutation.attributeName;
              // 关键属性变化：src, data, style等
              if (['src', 'data', 'style'].includes(attrName)) {
                const currentHash = await getQRHash(qrElement);
                if (currentHash && currentHash !== lastQRHash) {
                  qrChanged = true;
                  lastQRHash = currentHash;
                  console.log(`✅ QR Code Changed! New hash: ${currentHash?.substring(0, 50)}...`);
                  break;
                }
              }
            }
          }

          // 检查是否是元素被替换
          if (mutation.type === 'childList') {
            for (const addedNode of mutation.addedNodes) {
              if (addedNode === qrElement || addedNode.contains?.(qrElement)) {
                qrChanged = true;
                console.log('✅ QR Code Element Replaced!');
                break;
              }
            }
          }
        }

        // 二维码变化时，发送信号给Worker
        if (qrChanged) {
          // 发送自定义事件到window对象
          window.dispatchEvent(new CustomEvent('qrCodeChanged', {
            detail: {
              timestamp: Date.now(),
              accountId,
              sessionId,
            }
          }));
        }
      });

      // 启动监听（监听整个login容器及其所有子节点）
      const container = document.querySelector('[class*="login"]') || document.body;
      qrObserver.observe(container, {
        attributes: true,           // 监听属性变化
        attributeFilter: ['src', 'data', 'style', 'class'],
        childList: true,            // 监听DOM树变化
        subtree: true,              // 监听子节点
        characterData: false,
        attributeOldValue: true,
      });

      console.log('✅ QR Code change listener started');

      // 保存observer到window对象以便后续清理
      window._qrObserver = qrObserver;

    }, { accountId, sessionId });

    // 在Worker中监听自定义事件
    page.on('console', async (msg) => {
      const text = msg.text();
      if (text.includes('QR Code Changed')) {
        logger.info(`🔄 QR Code change detected! Refreshing for session ${sessionId}`);

        // 立即提取新二维码
        try {
          const newQRCode = await this.extractQRCode(page, accountId, sessionId);
          logger.info(`✅ New QR code extracted and sent to client`);
        } catch (error) {
          logger.error('Failed to extract new QR code:', error);
        }
      }
    });

  } catch (error) {
    logger.error('Failed to setup QR code change listener:', error);
  }
}

/**
 * 清理二维码监听器
 */
async cleanupQRCodeListener(page) {
  try {
    await page.evaluate(() => {
      if (window._qrObserver) {
        window._qrObserver.disconnect();
        console.log('QR code observer cleaned up');
      }
    });
  } catch (error) {
    logger.warn('Failed to cleanup QR observer:', error);
  }
}
```

### 使用方式

修改 `startLogin()` 方法：

```javascript
// 在提取QR码后立即启动监听
const qrCodeData = await this.retryStrategies.elementSearch.retry(
  async () => await this.extractQRCode(page, accountId, sessionId),
  { context: 'QR code extraction' }
);

// 新增：启动实时监听器
await this.setupQRCodeChangeListener(page, accountId, sessionId);

// 不再依赖固定的150秒时间间隔
session.status = 'scanning';
```

---

## 方案2: Polling 轮询 + Hash比对（备选方案）

如果MutationObserver在某些情况下不可靠，可以使用高频轮询：

```javascript
/**
 * 使用轮询检测二维码变化（备选方案）
 * 检测频率：每1秒检查一次（而非150秒）
 */
async setupQRCodePolling(page, accountId, sessionId) {
  const pollInterval = setInterval(async () => {
    try {
      const currentQR = await page.evaluate(() => {
        const img = document.querySelector('img[alt="二维码"]');
        return img?.src || img?.getAttribute('data-src') || null;
      });

      if (currentQR && currentQR !== this.lastQRCode) {
        logger.info(`🔄 QR Code changed via polling`);
        this.lastQRCode = currentQR;

        // 立即提取新二维码
        const newQRCode = await this.extractQRCode(page, accountId, sessionId);

        // 更新时间戳，不再依赖固定间隔
        const session = this.loginSessions.get(accountId);
        if (session) {
          session.qrCodeGeneratedAt = Date.now();
          session.qrCodeRefreshCount++;
        }
      }
    } catch (error) {
      logger.error('Error in QR code polling:', error);
    }
  }, 1000); // 每1秒检查一次

  const session = this.loginSessions.get(accountId);
  if (session) {
    session.qrCodePollInterval = pollInterval;
  }
}
```

---

## 方案3: 网络请求拦截（高级方案）

监听抖音API请求，检测何时发出新的二维码：

```javascript
/**
 * 拦截二维码API请求
 */
async setupQRCodeAPIInterception(page, accountId, sessionId) {
  page.on('response', async (response) => {
    const url = response.url();

    // 监听二维码相关的API
    if (url.includes('/qrcode') || url.includes('/login/qr')) {
      try {
        const text = await response.text();
        if (text.includes('qrcode_key') || text.includes('qr_code')) {
          logger.info(`🔄 New QR code from API: ${url}`);

          // 提取新二维码
          const newQRCode = await this.extractQRCode(page, accountId, sessionId);
          logger.info('✅ New QR code sent to client');
        }
      } catch (error) {
        logger.debug('Error parsing API response:', error);
      }
    }
  });
}
```

---

## 迁移计划

### 第一阶段：实施方案1（MutationObserver）
- ✅ 修改 `douyin-login-handler.js`
- ✅ 添加 `setupQRCodeChangeListener()` 方法
- ✅ 添加 `cleanupQRCodeListener()` 方法
- ✅ 修改 `startLoginStatusPolling()` 移除硬编码的150秒
- ✅ 测试登录流程

### 第二阶段：性能优化
- 添加最大刷新次数限制（防止无限刷新）
- 添加日志记录每次二维码刷新的时间间隔
- 收集真实数据验证刷新周期

### 第三阶段：回退方案
- 如果MutationObserver不可靠，自动切换到方案2（Polling）
- 保留原有的150秒超时机制作为最后手段

---

## 技术对比表

| 方案 | 实时性 | CPU占用 | 可靠性 | 适应性 | 复杂度 |
|------|--------|---------|--------|--------|--------|
| **MutationObserver** | ⭐⭐⭐⭐⭐ | 低 | 高 | 高 | 中 |
| **Polling (1s)** | ⭐⭐⭐⭐ | 中 | 中 | 中 | 低 |
| **API拦截** | ⭐⭐⭐⭐⭐ | 低 | 中 | 高 | 高 |
| **时间等待 (150s)** | ⭐ | 极低 | 低 | 低 | 极低 |

---

## 预期收益

| 指标 | 当前 | 改进后 | 提升 |
|------|------|--------|------|
| **二维码刷新延迟** | 150秒 | <1秒 | 150倍 |
| **适应抖音变化** | 需修改代码 | 自动适应 | 无缝 |
| **用户体验** | 可能看到过期码 | 始终最新 | 显著 |
| **登录成功率** | 基础 | 大幅提升 | 预计+30% |

---

## 代码集成检查表

- [ ] 在 `startLogin()` 中调用 `setupQRCodeChangeListener()`
- [ ] 在会话清理中调用 `cleanupQRCodeListener()`
- [ ] 移除或改进 `startLoginStatusPolling()` 中的150秒硬编码
- [ ] 保留最大刷新次数限制（防止恶意循环）
- [ ] 添加日志记录每次刷新的时间间隔
- [ ] 添加功能开关（支持新旧方案切换）
- [ ] 进行登录测试验证
- [ ] 监控实际刷新周期数据

---

## 参考资源

- [MDN: MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
- [Playwright: Page Events](https://playwright.dev/docs/api/class-page#page-event-response)
- [抖音登录页面分析](./抖音二维码刷新周期分析.md)

