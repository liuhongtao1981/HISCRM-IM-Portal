# 浏览器守护进程通用页面管理设计

**核心理念**: 所有平台操作的浏览器页面管理应该由 BrowserManager 统一处理，而不是由各个平台各自实现

**现状**: 各平台重复实现页面创建、检查、恢复等逻辑

**目标**: 在 BrowserManager 中实现通用的页面管理守护进程

---

## 🎯 核心问题

### 当前架构缺陷

```
Platform(douyin) → 需要页面 → getOrCreatePage()
                      ↓
                   新建page
                      ↓
                   执行操作
                      ↓
                   页面可能被关闭 ❌
                      ↓
                   下个操作失败 ❌

Platform(xiaohongshu) → 重复上述逻辑
Platform(other) → 重复上述逻辑
```

### 应该的架构

```
BrowserManager (守护进程)
  ↓
  1️⃣ 页面生命周期管理
  2️⃣ 页面池管理
  3️⃣ 页面检活机制
  4️⃣ 自动恢复机制
  ↓
Platform(douyin) → 向BrowserManager请求页面 ✅
Platform(xiaohongshu) → 向BrowserManager请求页面 ✅
Platform(other) → 向BrowserManager请求页面 ✅
```

---

## 📋 应该由 BrowserManager 统一处理的通用操作

### 1️⃣ 获取或创建页面

```javascript
/**
 * 获取或创建账户的可用页面
 * 这是所有操作的入口
 */
async getAccountPage(accountId, options = {}) {
  const {
    purpose = 'general',  // 'login' | 'crawl' | 'general'
    reuseExisting = true, // 是否复用现有页面
  } = options;

  // 1️⃣ 检查现有页面
  let page = this.getExistingPage(accountId);

  if (page && !page.isClosed()) {
    logger.info(`✅ Reusing existing page for account ${accountId}`);
    return page;
  }

  // 2️⃣ 检查上下文
  let context = this.getAccountContext(accountId);

  if (!context || !context.browser()?.isConnected()) {
    logger.warn(`Context invalid for account ${accountId}, recreating...`);
    context = await this.createContextForAccount(accountId);
  }

  // 3️⃣ 创建新页面
  page = await context.newPage();
  logger.info(`✅ Created new page for account ${accountId} (purpose: ${purpose})`);

  // 4️⃣ 保存页面
  this.savePageForAccount(accountId, page);

  return page;
}
```

### 2️⃣ 页面检活机制

```javascript
/**
 * 检查页面是否仍然可用
 */
async isPageAlive(accountId) {
  const page = this.getExistingPage(accountId);

  if (!page) return false;
  if (page.isClosed()) return false;

  try {
    // 快速检查：尝试获取URL
    const url = page.url();
    logger.debug(`Page check passed for account ${accountId}: ${url}`);
    return true;
  } catch (error) {
    logger.warn(`Page check failed for account ${accountId}:`, error.message);
    return false;
  }
}

/**
 * 定期检活所有页面
 */
startPageHealthCheck(interval = 30000) {
  setInterval(async () => {
    for (const [accountId, page] of this.accountPages.entries()) {
      const isAlive = await this.isPageAlive(accountId);

      if (!isAlive) {
        logger.warn(`Page dead for account ${accountId}, marking for recreation`);
        this.accountPages.delete(accountId);
      }
    }
  }, interval);
}
```

### 3️⃣ 自动恢复机制

```javascript
/**
 * 当页面操作失败时，自动恢复
 */
async recoverPage(accountId, reason) {
  logger.warn(`Recovering page for account ${accountId}: ${reason}`);

  try {
    // 1️⃣ 清理旧页面和上下文
    await this.forceCleanupContext(accountId);

    // 2️⃣ 创建新页面
    const page = await this.getAccountPage(accountId, { reuseExisting: false });

    logger.info(`✅ Page recovered for account ${accountId}`);
    return page;
  } catch (error) {
    logger.error(`Failed to recover page for account ${accountId}:`, error);
    throw error;
  }
}
```

### 4️⃣ 页面池管理

```javascript
class BrowserManagerV2 {
  constructor(...) {
    // 新增：页面池
    this.accountPages = new Map();  // accountId -> page
    this.pageUsageStats = new Map(); // accountId -> { usage, lastUsedTime }
  }

  /**
   * 保存页面到池
   */
  savePageForAccount(accountId, page) {
    this.accountPages.set(accountId, page);

    if (!this.pageUsageStats.has(accountId)) {
      this.pageUsageStats.set(accountId, { usage: 0, lastUsedTime: null });
    }

    const stats = this.pageUsageStats.get(accountId);
    stats.usage++;
    stats.lastUsedTime = Date.now();

    logger.debug(`Saved page for account ${accountId} (usage: ${stats.usage})`);
  }

  /**
   * 获取现有页面
   */
  getExistingPage(accountId) {
    return this.accountPages.get(accountId);
  }

  /**
   * 获取页面使用统计
   */
  getPageStats() {
    const stats = {};
    for (const [accountId, { usage, lastUsedTime }] of this.pageUsageStats.entries()) {
      stats[accountId] = {
        usage,
        lastUsedTime: new Date(lastUsedTime).toISOString(),
      };
    }
    return stats;
  }
}
```

---

## 🔧 平台代码应如何简化

### 之前（复杂）

```javascript
// platforms/douyin/platform.js
async getOrCreatePage(accountId) {
  if (this.currentPage && !this.currentPage.isClosed()) {
    return this.currentPage;
  }

  const context = await this.ensureAccountContext(accountId);
  this.currentPage = await context.newPage();
  return this.currentPage;
}

async crawlComments(account) {
  try {
    const page = await this.getOrCreatePage(account.id);
    // 爬取逻辑...
  } catch (error) {
    // 错误处理和重试...
  }
}
```

### 之后（简洁）

```javascript
// platforms/douyin/platform.js
async crawlComments(account) {
  try {
    // 直接从 BrowserManager 获取可用页面
    // ✅ 所有检查和恢复都由守护进程处理
    const page = await this.browserManager.getAccountPage(account.id, {
      purpose: 'crawl',
    });

    // 页面100%可用，直接使用
    await this.navigateToCommentPage(page);
    const comments = await this.extractComments(page);

    return comments;
  } catch (error) {
    // 简化的错误处理
    logger.error(`Failed to crawl comments for account ${account.id}:`, error);
    throw error;
  }
}
```

---

## 📊 BrowserManager 应提供的接口

### 获取/创建页面

```javascript
async getAccountPage(accountId, options)
  // 返回可用的页面
  // 自动处理：检查、创建、恢复
```

### 检查页面状态

```javascript
async isPageAlive(accountId)
  // 返回页面是否还活着

getExistingPage(accountId)
  // 直接获取现有页面（不创建新的）
```

### 恢复页面

```javascript
async recoverPage(accountId, reason)
  // 自动清理和重建页面
```

### 统计信息

```javascript
getPageStats()
  // 返回所有账户的页面使用统计

getAccountContext(accountId)
  // 获取账户的浏览器上下文
```

---

## 🏗️ 实现步骤

### 第一步：增强 BrowserManagerV2

在 `packages/worker/src/browser/browser-manager-v2.js` 中添加：

```javascript
class BrowserManagerV2 {
  constructor(...) {
    // 新增：页面池
    this.accountPages = new Map();
    this.pageUsageStats = new Map();
  }

  // 新增方法
  async getAccountPage(accountId, options = {}) { ... }
  async isPageAlive(accountId) { ... }
  async recoverPage(accountId, reason) { ... }
  savePageForAccount(accountId, page) { ... }
  getExistingPage(accountId) { ... }
  startPageHealthCheck(interval) { ... }
}
```

### 第二步：简化平台代码

移除各平台中的 `getOrCreatePage()` 等重复逻辑，统一使用：

```javascript
const page = await this.browserManager.getAccountPage(accountId);
```

### 第三步：测试验证

```
✅ 登录成功
✅ 页面被保存到池
✅ 抓取任务启动
✅ getAccountPage() 返回已保存的页面
✅ 抓取成功
✅ 页面继续可用供下个操作使用
```

---

## 💡 关键设计原则

| 原则 | 说明 |
|------|------|
| **单一职责** | BrowserManager 负责所有页面管理 |
| **自动恢复** | 页面关闭时自动重建 |
| **页面复用** | 同一账户的操作复用同一页面 |
| **最小化平台逻辑** | 平台只关心业务逻辑 |
| **透明隐藏** | 平台代码不需要知道页面是新建还是复用 |

---

## 📈 预期效果

### 代码行数减少

| 组件 | 之前 | 之后 | 节省 |
|------|------|------|------|
| BrowserManager | 550行 | 750行 | +200行（新功能） |
| Douyin Platform | 2100行 | 1900行 | -200行 |
| Xiaohongshu Platform | 1800行 | 1600行 | -200行 |
| 其他平台 | ... | ... | -50-100行/个 |

### 错误率降低

| 指标 | 之前 | 之后 |
|------|------|------|
| 页面关闭错误 | 频繁 | 极少 |
| 上下文无效错误 | 常见 | 几乎不出现 |
| 自动恢复成功率 | N/A | >95% |

### 性能指标

| 指标 | 之前 | 之后 |
|------|------|------|
| 平均页面创建时间 | 500-1000ms | <100ms（复用） |
| 页面复用率 | <20% | >80% |
| 浏览器实例数 | 频繁创建销毁 | 稳定 |

---

## ✅ 总结

你的建议是完全正确的：

> "浏览器守护进程里就应该干这些通用的事情，这是所有操作的前提"

**正确的架构**：
- ✅ BrowserManager 是浏览器生命周期的守护者
- ✅ 负责页面的创建、复用、检活、恢复
- ✅ 所有平台统一向 BrowserManager 请求页面
- ✅ 平台代码只关注业务逻辑，不管页面管理

**现在的情况**：
- ❌ 各平台各自实现页面管理
- ❌ 重复代码多
- ❌ 容易出现页面关闭的问题
- ❌ 维护困难

**改进后**：
- ✅ 统一、可靠的页面管理
- ✅ 自动恢复机制
- ✅ 页面复用优化
- ✅ 平台代码更简洁

