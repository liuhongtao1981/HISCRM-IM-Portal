# 私信会话消失问题 - 诊断报告

## 问题描述

用户反馈："点了其中一个会话，返回后其他会话消失了"

### 用户操作流程：
1. 在私信 Tab 看到多个会话（例如 10 个）
2. 点击某个会话进入对话
3. 点击"返回私信列表"按钮
4. **问题**：其他会话消失了，只剩下刚才点击的会话或部分会话

## 可能的原因分析

### 原因 1: Redux Store 数据被意外修改

**位置**: `packages/crm-pc-im/src/store/monitorSlice.ts` Line 252-271

```typescript
selectTopic: (state, action: PayloadAction<string>) => {
  state.selectedTopicId = action.payload

  // 清除该作品的未读计数
  if (state.selectedChannelId) {
    const topics = state.topics[state.selectedChannelId]
    if (topics) {
      const topic = topics.find(t => t.id === action.payload)
      if (topic) {
        topic.unreadCount = 0  // ✅ 清零
      }

      // ✅ 重新计算该账户的总未读数
      const channel = state.channels.find(ch => ch.id === state.selectedChannelId)
      if (channel) {
        channel.unreadCount = topics.reduce((sum, t) => sum + (t.unreadCount || 0), 0)
      }
    }
  }
},
```

**问题**：这个逻辑只是清零未读数，不应该导致 topic 消失。

### 原因 2: 服务端重新推送 topics 时过滤了无未读的会话

**怀疑**：服务端在某些情况下重新推送 `monitor:topics` 事件，但只包含有未读消息的会话。

**需要检查的位置**：
- `packages/master/src/communication/im-websocket-server.js`
- `monitor:request_topics` 事件处理器
- `monitor:request_messages` 事件处理器

### 原因 3: 前端过滤逻辑错误

**位置**: `packages/crm-pc-im/src/pages/MonitorPage.tsx` Line 147-186

```typescript
const privateMessagesByTopic = React.useMemo(() => {
  if (!selectedChannelId) return []

  const topicsWithPrivate: Array<...> = []

  currentTopics.forEach(topic => {
    if (topic.isPrivate) {
      // 添加到列表
      topicsWithPrivate.push({...})
    }
  })

  // 排序
  return topicsWithPrivate.sort(...)
}, [selectedChannelId, currentTopics, messages])
```

**问题**：这个逻辑会将所有 `isPrivate` 的 topic 都添加进来，不应该过滤掉任何会话。

### 原因 4: `currentTopics` 数据被覆盖

**可能性**：当用户点击会话后，服务端或客户端重新请求了 topics，但新的 topics 数据不完整。

**关键代码** (`MonitorPage.tsx` Line 241-242):
```typescript
websocketService.on('monitor:topics', (data: any) => {
  console.log('[监听] 收到作品列表:', data)
  dispatch(setTopics({ channelId: data.channelId, topics: data.topics }))
})
```

**问题**：`setTopics` 会**完全替换**该账户的 topics 列表。如果服务端推送的 topics 不完整，会导致会话消失。

## 诊断步骤

### 步骤 1: 添加调试日志（客户端）

修改 `MonitorPage.tsx`:

```typescript
// 在 privateMessagesByTopic useMemo 中添加
const privateMessagesByTopic = React.useMemo(() => {
  console.log('[DEBUG] 计算 privateMessagesByTopic')
  console.log('[DEBUG] selectedChannelId:', selectedChannelId)
  console.log('[DEBUG] currentTopics 长度:', currentTopics.length)
  console.log('[DEBUG] currentTopics:', currentTopics.map(t => ({
    id: t.id,
    title: t.title,
    isPrivate: t.isPrivate,
    unreadCount: t.unreadCount
  })))

  // ... 原有逻辑

  console.log('[DEBUG] privateMessagesByTopic 长度:', topicsWithPrivate.length)
  return topicsWithPrivate.sort(...)
}, [selectedChannelId, currentTopics, messages])
```

### 步骤 2: 添加调试日志（服务端）

修改 `im-websocket-server.js` 的 `monitor:request_messages` 处理器：

```javascript
socket.on('monitor:request_messages', (data) => {
  logger.info(`[IM] 客户端请求消息: topicId=${data.topicId}`)

  // 检查是否会触发 topics 重新推送
  logger.warn('[DEBUG] 是否会重新推送 topics? 当前逻辑检查')

  // ... 原有逻辑
})
```

### 步骤 3: 检查 Redux Store 更新

在浏览器控制台监控 Redux store 变化：

```javascript
// 添加到 MonitorPage.tsx useEffect
useEffect(() => {
  console.log('[Redux] currentTopics 变化:', currentTopics.length, '个 topics')
  currentTopics.forEach((t, i) => {
    console.log(`  [${i}] ${t.title} (unread: ${t.unreadCount}, isPrivate: ${t.isPrivate})`)
  })
}, [currentTopics])
```

## 临时解决方案

### 方案 1: 不完全替换 topics

修改 `monitorSlice.ts` 的 `setTopics` reducer：

```typescript
setTopics: (state, action: PayloadAction<{ channelId: string; topics: Topic[] }>) => {
  const { channelId, topics } = action.payload

  // ❌ 旧逻辑：完全替换
  // state.topics[channelId] = topics

  // ✅ 新逻辑：合并更新（保留现有的 topics，只更新或添加新的）
  const existingTopics = state.topics[channelId] || []
  const topicMap = new Map(existingTopics.map(t => [t.id, t]))

  // 更新或添加新 topics
  topics.forEach(topic => {
    topicMap.set(topic.id, topic)
  })

  state.topics[channelId] = Array.from(topicMap.values())

  // ... 其余逻辑
}
```

### 方案 2: 服务端确保总是推送完整的 topics 列表

修改服务端逻辑，确保每次推送 `monitor:topics` 时都包含所有会话（包括无未读消息的）。

## 问题根源猜测

最可能的原因是：

1. **服务端在 `monitor:request_messages` 时重新推送了 topics**
2. **但只包含有未读消息的会话**（因为服务端有过滤逻辑）
3. **客户端 `setTopics` 完全替换了 topics 列表**
4. **导致无未读消息的会话消失**

## 下一步行动

1. 检查服务端 `monitor:request_messages` 处理器是否会触发 topics 重新推送
2. 检查服务端推送的 topics 是否完整
3. 如果服务端会重新推送，修改为只推送变化的 topics，或确保总是推送完整列表
4. 如果客户端有问题，修改 `setTopics` 为合并逻辑而非完全替换

## 用户请求的日志检查

用户说"看看日志，怎么回事"，需要：
1. 查看 Master 服务端日志
2. 查看浏览器控制台日志
3. 确认是服务端问题还是客户端问题
