# 消息重复推送问题修复总结

## 问题描述

用户报告 Web 客户端在每次重新连接时都会收到所有历史消息，而不是只推送一次。

> "消息和私信为啥每次都推送，咱们不是master只给web推送一次就标记成is_new=false以后不在推送了么？"
> "web每次重开都会收到"

## 根本原因分析

消息重复推送的根本原因是 **消息的 is_new 字段在推送后没有自动标记为 false**，导致：

1. **Worker IsNewPushTask** 每60秒扫描一次 `is_new=1` 的所有消息
2. **Master onPushNewMessages/onPushNewComments** 检查消息，发现 `is_new=true` 就重复推送
3. **消息的 is_new 字段永不自动清零**，除非显式调用 `markNewAsViewed()`
4. 形成无限推送循环，直到手动干预

## 修复方案

### 修复1: 推送后自动标记 is_new=false

**文件**: `packages/master/src/index.js`

**改动**: 在 `onPushNewMessages` 和 `onPushNewComments` 函数中，在推送给客户端后，自动调用 `markNewAsViewed()` 标记消息为已查看。

**代码示例**:
```javascript
// 推送后标记这些消息为 is_new=false
const messageIds = messagesToNotify
  .filter(m => m.data && m.data.is_new === 1)
  .map(m => m.data.id);

if (messageIds.length > 0) {
  try {
    directMessagesDAO.markNewAsViewed(messageIds);
    logger.info(`[IsNew] Marked ${messageIds.length} messages as viewed (is_new=false)`);
  } catch (markError) {
    logger.warn(`[IsNew] Failed to mark messages as viewed:`, markError.message);
  }
}
```

### 修复2: 改进历史消息检查逻辑

**文件**: `packages/master/src/index.js`

**改动**: 使用严格的 `=== 1` 检查，明确只推送 `is_new=1` 的消息

**修改前**:
```javascript
if (existingMessage && existingMessage.is_new) {
  // 隐式的 truthy 检查，容易出错
}
```

**修改后**:
```javascript
if (existingMessage && existingMessage.is_new === 1) {
  // 明确只推送 is_new=1
} else if (existingMessage && existingMessage.is_new === 0) {
  // 明确跳过 is_new=0
}
```

### 修复3: 添加通知清理定时器

**文件**: `packages/master/src/index.js`

**改动**: 每小时自动清理 7 天以上的已发送通知，防止通知表无限增长

**代码**:
```javascript
setInterval(() => {
  try {
    const cutoffTime = Math.floor(Date.now() / 1000) - 7 * 24 * 60 * 60; // 7天
    const stmt = db.prepare(`
      DELETE FROM notifications
      WHERE is_sent = 1 AND sent_at < ?
    `);
    const result = stmt.run(cutoffTime);
    if (result.changes > 0) {
      logger.info(`[Cleanup] Deleted ${result.changes} old sent notifications`);
    }
  } catch (error) {
    logger.error('[Cleanup] Failed to clean up notifications:', error);
  }
}, 60 * 60 * 1000); // 1小时执行一次
```

### 修复4: 添加 markNewAsViewed 方法到 DirectMessagesDAO

**文件**: `packages/master/src/database/messages-dao.js`

**改动**: 添加 `markNewAsViewed()` 方法，支持按 ID 列表标记消息为已查看

**实现**:
```javascript
markNewAsViewed(messageIds) {
  try {
    if (!Array.isArray(messageIds) || messageIds.length === 0) {
      return 0;
    }

    const placeholders = messageIds.map(() => '?').join(',');
    const result = this.db.prepare(
      `UPDATE direct_messages SET is_new = 0 WHERE id IN (${placeholders})`
    ).run(...messageIds);

    if (result.changes > 0) {
      logger.info(`Marked ${result.changes} direct messages as viewed (is_new=false)`);
    }
    return result.changes;
  } catch (error) {
    logger.error(`Failed to mark direct messages as viewed:`, error);
    throw error;
  }
}
```

### 修复5: 增强 CommentsDAO 的 markNewAsViewed 方法

**文件**: `packages/master/src/database/comments-dao.js`

**改动**: 扩展 `markNewAsViewed()` 方法，支持两种调用方式：
1. 按 ID 数组标记（新）
2. 按条件标记（向后兼容）

**实现**:
```javascript
markNewAsViewed(accountIdOrArray = null, platformUserId = null, postId = null) {
  if (Array.isArray(accountIdOrArray)) {
    // 方式1: 按ID数组标记
    const commentIds = accountIdOrArray;
    const placeholders = commentIds.map(() => '?').join(',');
    const result = this.db.prepare(
      `UPDATE comments SET is_new = 0 WHERE id IN (${placeholders})`
    ).run(...commentIds);
    // ...
  } else {
    // 方式2: 按条件标记（向后兼容）
    // ... 原有逻辑
  }
}
```

## 修改的文件列表

1. **packages/master/src/index.js** (3处修改)
   - 行 620-637: 推送评论后标记 is_new=false
   - 行 581-606: 改进评论检查逻辑
   - 行 721-746: 改进消息检查逻辑
   - 行 743-759: 推送消息后标记 is_new=false
   - 行 1175-1195: 添加通知清理定时器

2. **packages/master/src/database/messages-dao.js** (1处新增)
   - 行 189-214: 新增 `markNewAsViewed()` 方法

3. **packages/master/src/database/comments-dao.js** (1处增强)
   - 行 419-475: 增强 `markNewAsViewed()` 方法

## 修复效果

修复后，消息推送流程变为：

```
1. Worker 爬虫插入消息 (is_new=1)
         ↓
2. Worker IsNewPushTask 扫描 is_new=1 的消息
         ↓
3. Master 接收推送，检查消息
         ├─ 新消息: INSERT, is_new=1
         └─ 历史消息: 如果 is_new=1，加入通知
         ↓
4. Master 推送给客户端
         ↓
5. ✅ Master 自动标记消息 is_new=0 ← 关键修复！
         ↓
6. Web 客户端接收消息，标记通知为 is_sent=1
         ↓
7. 下次 IsNewPushTask 扫描时，is_new=0 被过滤，不再推送 ✅
         ↓
8. Web 客户端重新连接时，不会收到已发送的消息 ✅
```

## 验证检查清单

修复后，需要验证以下场景：

- [ ] **测试1**: 新消息推送，检查数据库中 is_new 是否自动变为 0
  ```sql
  SELECT is_new FROM direct_messages WHERE id = '{messageId}' LIMIT 1;
  ```
  预期: `is_new = 0`

- [ ] **测试2**: Web 客户端第一次连接，收到新消息

- [ ] **测试3**: Web 客户端断开后重新连接
  - 预期: **不再收到同样的消息**

- [ ] **测试4**: Worker IsNewPushTask 再次扫描
  - 预期: 不再推送 is_new=0 的消息

- [ ] **测试5**: 多个 Web 客户端同时连接
  - 预期: 每个客户端只收到一次新消息

- [ ] **测试6**: 长时间运行后检查数据库
  - 预期: 旧通知被定期清理

## 性能影响

- **正向**: 减少了重复推送，减轻了服务器负担
- **中立**: 每小时执行一次清理，性能影响可忽略
- **中立**: 推送后的 markNewAsViewed 操作是批量的，性能高效

## 向后兼容性

- ✅ CommentsDAO 的 markNewAsViewed 方法保持向后兼容
- ✅ 现有的按条件标记逻辑仍然可用
- ✅ 没有破坏性变更

## 总结

这是一个关键的推送机制修复，解决了消息重复推送的根本问题。通过在推送后自动标记 `is_new=false`，防止了消息的无限循环推送，从而确保用户每条新消息只会收到一次推送。
