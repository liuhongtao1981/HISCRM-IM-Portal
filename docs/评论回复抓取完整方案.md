# 评论回复抓取完整方案

## 📋 问题发现

### 原始问题
用户反馈: "mcp 里把评论也研究一下，评论里的讨论我们貌似没有抓取回来"

### 调查过程

#### 1. MCP手动测试
通过MCP工具手动操作发现:
- ✅ 评论可以正常加载
- ✅ "查看X条回复"按钮存在
- ✅ 点击按钮后,讨论成功展开
- ✅ 讨论数据显示在DOM中

#### 2. API拦截测试
通过测试脚本发现:
- ✅ 评论API能正常拦截 (`/comment/list`)
- ❌ 讨论/回复API**无法拦截**

#### 3. 关键发现
**讨论数据不是通过独立API加载的,而是通过前端点击"查看回复"按钮触发的,但我们的拦截器却捕获不到!**

可能原因:
1. 讨论数据已经包含在评论API响应中(但实际检查发现没有)
2. 讨论API的URL格式与预期不同
3. **点击"查看回复"按钮时前端可能从缓存或虚拟DOM中读取数据,而不发起新的API请求**

## 🔍 核心发现

### 评论API数据结构

```json
{
  "comment_id": "...",
  "text": "评论内容",
  "create_time": "1557371703",
  "user_info": {
    "screen_name": "用户名",
    "user_id": "...",
    "avatar_url": "..."
  },
  "reply_count": "3",  // ⭐ 关键字段 - 表示有3条回复
  "digg_count": "12",
  "level": 1
}
```

**关键字段**:
- `reply_count`: 字符串类型,表示该评论有多少条回复
- 但**没有包含实际的回复数据**

### DOM结构分析

当点击"查看3条回复"按钮后:

```
评论项
├─ 用户信息
├─ 评论内容
├─ 操作按钮
└─ 【展开的回复列表】⬅️ 新增
    ├─ 回复1
    │   ├─ 用户: "有福同享"
    │   ├─ 内容: "临终关怀"
    │   └─ 时间: "10月06日 20:30"
    ├─ 回复2
    │   ├─ 用户: "晶莹"
    │   ├─ 内容: "回复有福同享:怎么关怀?"
    │   └─ 时间: "10月06日 20:32"
    └─ 回复3
        ├─ 用户: "细品岁月1962"
        ├─ 内容: "回复晶莹:不治疗,只是用药止痛!..."
        └─ 时间: "10月06日 20:40"
```

### 🎯 最终结论

**讨论数据可能已经在页面首次加载时通过React虚拟DOM预加载,点击"查看回复"只是切换显示/隐藏状态,并不触发新的API请求!**

这意味着我们需要:
1. **从DOM中提取讨论数据**(而不是API)
2. **或者使用React Fiber技术提取虚拟DOM数据**

## 💡 解决方案

### 方案A: 从DOM提取讨论数据 (推荐)

#### 优点
- 简单直接
- 不依赖API拦截
- 数据已经渲染在页面上

#### 流程
```
1. 点击视频
2. 等待评论加载
3. 滚动到底部(加载所有评论)
4. 查找所有"查看X条回复"按钮
5. 依次点击每个按钮
6. 等待展开动画完成
7. 从DOM提取所有展开的回复数据
8. 处理下一个视频
```

#### 实现伪代码

```javascript
// 1. 点击视频
await clickVideo(videoIndex);
await page.waitForTimeout(3000);

// 2. 滚动加载所有评论
let lastHeight = 0;
while (true) {
  await scrollToBottom();
  await page.waitForTimeout(2000);

  const currentHeight = await getScrollHeight();
  if (currentHeight === lastHeight) break;
  lastHeight = currentHeight;
}

// 3. 查找并点击所有"查看X条回复"按钮
const replyButtons = await page.evaluate(() => {
  const buttons = [];
  document.querySelectorAll('*').forEach(el => {
    if (/^查看\d+条回复$/.test(el.textContent) && el.offsetParent) {
      buttons.push(el);
    }
  });
  return buttons.length;
});

// 4. 依次点击
for (let i = 0; i < replyButtons; i++) {
  await page.evaluate((index) => {
    const buttons = Array.from(document.querySelectorAll('*'))
      .filter(el => /^查看\d+条回复$/.test(el.textContent) && el.offsetParent);

    if (buttons[index]) {
      buttons[index].click();
    }
  }, i);

  await page.waitForTimeout(1500); // 等待展开动画
}

// 5. 提取所有讨论数据
const discussions = await page.evaluate(() => {
  const results = [];

  // 查找所有展开的回复容器
  const replyContainers = document.querySelectorAll('[包含回复的选择器]');

  replyContainers.forEach(container => {
    // 提取回复数据
    const user = container.querySelector('.user-name')?.textContent;
    const content = container.querySelector('.content')?.textContent;
    const time = container.querySelector('.time')?.textContent;

    results.push({ user, content, time });
  });

  return results;
});
```

### 方案B: React Fiber提取 (备选)

如果讨论数据确实在虚拟DOM中,使用React Fiber技术:

```javascript
const fiber = element[Object.keys(element).find(k => k.startsWith('__reactFiber$'))];
const discussions = fiber.memoizedProps.discussions;
```

## 🛠️ 实现步骤

### Step 1: 修改 crawl-comments.js

**主要修改点:**

1. **改变视频处理策略**: 从批量点击改为逐个处理

```javascript
// ❌ 旧方式 - 批量点击
for (let i = 0; i < videos.length; i++) {
  await clickVideo(i);
  await page.waitForTimeout(2000);
}

// ✅ 新方式 - 逐个完整处理
for (let i = 0; i < videos.length; i++) {
  await processVideo(videos[i]); // 完整处理单个视频
}
```

2. **添加滚动加载评论功能**

```javascript
async function loadAllComments(page) {
  let scrollAttempts = 0;
  const maxScrolls = 10;

  while (scrollAttempts < maxScrolls) {
    const scrolled = await page.evaluate(() => {
      const container = document.querySelector('[class*="comment-list"]');
      if (container) {
        const before = container.scrollTop;
        container.scrollTo(0, container.scrollHeight);
        return container.scrollTop > before;
      }
      return false;
    });

    if (!scrolled) break;

    await page.waitForTimeout(2000);
    scrollAttempts++;
  }
}
```

3. **添加点击所有"查看回复"按钮功能**

```javascript
async function clickAllReplyButtons(page) {
  const buttonCount = await page.evaluate(() => {
    return Array.from(document.querySelectorAll('*'))
      .filter(el => /^查看\d+条回复$/.test(el.textContent) && el.offsetParent)
      .length;
  });

  logger.info(`Found ${buttonCount} reply buttons`);

  for (let i = 0; i < buttonCount; i++) {
    const clicked = await page.evaluate((index) => {
      const buttons = Array.from(document.querySelectorAll('*'))
        .filter(el => /^查看\d+条回复$/.test(el.textContent) && el.offsetParent);

      if (buttons[index]) {
        buttons[index].click();
        return true;
      }
      return false;
    }, i);

    if (clicked) {
      logger.debug(`  Clicked button ${i + 1}/${buttonCount}`);
      await page.waitForTimeout(1500);
    }
  }

  logger.info(`All reply buttons clicked`);
}
```

4. **完整的单视频处理流程**

```javascript
async function processVideo(page, video, apiResponses) {
  logger.info(`Processing video: ${video.title}`);

  // 1. 点击视频
  await clickVideo(page, video.index);
  await page.waitForTimeout(3000);

  // 2. 滚动加载所有评论
  logger.info('  Loading all comments...');
  await loadAllComments(page);

  // 3. 点击所有"查看回复"按钮
  logger.info('  Clicking all reply buttons...');
  await clickAllReplyButtons(page);

  // 4. 等待所有API响应
  await page.waitForTimeout(2000);

  logger.info('  Video processing complete');
}
```

### Step 2: 字段映射修复

根据之前的调查,修复字段映射错误:

```javascript
// ❌ 错误的字段映射
platform_discussion_id: reply.reply_id || reply.comment_id,
author_name: reply.user_info?.screen_name,
author_id: reply.user_info?.user_id,
author_avatar: reply.user_info?.avatar_url,
reply_count: parseInt(reply.reply_count),

// ✅ 正确的字段映射
platform_discussion_id: reply.cid,
author_name: reply.user?.nickname,
author_id: reply.user?.uid,
author_avatar: reply.user?.avatar_thumb?.url_list?.[0],
reply_count: parseInt(reply.reply_comment_total),
```

### Step 3: 测试验证

创建测试脚本验证:
1. 视频逐个处理
2. 评论滚动加载
3. 回复按钮点击
4. 讨论API拦截
5. 数据完整性

## 📊 预期结果

### 修改前
- 只能抓取一级评论
- 讨论数据丢失
- `reply_count`字段有值,但没有实际回复数据

### 修改后
- ✅ 完整抓取一级评论
- ✅ 完整抓取所有讨论/回复
- ✅ 讨论数据包含完整的用户信息、内容、时间等
- ✅ 支持多级回复("回复XXX:")

## 🎯 下一步

1. ✅ 创建此文档
2. ⏳ 修改 `crawl-comments.js` 实现新流程
3. ⏳ 测试验证
4. ⏳ 更新相关文档

---

**创建时间**: 2025-10-24
**作者**: Claude Code
**版本**: v1.0
