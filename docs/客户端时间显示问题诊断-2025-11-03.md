# 客户端时间显示问题诊断

**日期**: 2025-11-03
**问题**: CRM PC IM 客户端显示会话时间为 "01/21" (1970年1月21日)

---

## 问题确认

### 服务端数据 ✅ 正确

**Master IM WebSocket 日志** (15:06:06):
```
[DEBUG] 第一个 conversation 对象:
  conversationId: MS4wLjABAAAA00qt8pVrvdIGNBoyJ0kYOvA2Dys9Q-i0gn0h3PJN1-odUsdHTaedM2ZaEQeqBr3f
  userName: 福康普惠-养老中心
  createdAt: 1762153517477 (2025/11/3 15:05:17) ✅
  updatedAt: 1762153517477 (2025/11/3 15:05:17) ✅
  lastMessageTime: 1762153517477 (2025/11/3 15:05:17) ✅

[DEBUG] 第一个 topic 对象:
  id: MS4wLjABAAAA00qt8pVrvdIGNBoyJ0kYOvA2Dys9Q-i0gn0h3PJN1-odUsdHTaedM2ZaEQeqBr3f
  title: 福康普惠-养老中心
  createdTime: 1762153517477 (2025/11/3 15:05:17) ✅
  lastMessageTime: 1762153517477 (2025/11/3 15:05:17) ✅
```

**发送给客户端的数据**:
- `lastMessageTime: 1762153517477` (毫秒级, 13位)
- 对应日期: 2025年11月3日 15:05:17

### 客户端显示 ❌ 错误

**CRM PC IM 界面**:
- 显示: "01/21"
- 实际应该显示: "11/03" 或 "2025/11/03"

---

## 问题分析

### 数据流验证

```
Worker (抓取)
  └─> normalizeTimestamp()
  └─> created_at: 1762153517477 (毫秒级) ✅

DataStore (内存)
  └─> conversation.lastMessageTime: 1762153517477 ✅

IM WebSocket (发送)
  └─> topic.lastMessageTime: 1762153517477 ✅
  └─> 通过 Socket.IO 发送给客户端

CRM PC IM (接收)
  └─> 接收到: 1762153517477
  └─> 显示: "01/21" ❌ 错误!
```

### 可能的原因

#### 1. 客户端错误地将毫秒级当作秒级处理

```javascript
// ❌ 错误的处理方式
const timestamp = 1762153517477;  // 毫秒级
const date = new Date(timestamp / 1000);  // 除以 1000 变成秒级
// 结果: 1970-01-21 (错误!)

// ✅ 正确的处理方式
const timestamp = 1762153517477;  // 毫秒级
const date = new Date(timestamp);  // 直接使用
// 结果: 2025-11-03 (正确!)
```

#### 2. 客户端有时间格式化bug

可能在格式化时间时有某种逻辑错误。

#### 3. 客户端缓存了旧数据

客户端可能缓存了之前的错误数据 (秒级时间戳)。

---

## 诊断步骤

### 1. 验证服务端发送的数据

✅ **已验证**: 服务端发送的是正确的毫秒级时间戳 `1762153517477`

### 2. 检查客户端接收到的原始数据

需要在客户端添加日志:

```javascript
socket.on('topics', (topics) => {
  console.log('[DEBUG] Received topics:', topics);
  topics.forEach(topic => {
    console.log(`  ${topic.title}: lastMessageTime = ${topic.lastMessageTime}`);
    console.log(`    Date object: ${new Date(topic.lastMessageTime)}`);
    console.log(`    Formatted: ${new Date(topic.lastMessageTime).toLocaleString('zh-CN')}`);
  });
});
```

### 3. 检查客户端的时间格式化代码

需要查找客户端中处理 `lastMessageTime` 的代码:

**可能的位置**:
- `packages/crm-pc-im/src/components/TopicList.jsx`
- `packages/crm-pc-im/src/components/ConversationItem.jsx`
- `packages/crm-pc-im/src/utils/timeFormat.js`
- `packages/crm-pc-im/src/store/topics.js`

**需要搜索的关键词**:
- `lastMessageTime`
- `topic.lastMessageTime`
- `formatTime`
- `MM/DD`
- `toLocaleDateString`

### 4. 检查客户端是否有错误的时间戳转换

```javascript
// 搜索这些模式:
timestamp / 1000
timestamp * 1000
Math.floor(timestamp / 1000)
```

---

## 修复建议

### 方案 1: 客户端统一使用毫秒级

确保客户端所有时间处理都使用毫秒级:

```javascript
// 接收数据时
const topic = {
  ...data,
  lastMessageTime: data.lastMessageTime  // 已经是毫秒级,直接使用
};

// 格式化显示时
const formatTime = (timestamp) => {
  const date = new Date(timestamp);  // 直接传入毫秒级
  return date.toLocaleDateString('zh-CN', {
    month: '2-digit',
    day: '2-digit'
  });
};
```

### 方案 2: 客户端添加时间戳验证

```javascript
const normalizeClientTimestamp = (timestamp) => {
  // 如果是秒级 (10位),转换为毫秒级
  if (timestamp < 10000000000) {
    console.warn('[Client] Received seconds timestamp, converting to milliseconds');
    return timestamp * 1000;
  }
  // 已经是毫秒级 (13位),直接返回
  return timestamp;
};

// 使用时
const topic = {
  ...data,
  lastMessageTime: normalizeClientTimestamp(data.lastMessageTime)
};
```

### 方案 3: 清除客户端缓存

如果客户端有本地存储或缓存:

```javascript
// 清除旧的缓存数据
localStorage.clear();
sessionStorage.clear();

// 或者只清除相关的
localStorage.removeItem('topics');
localStorage.removeItem('conversations');
```

---

## 验证方法

### 1. 浏览器开发者工具

在客户端打开 Chrome DevTools:

**Network 标签**:
- 过滤: WS (WebSocket)
- 查看 Socket.IO 消息
- 找到 `topics` 事件
- 检查 `lastMessageTime` 的值

**Console 标签**:
```javascript
// 手动测试时间戳
const timestamp = 1762153517477;
console.log('Timestamp:', timestamp);
console.log('Date:', new Date(timestamp));
console.log('Formatted:', new Date(timestamp).toLocaleString('zh-CN'));
// 应该输出: 2025/11/3 15:05:17
```

### 2. 添加客户端日志

在客户端代码中添加详细的日志输出,追踪 `lastMessageTime` 的完整处理流程。

---

## 结论

**服务端已完全修复** ✅:
- Phase 1: Worker normalizeTimestamp()
- Phase 2: CacheDAO 保持毫秒级
- Phase 3: IM WebSocket 使用正确字段

**客户端需要修复** ❌:
- 接收到的数据是正确的毫秒级时间戳
- 但显示时出现错误,变成了 1970年1月21日
- 需要检查客户端的时间格式化代码

**下一步**:
1. 在客户端添加日志,确认接收到的原始数据
2. 检查客户端时间格式化代码
3. 修复客户端的时间处理逻辑
4. 清除客户端可能的旧缓存数据

---

**相关文档**:
- [时间戳格式统一方案-2025-11-03.md](时间戳格式统一方案-2025-11-03.md)
- [时间戳问题完整修复报告-2025-11-03.md](时间戳问题完整修复报告-2025-11-03.md)
- [CacheDAO时间戳修复报告-2025-11-03.md](CacheDAO时间戳修复报告-2025-11-03.md)
