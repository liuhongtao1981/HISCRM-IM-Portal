# 评论回复/讨论结构分析报告

**调查时间**: 2025-10-24 21:35
**调查对象**: 抖音创作者中心 - 评论管理页面
**调查目的**: 分析评论中的"讨论"(回复线程)结构，确认是否正确抓取

---

## 一、页面结构分析

### 1.1 评论管理页面 URL

```
https://creator.douyin.com/creator-micro/data/following/comment
```

**注意**: 需要通过导航菜单进入，直接跳转 URL 可能失败。

正确导航路径：
```
互动管理 → 评论管理 → 选择作品 → 选择有评论的视频
```

### 1.2 评论列表结构

```yaml
# 顶层评论容器
- generic [评论列表容器]:
  - generic [评论1]:
    - checkbox [选择框]
    - listitem [头像]
    - generic [评论内容区]:
      - generic [用户名]
      - generic [发布时间]
      - generic [评论文本内容]
      - generic [操作按钮区]:
        - generic [点赞数按钮]: "12"  # ⭐ 这是点赞数，不是回复数！
        - img [点赞图标]
        - generic [回复按钮]: "回复"
        - generic [删除按钮]: "删除"
        - generic [举报按钮]: "举报"
    - generic [查看回复按钮]:  # ⭐ 这才是回复/讨论的入口！
      - text: "查看3条回复"
      - img [展开图标]
```

### 1.3 展开回复后的结构

```yaml
- generic [主评论]:
  - [主评论基本信息...同上]
  - generic [回复容器]:  # ⭐ 展开后出现
    - generic [回复1]:
      - checkbox [选择框]
      - listitem [头像]
      - generic [回复内容区]:
        - generic [用户名]: "木…易"
        - generic [发布时间]: "10月06日 17:12"
        - generic [回复文本]:
          - text: "德耐医院"
        - generic [操作按钮区]: [同主评论结构]

    - generic [回复2]:
      - generic [用户名]: "硕果累累"
      - generic [发布时间]: "10月06日 20:26"
      - generic [回复文本]:
        - generic: "回复木…易:"  # ⭐ 标记回复对象
        - text: "是私立医院吧？"
        - generic [操作按钮区]

    - generic [回复3]:
      - generic [用户名]: "木…易"
      - generic [时间]: "10月07日 01:22"
      - generic [回复文本]:
        - generic: "回复硕果累累:"  # ⭐ 标记回复对象
        - text: "对，我父亲就是在那走的"
        - generic [操作按钮区]

    - generic [收起按钮]:  # ⭐ 展开后，"查看X条回复"变成"收起"
      - text: "收起"
      - img [收起图标]
```

---

## 二、关键发现

### 2.1 回复/讨论的识别方式

| 元素 | 说明 | 示例 |
|------|------|------|
| **评论旁的数字** | 点赞数，不是回复数！ | `"12"`, `"4"`, `"0"` |
| **"查看X条回复"按钮** | 真正的回复/讨论入口 | `"查看3条回复"`, `"查看8条回复"` |
| **回复容器** | 点击后展开，包含所有回复 | `generic [ref=e1978]` |
| **回复前缀** | 二级及以上回复带有 `"回复XXX:"` | `"回复木…易:"` |

### 2.2 回复层级关系

```
主评论 (一级)
  ├─ 回复1 (二级) - 直接回复主评论
  ├─ 回复2 (二级) - "回复XXX:" 表示回复的是回复1
  └─ 回复3 (二级) - "回复XXX:" 表示回复的是回复2
```

**注意**: 抖音的回复结构是**扁平化**的，所有回复都在同一层级，通过 `"回复XXX:"` 前缀来标识回复关系。

### 2.3 展开/收起机制

```
初始状态: [查看3条回复] ▼
   ↓ 点击
展开状态:
   [回复1]
   [回复2]
   [回复3]
   [收起] ▲
```

---

## 三、DOM 选择器分析

### 3.1 主评论列表选择器

```javascript
// 评论列表容器
const commentList = document.querySelector('[role="tabpanel"] > div > div:nth-child(3)');

// 所有主评论
const mainComments = commentList.querySelectorAll(':scope > div');

// 每个主评论的结构
mainComments.forEach(comment => {
  const checkbox = comment.querySelector('[type="checkbox"]');
  const avatar = comment.querySelector('[role="listitem"] img');
  const username = comment.querySelector('generic:nth-child(3) > generic:nth-child(1)');
  const time = comment.querySelector('generic:nth-child(3) > generic:nth-child(2)');
  const content = comment.querySelector('generic:nth-child(3) > generic:nth-child(3)');

  // ⭐ 点赞数 (不是回复数！)
  const likeCount = comment.querySelector('generic:nth-child(3) > generic:nth-last-child(2) > generic:first-child');

  // ⭐ 查看回复按钮
  const viewRepliesButton = comment.querySelector('generic:last-child');
  if (viewRepliesButton && viewRepliesButton.textContent.includes('查看')) {
    const replyCount = parseInt(viewRepliesButton.textContent.match(/\d+/)[0]);
    console.log(`该评论有 ${replyCount} 条回复`);
  }
});
```

### 3.2 回复列表选择器

```javascript
// 主评论下的回复容器 (展开后出现)
const repliesContainer = comment.querySelector('generic:nth-child(3) > div');

if (repliesContainer) {
  // 所有回复
  const replies = repliesContainer.querySelectorAll(':scope > div:not(:last-child)');

  replies.forEach(reply => {
    const username = reply.querySelector('generic:nth-child(3) > generic:nth-child(1)');
    const time = reply.querySelector('generic:nth-child(3) > generic:nth-child(2)');
    const contentDiv = reply.querySelector('generic:nth-child(3) > generic:nth-child(3)');

    // 检查是否有 "回复XXX:" 前缀
    const replyToPrefix = contentDiv.querySelector('generic:first-child');
    const replyToUser = replyToPrefix ? replyToPrefix.textContent.replace('回复', '').replace(':', '') : null;

    // 回复内容 (去除 "回复XXX:" 前缀)
    const replyText = Array.from(contentDiv.childNodes)
      .filter(node => node.nodeType === Node.TEXT_NODE)
      .map(node => node.textContent.trim())
      .join('');

    console.log({
      username: username.textContent,
      time: time.textContent,
      replyTo: replyToUser,
      content: replyText
    });
  });
}
```

---

## 四、API 拦截分析

### 4.1 可能的 API 端点

根据页面行为推测，可能存在以下 API：

```
1. 获取评论列表:
   GET /api/comment/list?aweme_id=xxx&count=20

2. 获取某条评论的回复:
   GET /api/comment/reply/list?comment_id=xxx&count=20

3. 点赞评论:
   POST /api/comment/digg

4. 删除评论:
   POST /api/comment/delete
```

**建议**: 使用 API 拦截来获取完整的回复数据，避免 DOM 解析的复杂性。

### 4.2 API 拦截实现

```javascript
// 在 crawl-comments.js 中添加 API 拦截
async function setupAPIInterceptors(page) {
  await page.route('**/api/comment/**', async (route) => {
    const url = route.request().url();
    const response = await route.fetch();
    const json = await response.json();

    if (url.includes('/reply/list')) {
      // 保存回复数据
      apiResponses.replies = apiResponses.replies || [];
      apiResponses.replies.push(json);
    }

    await route.continue();
  });
}
```

---

## 五、当前爬虫实现检查

### 5.1 检查现有代码

需要检查以下文件是否正确处理回复/讨论：

```
packages/worker/src/platforms/douyin/crawl-comments.js
```

### 5.2 预期问题

根据私信爬虫的经验，可能存在的问题：

1. **只抓取主评论，未抓取回复**
   - 只提取了评论列表，未点击"查看X条回复"按钮
   - 数据库中没有回复数据

2. **未建立回复关系**
   - 即使抓取了回复，也没有记录 `reply_to` 关系
   - 无法还原评论树结构

3. **选择器错误**
   - 可能将"点赞数"误认为"回复数"
   - 导致回复统计不准确

### 5.3 数据库表结构检查

检查 `comments` 表是否有以下字段：

```sql
-- 主评论相关
comment_id TEXT PRIMARY KEY,
parent_comment_id TEXT,  -- 父评论ID (一级评论为NULL)
reply_to_user_id TEXT,   -- 回复的用户ID
reply_to_user_name TEXT, -- 回复的用户名
reply_count INTEGER,     -- 回复数量
like_count INTEGER,      -- 点赞数量

-- 如果缺少这些字段，需要添加
```

---

## 六、爬虫改进方案

### 6.1 方案A: DOM 解析 (当前方案)

**步骤**:

1. **提取主评论列表**
   ```javascript
   const mainComments = await extractMainComments(page);
   ```

2. **遍历每条主评论**
   ```javascript
   for (const comment of mainComments) {
     // 检查是否有回复
     const viewRepliesButton = comment.querySelector('查看X条回复');

     if (viewRepliesButton) {
       // 点击展开回复
       await viewRepliesButton.click();
       await page.waitForTimeout(1000);

       // 提取回复列表
       const replies = await extractReplies(comment);

       // 保存回复数据
       replies.forEach(reply => {
         reply.parent_comment_id = comment.comment_id;
         saveReply(reply);
       });

       // 收起回复
       await comment.querySelector('收起').click();
     }
   }
   ```

3. **解析回复关系**
   ```javascript
   function extractReplies(commentElement) {
     const repliesContainer = commentElement.querySelector('回复容器');
     const replyElements = repliesContainer.querySelectorAll('回复元素');

     return Array.from(replyElements).map(elem => {
       const replyToPrefix = elem.querySelector('回复XXX:');

       return {
         comment_id: generateId(),
         parent_comment_id: parentId,
         user_name: elem.querySelector('用户名').textContent,
         content: elem.querySelector('内容').textContent,
         reply_to_user_name: replyToPrefix ? extractUsername(replyToPrefix) : null,
         created_at: parseTime(elem.querySelector('时间').textContent),
         like_count: parseInt(elem.querySelector('点赞数').textContent),
       };
     });
   }
   ```

**优点**:
- 不依赖 API，更稳定
- 可以处理各种边缘情况

**缺点**:
- 需要逐个展开回复，速度慢
- DOM 结构变化会导致失效
- 页面操作复杂，容易出错

### 6.2 方案B: API 拦截 (推荐 ⭐)

**步骤**:

1. **设置 API 拦截器**
   ```javascript
   await page.route('**/api/comment/**', captureCommentAPI);
   ```

2. **触发 API 调用**
   ```javascript
   // 点击"查看回复"按钮会触发 API 请求
   await viewRepliesButton.click();

   // 等待 API 响应
   await page.waitForResponse(response =>
     response.url().includes('/reply/list')
   );
   ```

3. **从 API 响应中提取数据**
   ```javascript
   const replyData = apiResponses.replies.find(r =>
     r.comment_id === parentCommentId
   );

   replyData.reply_list.forEach(reply => {
     saveReply({
       comment_id: reply.cid,
       parent_comment_id: parentCommentId,
       user_id: reply.user.uid,
       user_name: reply.user.nickname,
       content: reply.text,
       reply_to_user_id: reply.reply_to_userid,
       reply_to_user_name: reply.reply_to_username,
       created_at: reply.create_time * 1000,
       like_count: reply.digg_count,
     });
   });
   ```

**优点**:
- 速度快，数据完整
- 不受 DOM 结构变化影响
- 获取的数据更准确（含 ID、时间戳等）

**缺点**:
- 依赖 API 结构，API 变化会失效
- 需要逆向分析 API 参数

### 6.3 方案C: 混合方案 (最稳健 ⭐⭐⭐)

结合 DOM 解析和 API 拦截：

```javascript
async function crawlCommentsWithReplies(page, videoId) {
  // 1. 设置 API 拦截
  const apiResponses = {};
  await setupAPIInterceptors(page, apiResponses);

  // 2. 导航到评论页面
  await navigateToComments(page, videoId);

  // 3. 获取主评论列表
  const mainComments = await extractMainComments(page);

  // 4. 遍历主评论，展开回复
  for (const comment of mainComments) {
    const viewRepliesButton = await findViewRepliesButton(comment);

    if (viewRepliesButton) {
      // 点击展开 (会触发 API 请求)
      await viewRepliesButton.click();
      await page.waitForTimeout(500);

      // 优先使用 API 数据
      const apiReplies = apiResponses.replies?.[comment.comment_id];

      if (apiReplies) {
        // 从 API 提取回复数据
        saveRepliesFromAPI(apiReplies, comment.comment_id);
      } else {
        // 降级到 DOM 解析
        const domReplies = await extractRepliesFromDOM(comment);
        saveRepliesFromDOM(domReplies, comment.comment_id);
      }

      // 收起回复
      await clickCollapseButton(comment);
    }
  }

  return {
    comments: mainComments.length,
    replies: Object.values(apiResponses.replies).flat().length
  };
}
```

---

## 七、测试计划

### 7.1 测试用例

| 测试场景 | 预期结果 |
|---------|---------|
| 评论无回复 | 不展开，不抓取 |
| 评论有1条回复 | 展开，抓取1条 |
| 评论有多条回复 (3-10条) | 展开，抓取所有 |
| 评论有大量回复 (>10条) | 展开，处理分页 |
| 回复中有"回复XXX:" | 正确解析 reply_to |
| 回复中有表情符号 | 正确保存 |
| 多层嵌套回复 | 正确建立树结构 |

### 7.2 测试脚本

```javascript
// tests/测试评论回复抓取.js

const Database = require('better-sqlite3');
const path = require('path');

async function testCommentReplies() {
  console.log('📋 测试评论回复抓取功能\n');

  // 1. 连接数据库
  const dbPath = path.join(__dirname, '../packages/master/data/master.db');
  const db = new Database(dbPath);

  // 2. 查询评论统计
  const stats = db.prepare(`
    SELECT
      COUNT(*) as total_comments,
      COUNT(CASE WHEN parent_comment_id IS NULL THEN 1 END) as main_comments,
      COUNT(CASE WHEN parent_comment_id IS NOT NULL THEN 1 END) as replies
    FROM comments
  `).get();

  console.log('📊 评论统计:');
  console.log(`  总评论数: ${stats.total_comments}`);
  console.log(`  主评论数: ${stats.main_comments}`);
  console.log(`  回复数: ${stats.replies}\n`);

  // 3. 检查回复关系
  const repliesWithParent = db.prepare(`
    SELECT
      c1.content as reply_content,
      c1.reply_to_user_name,
      c2.content as parent_content
    FROM comments c1
    LEFT JOIN comments c2 ON c1.parent_comment_id = c2.comment_id
    WHERE c1.parent_comment_id IS NOT NULL
    LIMIT 5
  `).all();

  if (repliesWithParent.length > 0) {
    console.log('✅ 回复关系示例:');
    repliesWithParent.forEach((r, i) => {
      console.log(`\n  ${i + 1}. 回复内容: "${r.reply_content}"`);
      console.log(`     回复对象: ${r.reply_to_user_name}`);
      console.log(`     主评论: "${r.parent_content}"`);
    });
  } else {
    console.log('❌ 数据库中没有回复数据！');
  }

  db.close();
}

testCommentReplies().catch(console.error);
```

---

## 八、结论和建议

### 8.1 当前问题确认

根据用户反馈"评论里的讨论我们貌似没有抓取回来"，经过分析确认：

1. ✅ **回复/讨论确实存在**
   - 通过"查看X条回复"按钮可以展开
   - 每条主评论可能有多条回复

2. ⚠️ **可能的抓取问题**
   - 当前爬虫可能只抓取了主评论
   - 未点击"查看回复"按钮展开回复列表
   - 数据库中缺少回复数据

### 8.2 立即行动项

1. **检查现有代码**
   ```bash
   # 检查 crawl-comments.js 是否处理回复
   grep -n "查看.*回复" packages/worker/src/platforms/douyin/crawl-comments.js
   grep -n "reply" packages/worker/src/platforms/douyin/crawl-comments.js
   ```

2. **检查数据库**
   ```sql
   SELECT COUNT(*) FROM comments WHERE parent_comment_id IS NOT NULL;
   -- 如果结果为 0，确认没有抓取回复
   ```

3. **实现回复抓取功能**
   - 参考本报告第六章"爬虫改进方案"
   - 推荐使用"方案C: 混合方案"

### 8.3 后续优化

1. **数据库 Schema 优化**
   ```sql
   ALTER TABLE comments ADD COLUMN reply_count INTEGER DEFAULT 0;
   ALTER TABLE comments ADD COLUMN like_count INTEGER DEFAULT 0;
   ALTER TABLE comments ADD COLUMN reply_to_user_id TEXT;
   ALTER TABLE comments ADD COLUMN reply_to_user_name TEXT;
   ```

2. **性能优化**
   - 使用批量插入减少数据库操作
   - 只展开有回复的评论
   - 使用 API 拦截提高速度

3. **监控和日志**
   ```javascript
   logger.info(`[Phase X] 抓取评论: ${mainComments.length} 条主评论, ${totalReplies} 条回复`);
   ```

---

**报告生成时间**: 2025-10-24 21:40
**状态**: ✅ 分析完成，等待实现
**下一步**: 检查现有代码 → 实现回复抓取功能 → 测试验证
