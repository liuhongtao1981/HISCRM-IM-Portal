# 私信爬虫 0 消息问题 - 虚拟列表索引问题

## 时间: 2025-11-05 10:38

## 问题发现

用户反馈："他貌似找不到会话了，一直在移动"

## 根本原因

**虚拟列表的特性**:
- 虚拟列表只渲染可见的元素（约 16 个）
- 当滚动时，DOM 中的元素会被替换
- **索引是动态的，不固定的**

**当前方法的问题**:
1. 滚动会话列表到位置 `index * 80px`
2. 等待 1 秒
3. 重新获取元素列表
4. 使用索引 `allConversations[index]` 点击

**为什么失败**:
- 滚动后，虚拟列表渲染了新的元素
- 但这些新元素的索引可能不是我们想要的
- 例如：滚动到第 20 个会话，虚拟列表可能渲染第 15-31 个会话
- 但 `allConversations[20]` 可能是第 35 个会话（因为虚拟列表重新编号）

## 正确的解决方案

### 方案 A: 使用会话名称定位 ✅ 推荐

不使用索引，而是使用会话的名称来定位：

```javascript
// 1. 滚动到目标区域
const scrollDistance = conversationIndex * 80;
await page.evaluate((distance) => {
  const grid = document.querySelector('[role="grid"]');
  if (grid) grid.scrollTop = distance;
}, scrollDistance);

await page.waitForTimeout(1000);

// 2. 使用会话名称查找元素
const targetElement = await page.locator(`[role="list-item"]:has-text("${conversation.platform_user_name}")`).first();

// 3. 确保元素可见
await targetElement.scrollIntoViewIfNeeded();

// 4. 点击
await targetElement.click({ timeout: 10000 });
```

**优点**:
- 不依赖索引
- 名称是唯一标识
- 更稳定

**缺点**:
- 重复名称会有问题（但抖音用户名应该唯一）

### 方案 B: 直接滚动元素到可见

如果 Playwright 支持，直接通过 `scrollIntoViewIfNeeded` 触发虚拟列表加载：

```javascript
const element = await page.locator(`[role="list-item"]:has-text("${conversation.platform_user_name}")`).first();
await element.scrollIntoViewIfNeeded({ timeout: 30000 });
await element.click();
```

但这可能仍然超时（之前已经失败）。

### 方案 C: 只处理前 N 个可见会话

不尝试打开所有会话，只处理前 16 个（虚拟列表当前渲染的）：

```javascript
const maxConversationsToProcess = 16; // 只处理可见的会话
for (let i = 0; i < Math.min(conversations.length, maxConversationsToProcess); i++) {
  await openConversationByIndex(page, conversations[i], i);
}
```

**优点**:
- 简单可靠
- 不需要滚动

**缺点**:
- 只能处理部分会话

## 下一步

实施方案 A：使用会话名称定位，不依赖索引。
