# 未读数反复横跳问题 - 诊断报告

## 问题描述

用户反馈："我点击了一下左侧账户，右侧变成33条未读，再点一下又变成29，在点又变成33，反复横跳"

### 用户操作流程：
1. 点击左侧账户 A
2. 右侧 Tab 徽章显示 33 条未读
3. 再次点击同一账户 A
4. 右侧 Tab 徽章变成 29 条未读
5. 再次点击
6. 又变成 33 条未读

**问题特征**：未读数在两个值之间反复变化，说明计算逻辑存在不确定性。

## 根本原因分析

### 原因 1: 服务端计算 unreadCount 时的过滤逻辑不稳定

**位置**: `packages/master/src/communication/im-websocket-server.js` Line 463-467

```javascript
const unreadMessages = conversationMessages.filter(m => {
  // 检查是否已读：read_at 字段存在且不为空/null
  const isRead = m.read_at || m.readAt || m.isRead;
  return !isRead;  // 返回未读的消息
});
```

**问题**：使用 `||` 运算符检查多个字段，可能导致不一致：
- 某些消息有 `read_at` 字段
- 某些消息有 `readAt` 字段
- 某些消息有 `isRead` 字段
- 字段的值可能是 `null`, `undefined`, `0`, `false`, `''` 等

**例子**：
```javascript
// 消息 A
{ read_at: null, readAt: 0, isHandled: true }
// 当前逻辑: isRead = null || 0 → 0 (falsy) → 视为未读 ❌

// 消息 B
{ read_at: 0, readAt: null, isHandled: true }
// 当前逻辑: isRead = 0 || null → null (falsy) → 视为未读 ❌
```

### 原因 2: 数据库和内存数据不一致

**可能性**：
- 内存中的 `messages` 列表可能包含尚未写入数据库的消息
- 或者数据库中的 `read_at` 字段已更新，但内存中的消息对象尚未更新

**场景**：
1. 用户点击会话 → 客户端标记消息已读
2. 客户端发送 `monitor:mark_conversation_as_read` 事件
3. 服务端更新数据库（异步）
4. 但内存中的消息对象尚未更新 `read_at` 字段
5. 下次请求 topics 时，服务端从内存计算 unreadCount → 结果不准确

### 原因 3: 客户端和服务端的未读标准不一致

**服务端标准** (`im-websocket-server.js`):
```javascript
const isRead = m.read_at || m.readAt || m.isRead;
```

**客户端标准** (`MonitorPage.tsx`):
```typescript
const unreadMessages = privateMessages.filter(msg =>
  !msg.isHandled && msg.fromId !== 'monitor_client'
)
```

**不一致**：
- 服务端使用 `read_at` / `readAt` / `isRead`
- 客户端使用 `isHandled`
- 两者标准不同，导致计算结果不一致

## 诊断步骤

### 步骤 1: 添加详细的调试日志（服务端）

修改 `im-websocket-server.js`:

```javascript
// 在计算未读消息时添加日志
const unreadMessages = conversationMessages.filter(m => {
  const isRead = m.read_at || m.readAt || m.isRead;
  const result = !isRead;

  if (result) {
    logger.debug(`[UNREAD] 消息 ${m.id}: read_at=${m.read_at}, readAt=${m.readAt}, isRead=${m.isRead}, isHandled=${m.isHandled} → 未读`);
  }

  return result;
});

logger.info(`[UNREAD] 会话 "${conversation.userName}": 总消息=${conversationMessages.length}, 未读=${unreadMessages.length}`);
```

### 步骤 2: 检查消息对象的字段

查看数据库中的 `direct_messages` 表：
```sql
SELECT
  id,
  conversationId,
  read_at,
  readAt,
  isRead,
  isHandled,
  createdAt
FROM direct_messages
WHERE conversationId = 'xxx'
ORDER BY createdAt DESC
LIMIT 10;
```

### 步骤 3: 统一未读标准

**建议**：统一使用 `read_at` 字段作为唯一的已读标记。

**原因**：
1. 语义清晰：`read_at` 表示"何时被标记为已读"
2. 支持时间戳：可以记录已读时间
3. 易于查询：`WHERE read_at IS NULL` 表示未读

## 修复方案

### 方案 1: 统一已读判断逻辑（推荐）

**服务端** (`im-websocket-server.js`):
```javascript
const unreadMessages = conversationMessages.filter(m => {
  // ✅ 统一标准：只使用 read_at 字段
  // read_at 为 null/undefined/0 表示未读
  // read_at 为时间戳表示已读
  const readAt = m.read_at || m.readAt;  // 兼容两种命名
  return !readAt || readAt === 0;  // 明确判断
});
```

**客户端** (`MonitorPage.tsx`):
```typescript
const unreadMessages = privateMessages.filter(msg => {
  // ✅ 统一标准：只使用 read_at 或 readAt
  const readAt = msg.read_at || msg.readAt;
  return !readAt || readAt === 0;
})
```

**关键点**：
- 不再使用 `isRead` 和 `isHandled` 字段
- 统一使用 `read_at` / `readAt` 时间戳字段
- 明确判断：`!readAt || readAt === 0` 表示未读

### 方案 2: 服务端标记已读时同步更新内存对象

**位置**: `im-websocket-server.js` 的 `handleMarkConversationAsRead` 方法

```javascript
handleMarkConversationAsRead(socket, data) {
  const { topicId } = data;
  logger.info(`[IM WS] Mark conversation as read: ${topicId}`);

  try {
    // 1. 更新数据库
    this.cacheDAO.markConversationAsRead(topicId);

    // 2. ✅ 同步更新内存中的消息对象
    const accountId = this.getAccountIdFromTopicId(topicId);
    const dataObj = dataStore.getAccountData(accountId);
    if (dataObj && dataObj.messages) {
      const messages = dataObj.messages instanceof Map
        ? Array.from(dataObj.messages.values())
        : dataObj.messages;

      messages.forEach(msg => {
        if (msg.conversationId === topicId) {
          msg.read_at = Date.now();  // ✅ 更新内存对象
        }
      });
    }

    socket.emit('monitor:mark_as_read_success', { topicId });
  } catch (error) {
    logger.error('[IM WS] Mark conversation as read error:', error);
    socket.emit('monitor:mark_as_read_error', { topicId, error: error.message });
  }
}
```

### 方案 3: 客户端避免重复请求 topics

**问题**：每次点击账户都会重新请求 topics，导致服务端重新计算 unreadCount。

**解决**：
- 第一次点击账户时请求 topics
- 后续点击同一账户时，不重新请求（使用缓存的 topics）
- 只在需要刷新时（例如收到新消息）才重新请求

**修改** (`MonitorPage.tsx`):
```typescript
const handleSelectChannel = (channelId: string) => {
  dispatch(selectChannel(channelId))

  // ✅ 只在第一次或需要刷新时请求 topics
  const existingTopics = topics[channelId]
  if (!existingTopics || existingTopics.length === 0) {
    websocketService.emit('monitor:request_topics', { channelId })
  }

  // ... 其余逻辑
}
```

## 推荐修复流程

1. **立即修复：统一已读判断逻辑**（方案 1）
   - 服务端和客户端都只使用 `read_at` / `readAt` 字段
   - 明确判断：`!readAt || readAt === 0` 表示未读

2. **短期优化：同步更新内存对象**（方案 2）
   - 在 `handleMarkConversationAsRead` 中同步更新内存

3. **长期优化：避免重复请求**（方案 3）
   - 客户端缓存 topics，避免重复请求

## 验证清单

修复后需要验证：

1. ✅ 点击同一账户多次，未读数保持一致
2. ✅ 标记消息已读后，未读数立即减少
3. ✅ 刷新页面后，未读数与之前一致
4. ✅ 新消息到达时，未读数正确增加
5. ✅ 服务端和客户端计算的未读数一致

## 总结

**根本原因**：服务端计算 unreadCount 时的判断逻辑不稳定，使用了多个可能不一致的字段（`read_at`, `readAt`, `isRead`），且与客户端的标准（`isHandled`）不一致。

**解决方案**：统一使用 `read_at` 时间戳字段作为唯一的已读标记，服务端和客户端都遵循同一标准。

**预期效果**：未读数计算稳定，不再出现"反复横跳"的问题。
