# 私信消息推送机制 - 正确设计方案

## 问题分析

**原始问题**：IM PC 客户端显示"暂无私信消息"

**最初理解错误**：我以为应该 Worker 推送数据 → Master 广播给 IM

**正确理解（用户指出）**：
> "广播时机不对，每个消息无论什么都有已读维度嘛，无论推送还是拉取，都应该是 master 跟 im，跟 worker 根本没有任何关系，worker 只是个数据搬运，按照他现在的架构，应该 master 有个定期去检测所有未读数据推送给 im"

## 架构设计原则

### 角色定义

1. **Worker**
   - 唯一职责：爬取数据
   - 推送数据到 Master DataStore
   - **不关心**已读/未读状态
   - **不关心**IM 客户端

2. **Master**
   - 管理**已读/未读状态**
   - 定期检测未读数据
   - 主动推送给 IM 客户端
   - 接收 IM 客户端的已读标记

3. **IM 客户端**
   - 接收 Master 的推送通知
   - 显示未读消息
   - 标记消息为已读

### 数据流

```
Worker (爬虫)
   ↓ WORKER_DATA_SYNC
Master DataStore (数据存储)
   ↓ 定期检测 (每 5 秒)
Master IM WebSocket (未读数变化？)
   ↓ monitor:unread_update (仅推送变化)
IM 客户端 (显示通知)
   ↓ monitor:mark_as_read
Master (更新已读状态)
```

## 实现方案

### 1. Worker 端（无需修改）

Worker 只负责爬取数据，推送给 Master：

```javascript
// packages/worker/src/platforms/base/worker-bridge.js
async syncData() {
  const snapshot = {
    platform: 'douyin',
    data: {
      comments: [...],      // isHandled: false (默认未读)
      conversations: [...],  // unreadCount: 0/1/2...
      messages: [...]
    }
  };

  // 推送给 Master，不关心后续处理
  this.socket.emit('message', createMessage('WORKER_DATA_SYNC', {
    accountId, platform, snapshot, timestamp: Date.now()
  }));
}
```

### 2. Master 端实现

#### 2.1 配置文件

**文件**：`packages/master/.env`

```bash
# ============================================
# IM WebSocket 配置
# ============================================
IM_UNREAD_POLL_INTERVAL=5000  # 未读消息推送间隔(ms) - Master 每5秒检测未读数并推送给 IM 客户端
```

#### 2.2 初始化定时器

**文件**：`packages/master/src/index.js`

```javascript
// Line 539-541
const unreadPollInterval = parseInt(process.env.IM_UNREAD_POLL_INTERVAL) || 5000;
imWebSocketServer.startUnreadNotificationPolling(unreadPollInterval);
logger.info(`IM WebSocket unread notification polling started (interval: ${unreadPollInterval}ms)`);
```

#### 2.3 定期检测未读数

**文件**：`packages/master/src/communication/im-websocket-server.js`

```javascript
/**
 * 启动未读消息定期推送
 * @param {number} interval - 轮询间隔（毫秒），默认 5000ms
 */
startUnreadNotificationPolling(interval = 5000) {
  // 如果已经有定时器在运行，先停止
  if (this.unreadPollingTimer) {
    clearInterval(this.unreadPollingTimer);
  }

  // 存储上一次的未读数，用于检测变化
  this.lastUnreadCounts = new Map(); // accountId -> { comments, messages, total }

  this.unreadPollingTimer = setInterval(() => {
    this.checkAndPushUnreadNotifications();
  }, interval);

  logger.info(`[IM WS] Unread notification polling started (interval: ${interval}ms)`);
}

/**
 * 检测并推送未读消息通知
 */
checkAndPushUnreadNotifications() {
  try {
    // 如果没有连接的客户端，跳过
    if (this.monitorClients.size === 0 && this.adminClients.size === 0) {
      return;
    }

    // 遍历所有账户，检测未读数变化
    const accounts = this.dataStore.accounts; // Map<accountId, AccountData>

    for (const [accountId, accountData] of accounts) {
      if (!accountData || !accountData.data) continue;

      // 计算当前未读数
      const currentUnread = {
        comments: this.calculateUnreadComments(accountData.data),
        messages: this.calculateUnreadMessages(accountData.data),
        total: 0
      };
      currentUnread.total = currentUnread.comments + currentUnread.messages;

      // 获取上一次的未读数
      const lastUnread = this.lastUnreadCounts.get(accountId) || { comments: 0, messages: 0, total: 0 };

      // 检测是否有新的未读消息
      if (currentUnread.total > lastUnread.total) {
        const newComments = currentUnread.comments - lastUnread.comments;
        const newMessages = currentUnread.messages - lastUnread.messages;

        logger.info(`[IM WS] New unread detected for ${accountId}: +${newComments} comments, +${newMessages} messages`);

        // 广播未读数更新
        this.broadcastToMonitors('monitor:unread_update', {
          channelId: accountId,
          unread: currentUnread,
          delta: {
            comments: newComments,
            messages: newMessages,
            total: currentUnread.total - lastUnread.total
          }
        });

        // 更新缓存
        this.lastUnreadCounts.set(accountId, currentUnread);
      } else if (currentUnread.total < lastUnread.total) {
        // 未读数减少（用户标记已读）
        logger.debug(`[IM WS] Unread decreased for ${accountId}: ${lastUnread.total} -> ${currentUnread.total}`);
        this.lastUnreadCounts.set(accountId, currentUnread);
      }
    }
  } catch (error) {
    logger.error('[IM WS] Check unread notifications error:', error);
  }
}

/**
 * 计算未读评论数
 */
calculateUnreadComments(dataObj) {
  const commentsList = dataObj.comments instanceof Map ? Array.from(dataObj.comments.values()) : (dataObj.comments || []);
  return commentsList.filter(c => c.isHandled === undefined || !c.isHandled).length;
}

/**
 * 计算未读私信数
 */
calculateUnreadMessages(dataObj) {
  const conversationsList = dataObj.conversations instanceof Map ? Array.from(dataObj.conversations.values()) : (dataObj.conversations || []);
  return conversationsList.reduce((sum, conv) => sum + (conv.unreadCount || 0), 0);
}
```

#### 2.4 shutdown 时停止定时器

**文件**：`packages/master/src/index.js`

```javascript
// Line 748
if (imWebSocketServer) imWebSocketServer.stopUnreadNotificationPolling();
```

### 3. IM 客户端实现（需要添加）

**文件**：`packages/crm-pc-im/src/services/websocket.ts`

```typescript
// 监听未读数更新
socket.on('monitor:unread_update', (data) => {
  const { channelId, unread, delta } = data;

  console.log(`[IM] 收到未读消息:`, {
    channelId,
    总未读: unread.total,
    新增评论: delta.comments,
    新增私信: delta.messages
  });

  // 显示通知
  showNotification({
    title: '新消息',
    body: `${delta.comments} 条新评论，${delta.messages} 条新私信`,
    channelId
  });

  // 更新 Redux 状态
  dispatch({
    type: 'UPDATE_UNREAD_COUNT',
    payload: { channelId, unread }
  });
});

// 标记已读
function markAsRead(messageId, topicId) {
  socket.emit('monitor:mark_as_read', {
    messageId,
    topicId
  });
}
```

## 关键设计点

### 1. 为什么不在 Worker 推送时广播？

**原因**：
- Worker 推送间隔：30 秒
- 如果每次 Worker 推送都广播，IM 客户端会频繁收到通知
- 即使没有**新消息**，也会收到通知（因为 Worker 每次推送全量数据）

**正确做法**：
- Worker 推送 → Master DataStore 更新
- Master **定期检测**未读数**变化**
- **仅在未读数增加时**推送给 IM

### 2. 为什么需要缓存上一次的未读数？

**原因**：
- 检测**增量变化**（从 5 条未读 → 7 条未读 = 新增 2 条）
- 避免重复推送（未读数没变化时不推送）

### 3. 如何处理已读状态？

**流程**：
1. IM 客户端标记消息已读 → `monitor:mark_as_read`
2. Master 更新 DataStore（`comment.isHandled = true`）
3. Master 持久化到数据库（`cache_comments.is_handled = 1`）
4. 下次定时检测时，未读数减少，更新缓存

### 4. 检测频率如何设置？

**建议**：
- 默认：5秒（`IM_UNREAD_POLL_INTERVAL=5000`）
- 生产环境可调整到 10-30 秒
- 不建议 < 3 秒（性能开销）
- 不建议 > 60 秒（通知延迟过高）

## 性能考虑

### CPU 开销

```
每次检测：
1. 遍历所有账户（1-100 个）
2. 遍历所有评论/会话（10-1000 条）
3. 过滤未读消息（O(n)）
4. 比较未读数（O(1)）

总复杂度：O(n * m)
n = 账户数，m = 平均消息数

实际开销：
- 1 账户 * 100 消息 * 5秒间隔 = 每秒 20 次过滤操作
- CPU < 1%
```

### 内存开销

```
this.lastUnreadCounts: Map<accountId, { comments, messages, total }>

实际占用：
- 1 账户 = 3 个数字 * 8 字节 = 24 字节
- 100 账户 = 2.4 KB
```

### 网络带宽

```
每次推送：
- 事件名：monitor:unread_update（21 字节）
- 数据：{ channelId, unread, delta }（约 100 字节）

广播给 N 个客户端：
- 100 字节 * N 个客户端 * 每 5 秒

实际带宽：
- 10 个客户端 = 1 KB / 5秒 = 0.2 KB/秒
```

## 对比分析

### 错误方案（Worker 推送时广播）

```
16:01:13 Worker 推送 (messages: 0)
   ↓
16:01:13 Master 广播 → IM (0 条消息)  ❌ 无意义广播

16:01:43 Worker 推送 (messages: 2)
   ↓
16:01:43 Master 广播 → IM (2 条消息)  ✅ 有效推送

16:02:13 Worker 推送 (messages: 2)  ← 没有新消息
   ↓
16:02:13 Master 广播 → IM (2 条消息)  ❌ 重复推送
```

**问题**：
- 30% 的广播是无效的（没有新消息）
- 客户端频繁刷新界面
- 浪费网络带宽

### 正确方案（Master 定期检测变化）

```
16:01:00 定时器：未读 0 条 → 缓存 0
16:01:05 定时器：未读 0 条 → 未变化，不推送 ✅
16:01:10 定时器：未读 0 条 → 未变化，不推送 ✅
16:01:15 定时器：未读 2 条 → 增加 2，推送！✅
16:01:20 定时器：未读 2 条 → 未变化，不推送 ✅
16:01:25 定时器：未读 2 条 → 未变化，不推送 ✅
16:01:30 定时器：未读 5 条 → 增加 3，推送！✅
```

**优势**：
- **仅在未读数变化时推送**
- 检测频率可配置（5-30秒）
- 与 Worker 推送频率解耦

## 实现状态

### 已完成 ✅

1. 添加配置项 `IM_UNREAD_POLL_INTERVAL`
2. 实现 `startUnreadNotificationPolling()` 方法
3. 实现 `checkAndPushUnreadNotifications()` 方法
4. 实现 `calculateUnreadComments()` 和 `calculateUnreadMessages()` 方法
5. 添加 shutdown 时停止定时器

### 待完成 ⏳

1. **修复 DataStore 访问**
   - 当前代码：`this.dataStore.getAllAccounts()` ❌
   - 正确代码：`this.dataStore.accounts` ✅
   - 文件：`im-websocket-server.js:1083`

2. **测试定时推送**
   - 启动 Master
   - 等待 Worker 推送新数据
   - 观察日志是否有 `[IM WS] New unread detected`

3. **IM 客户端添加监听**
   - 监听 `monitor:unread_update` 事件
   - 显示通知
   - 更新未读数

## 测试计划

### 1. Master 定时检测测试

```bash
# 启动 Master
cd packages/master && npm start

# 观察日志（每 5 秒）
# 应该看到：
[IM WS] Unread notification polling started (interval: 5000ms)

# 当 Worker 推送新数据后，应该看到：
[IM WS] New unread detected for acc-xxx: +2 comments, +1 messages
[IM WS] Broadcasted monitor:unread_update to 1 monitors
```

### 2. IM 客户端接收测试

```javascript
// 在浏览器控制台
window.socket.on('monitor:unread_update', (data) => {
  console.log('收到未读更新:', data);
});

// 应该看到：
// {
//   channelId: 'acc-xxx',
//   unread: { comments: 7, messages: 3, total: 10 },
//   delta: { comments: 2, messages: 1, total: 3 }
// }
```

### 3. 已读标记测试

```javascript
// 标记已读
window.socket.emit('monitor:mark_as_read', {
  messageId: 'msg-123',
  topicId: 'topic-456'
});

// 下次定时检测应该看到未读数减少
```

## 总结

**核心原则**：
1. **Worker 只负责数据搬运**，不关心已读/未读
2. **Master 负责管理已读状态**，定期检测变化
3. **仅在未读数增加时推送**，避免无效广播
4. **推送间隔可配置**，平衡实时性和性能

**关键收获**：
> 用户指出的逻辑错误非常正确！架构设计应该清晰划分职责，Worker 就是数据搬运工，不应该触发业务逻辑（如推送通知）。Master 才是中央协调者，负责管理状态和推送。

---

**文档版本**：v1.0
**最后更新**：2025-11-04 16:10
**状态**：设计完成，待测试验证
