# 实时监控 + 历史爬虫混合方案 - 开发计划 v2.0

**创建日期**: 2025-11-06
**方案版本**: v2.0 (基于现有架构调整)
**预计工期**: 3-4个工作日

---

## 📋 方案调整说明

### 与现有架构的融合

✅ **保留现有结构**:
- `crawl-direct-messages-v2.js` - 保持不变,已有完整的 API 拦截和 DOM 爬取
- `crawl-comments.js` - 保持不变,已有评论爬取逻辑
- `crawl-contents.js` - 保持不变,已有作品爬取逻辑
- `douyin-data-manager.js` - 保持不变,已有完整的数据映射

✅ **新增模块**:
- `realtime-monitor.js` - 实时监控核心(钩子注入)
- `crawl-scheduler.js` - 爬虫任务调度器
- 更新 `platform.js` - 集成实时监控和调度器

---

## 🎯 核心思路

### 两层监控架构

```
┌─────────────────────────────────────────────────┐
│           DouyinPlatform (platform.js)          │
│  ┌──────────────────────────────────────────┐  │
│  │   实时监控层 (realtime-monitor.js)       │  │
│  │   - 钩子注入到页面                       │  │
│  │   - msgListToPush 监听                   │  │
│  │   - noticePushList 监听                  │  │
│  │   - 通过 DouyinDataManager 格式化        │  │
│  │   - 直接推送到 Master                    │  │
│  └──────────────────────────────────────────┘  │
│                     ↓                           │
│  ┌──────────────────────────────────────────┐  │
│  │   爬虫调度层 (crawl-scheduler.js)        │  │
│  │   - 定时触发 (5-10分钟)                  │  │
│  │   - 调用现有爬虫:                        │  │
│  │     * crawlDirectMessagesV2()            │  │
│  │     * crawlCommentsV2()                  │  │
│  │   - 增量抓取(只抓新数据)                 │  │
│  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
                      ↓
         通过 DouyinDataManager 统一格式化
                      ↓
              推送到 Master Server
```

---

## 📐 文件结构 (调整后)

```
packages/worker/src/platforms/douyin/
├── platform.js                      # 更新: 集成实时监控和调度器
├── douyin-data-manager.js           # 保持: 数据映射层
│
├── crawl-direct-messages-v2.js      # 保持: 私信爬虫
├── crawl-comments.js                # 保持: 评论爬虫
├── crawl-contents.js                # 保持: 作品爬虫
│
├── realtime-monitor.js              # 新增: 实时监控核心
├── crawl-scheduler.js               # 新增: 爬虫调度器
└── install-hooks.js                 # 新增: 钩子注入脚本(浏览器端)
```

---

## 🔧 详细开发任务

### 阶段一: 实时监控核心 (1.5天)

#### 任务 1.1: 钩子注入脚本 (浏览器端)
**文件**: `packages/worker/src/platforms/douyin/install-hooks.js`

**说明**: 这是在浏览器中执行的脚本,改编自 `test-realtime-hook-monitor-v2.js`

**关键代码**:
```javascript
/**
 * 在浏览器中执行的钩子安装脚本
 * 改编自 test-realtime-hook-monitor-v2.js
 */

// IIFE,避免污染全局命名空间
(function() {
  'use strict';

  // ==================== 工具函数 ====================

  /**
   * 从 React Fiber 提取 imStore
   */
  function extractImStore() {
    const appElement = document.querySelector('#root') ||
                       document.querySelector('[data-reactroot]');

    if (!appElement) return null;

    const fiberKey = Object.keys(appElement).find(key =>
      key.startsWith('__reactFiber$') || key.startsWith('__reactInternalInstance$')
    );

    if (!fiberKey) return null;

    let fiber = appElement[fiberKey];
    while (fiber) {
      const state = fiber.memoizedState || fiber.stateNode?.state;
      if (state?.imStore) return state.imStore;

      const props = fiber.memoizedProps;
      if (props?.imStore) return props.imStore;

      fiber = fiber.return;
    }
    return null;
  }

  /**
   * 从 React Fiber 提取 noticeStore
   */
  function extractNoticeStore() {
    const appElement = document.querySelector('#root') ||
                       document.querySelector('[data-reactroot]');

    if (!appElement) return null;

    const fiberKey = Object.keys(appElement).find(key =>
      key.startsWith('__reactFiber$') || key.startsWith('__reactInternalInstance$')
    );

    if (!fiberKey) return null;

    let fiber = appElement[fiberKey];
    while (fiber) {
      const state = fiber.memoizedState || fiber.stateNode?.state;
      if (state?.noticeStore) return state.noticeStore;

      const props = fiber.memoizedProps;
      if (props?.noticeStore) return props.noticeStore;

      fiber = fiber.return;
    }
    return null;
  }

  // ==================== 钩子安装 ====================

  /**
   * 劫持数组方法
   */
  function hijackArray(arr, onAdd, arrayName) {
    const originalPush = arr.push;
    const originalSplice = arr.splice;
    const originalUnshift = arr.unshift;

    // 劫持 push
    arr.push = function(...items) {
      console.log(`🎯 [Hook] ${arrayName}.push() 捕获! 添加 ${items.length} 项`);

      items.forEach(item => {
        try {
          onAdd(item);
        } catch (e) {
          console.error(`[Hook] 回调错误:`, e);
        }
      });

      return originalPush.apply(this, items);
    };

    // 劫持 splice (当添加元素时)
    arr.splice = function(start, deleteCount, ...items) {
      if (items.length > 0) {
        console.log(`🎯 [Hook] ${arrayName}.splice() 添加 ${items.length} 项`);
        items.forEach(item => {
          try {
            onAdd(item);
          } catch (e) {
            console.error(`[Hook] 回调错误:`, e);
          }
        });
      }

      return originalSplice.apply(this, [start, deleteCount, ...items]);
    };

    // 劫持 unshift
    arr.unshift = function(...items) {
      console.log(`🎯 [Hook] ${arrayName}.unshift() 添加 ${items.length} 项`);

      items.forEach(item => {
        try {
          onAdd(item);
        } catch (e) {
          console.error(`[Hook] 回调错误:`, e);
        }
      });

      return originalUnshift.apply(this, items);
    };
  }

  // ==================== 数据处理 ====================

  /**
   * 处理新私信
   */
  function handleNewMessage(msg) {
    console.log('⚡ [实时捕获] 新私信!', {
      ID: msg.serverId,
      发送者: msg.sender,
      时间: new Date(msg.createdAt).toLocaleString()
    });

    // 调用 Playwright 暴露的函数,发送到 Node.js
    if (typeof window.__PLAYWRIGHT_sendRealtimeData === 'function') {
      window.__PLAYWRIGHT_sendRealtimeData({
        type: 'message',
        data: msg,
        timestamp: Date.now()
      });
    }
  }

  /**
   * 处理新评论
   */
  function handleNewComment(notice) {
    // 只处理评论通知 (type: 31)
    if (notice.type !== 31) return;

    console.log('⚡ [实时捕获] 新评论!', {
      ID: notice.nid_str,
      类型: notice.type,
      时间: new Date(notice.create_time * 1000).toLocaleString()
    });

    // 调用 Playwright 暴露的函数,发送到 Node.js
    if (typeof window.__PLAYWRIGHT_sendRealtimeData === 'function') {
      window.__PLAYWRIGHT_sendRealtimeData({
        type: 'comment',
        data: notice,
        timestamp: Date.now()
      });
    }
  }

  // ==================== 主逻辑 ====================

  /**
   * 安装钩子
   */
  function installHooks() {
    console.log('🔧 [Hook Installer] 开始安装钩子...');

    // 查找 imStore 和 noticeStore
    const imStore = extractImStore();
    const noticeStore = extractNoticeStore();

    let successCount = 0;

    // 安装私信钩子
    if (imStore?.msgListToPush) {
      hijackArray(imStore.msgListToPush, handleNewMessage, 'msgListToPush');
      console.log('✅ [Hook] msgListToPush 钩子已安装');
      successCount++;
    } else {
      console.warn('⚠️  [Hook] 未找到 imStore.msgListToPush');
    }

    // 安装评论钩子
    if (noticeStore?.noticePushList) {
      hijackArray(noticeStore.noticePushList, handleNewComment, 'noticePushList');
      console.log('✅ [Hook] noticePushList 钩子已安装');
      successCount++;
    } else {
      console.warn('⚠️  [Hook] 未找到 noticeStore.noticePushList');
    }

    // 返回安装结果
    return {
      success: successCount > 0,
      installedHooks: successCount,
      totalHooks: 2,
      hasImStore: !!imStore?.msgListToPush,
      hasNoticeStore: !!noticeStore?.noticePushList
    };
  }

  // ==================== 执行安装 ====================

  // 立即尝试安装
  const result = installHooks();

  // 如果安装失败,等待一段时间后重试
  if (!result.success) {
    console.log('⏳ [Hook Installer] 延迟 3 秒后重试安装...');
    setTimeout(() => {
      const retryResult = installHooks();
      console.log('🔁 [Hook Installer] 重试结果:', retryResult);
    }, 3000);
  }

  // 暴露检查函数(供 Node.js 调用)
  window.__PLAYWRIGHT_checkHookStatus = function() {
    const imStore = extractImStore();
    const noticeStore = extractNoticeStore();

    return {
      installed: true,
      hasImStore: !!imStore?.msgListToPush,
      hasNoticeStore: !!noticeStore?.noticePushList,
      timestamp: Date.now()
    };
  };

  console.log('🎉 [Hook Installer] 脚本加载完成');

})();
```

**预计时间**: 3小时

---

#### 任务 1.2: 实时监控管理器 (Node.js 端)
**文件**: `packages/worker/src/platforms/douyin/realtime-monitor.js`

**说明**: 负责注入钩子、接收数据、格式化并推送

**关键代码**:
```javascript
/**
 * 抖音实时监控管理器
 * 负责钩子注入、数据接收和格式化
 */

const path = require('path');
const { createLogger } = require('@hiscrm-im/shared/utils/logger');

class DouyinRealtimeMonitor {
  constructor(accountId, page, dataManager) {
    this.accountId = accountId;
    this.page = page;
    this.dataManager = dataManager;
    this.logger = createLogger(`realtime-monitor:${accountId}`);

    this.isInstalled = false;
    this.processedIds = new Set(); // 去重
  }

  /**
   * 启动实时监控
   */
  async start() {
    this.logger.info('启动实时监控...');

    try {
      // 1. 注入钩子脚本
      await this.installHooks();

      // 2. 暴露函数给页面
      await this.exposeHandlers();

      // 3. 监听页面导航,自动重新注入
      this.setupNavigationListener();

      this.logger.info('✅ 实时监控启动成功');
    } catch (error) {
      this.logger.error('实时监控启动失败:', error);
      throw error;
    }
  }

  /**
   * 注入钩子脚本到页面
   */
  async installHooks() {
    this.logger.info('注入钩子脚本...');

    const scriptPath = path.join(__dirname, 'install-hooks.js');

    await this.page.addScriptTag({
      path: scriptPath
    });

    // 等待脚本加载
    await this.page.waitForTimeout(1000);

    // 检查钩子状态
    const status = await this.page.evaluate(() => {
      if (typeof window.__PLAYWRIGHT_checkHookStatus === 'function') {
        return window.__PLAYWRIGHT_checkHookStatus();
      }
      return { installed: false };
    });

    if (status.installed) {
      this.isInstalled = true;
      this.logger.info('✅ 钩子安装成功', status);
    } else {
      this.logger.warn('⚠️  钩子安装可能失败', status);
    }
  }

  /**
   * 暴露函数给页面调用
   */
  async exposeHandlers() {
    // 暴露数据接收函数
    await this.page.exposeFunction(
      '__PLAYWRIGHT_sendRealtimeData',
      async (data) => {
        await this.handleRealtimeData(data);
      }
    );

    this.logger.info('✅ 函数已暴露给页面');
  }

  /**
   * 处理实时数据
   */
  async handleRealtimeData(data) {
    const { type, data: rawData, timestamp } = data;

    try {
      // 去重检查
      const id = type === 'message' ? rawData.serverId : rawData.nid_str;
      if (this.processedIds.has(id)) {
        this.logger.debug(`[去重] ${type} ${id} 已处理,跳过`);
        return;
      }

      // 格式化数据
      let formattedData;
      if (type === 'message') {
        formattedData = this.formatMessageData(rawData);
      } else if (type === 'comment') {
        formattedData = this.formatCommentData(rawData);
      }

      if (!formattedData) {
        this.logger.warn(`数据格式化失败: ${type}`);
        return;
      }

      // 通过 DataManager 推送数据
      if (type === 'message') {
        await this.dataManager.pushMessage(formattedData, 'realtime');
      } else if (type === 'comment') {
        await this.dataManager.pushComment(formattedData, 'realtime');
      }

      // 标记已处理
      this.processedIds.add(id);

      this.logger.info(`✅ [实时数据] ${type} 已推送`, {
        id,
        timestamp: new Date(timestamp).toLocaleString()
      });

    } catch (error) {
      this.logger.error(`处理实时数据失败:`, error);
    }
  }

  /**
   * 格式化私信数据
   */
  formatMessageData(rawData) {
    try {
      // 解析 content JSON
      const content = JSON.parse(rawData.content);

      // 需要补充用户信息(从 converSationListOrigin)
      // 这里简化处理,实际需要查询会话列表
      return {
        message_id: rawData.serverId,
        platform_message_id: rawData.serverId,
        conversation_id: rawData.conversationId,

        // 发送者
        platform_sender_id: rawData.sender,
        sender_id: rawData.secSender,
        platform_sender_name: '未知', // 需要补充
        sender_avatar: null,

        // 内容
        type: this.mapMessageType(rawData.type),
        content: content.text,
        text: content.text,

        // 方向
        direction: 'incoming', // 默认为接收

        // 时间
        created_at: new Date(rawData.createdAt).getTime(),
        create_time: new Date(rawData.createdAt).getTime(),

        // 原始数据
        rawData: rawData
      };
    } catch (error) {
      this.logger.error('格式化私信数据失败:', error);
      return null;
    }
  }

  /**
   * 格式化评论数据
   */
  formatCommentData(rawData) {
    try {
      const comment = rawData.comment?.comment;
      if (!comment) return null;

      return {
        cid: comment.cid,
        comment_id: comment.cid,

        // 作品
        aweme_id: rawData.comment?.aweme?.aweme_id,

        // 用户
        user: comment.user,
        user_id: comment.user?.uid,

        // 内容
        text: comment.text,
        content: comment.text,

        // 统计
        digg_count: comment.digg_count || 0,
        reply_comment_total: comment.reply_comment_total || 0,

        // 时间
        create_time: rawData.create_time,
        created_at: rawData.create_time * 1000,

        // 原始数据
        rawData: rawData
      };
    } catch (error) {
      this.logger.error('格式化评论数据失败:', error);
      return null;
    }
  }

  /**
   * 映射消息类型
   */
  mapMessageType(douyinType) {
    const typeMap = {
      7: 'text',
      // 其他类型...
    };
    return typeMap[douyinType] || 'text';
  }

  /**
   * 设置页面导航监听器
   */
  setupNavigationListener() {
    this.page.on('framenavigated', async (frame) => {
      if (frame === this.page.mainFrame()) {
        this.logger.info('页面导航,重新安装钩子...');
        this.isInstalled = false;

        // 延迟重新安装
        setTimeout(async () => {
          await this.installHooks();
          await this.exposeHandlers();
        }, 2000);
      }
    });
  }

  /**
   * 停止监控
   */
  async stop() {
    this.logger.info('停止实时监控');
    this.isInstalled = false;
    // 清理...
  }

  /**
   * 检查钩子状态
   */
  async checkStatus() {
    if (!this.page) return { installed: false };

    try {
      const status = await this.page.evaluate(() => {
        if (typeof window.__PLAYWRIGHT_checkHookStatus === 'function') {
          return window.__PLAYWRIGHT_checkHookStatus();
        }
        return { installed: false };
      });
      return status;
    } catch (error) {
      return { installed: false, error: error.message };
    }
  }
}

module.exports = { DouyinRealtimeMonitor };
```

**预计时间**: 5小时

---

### 阶段二: 爬虫调度器 (1天)

#### 任务 2.1: 爬虫调度器
**文件**: `packages/worker/src/platforms/douyin/crawl-scheduler.js`

**说明**: 定时调用现有爬虫函数,实现增量抓取

**关键代码**:
```javascript
/**
 * 抖音爬虫调度器
 * 定时触发现有爬虫函数,实现增量抓取
 */

const { createLogger } = require('@hiscrm-im/shared/utils/logger');
const { crawlDirectMessagesV2 } = require('./crawl-direct-messages-v2');
const { crawlComments } = require('./crawl-comments');

class DouyinCrawlScheduler {
  constructor(accountId, page, config, platform) {
    this.accountId = accountId;
    this.page = page;
    this.config = config;
    this.platform = platform;
    this.logger = createLogger(`crawl-scheduler:${accountId}`);

    this.intervalId = null;
    this.isRunning = false;
    this.lastCrawlTime = {
      messages: 0,
      comments: 0
    };
  }

  /**
   * 启动调度器
   */
  start() {
    const intervalMinutes = this.config.crawlInterval || 5;
    const intervalMs = intervalMinutes * 60 * 1000;

    this.logger.info(`启动爬虫调度器, 间隔: ${intervalMinutes} 分钟`);

    this.intervalId = setInterval(async () => {
      if (this.isRunning) {
        this.logger.warn('上次爬虫任务未完成,跳过本次');
        return;
      }

      try {
        this.isRunning = true;
        await this.executeCrawl();
      } catch (error) {
        this.logger.error('爬虫执行失败:', error);
      } finally {
        this.isRunning = false;
      }
    }, intervalMs);

    // 立即执行一次
    setTimeout(() => {
      this.executeCrawl().catch(err => {
        this.logger.error('首次爬虫执行失败:', err);
      });
    }, 10000); // 10秒后执行

    this.logger.info('✅ 爬虫调度器已启动');
  }

  /**
   * 执行爬虫任务
   */
  async executeCrawl() {
    this.logger.info('开始执行爬虫任务...');

    const startTime = Date.now();

    try {
      // 1. 爬取私信(如果启用)
      if (this.config.crawlMessages !== false) {
        await this.crawlMessagesIncremental();
      }

      // 2. 爬取评论(如果启用)
      if (this.config.crawlComments !== false) {
        await this.crawlCommentsIncremental();
      }

      const duration = Date.now() - startTime;
      this.logger.info(`爬虫任务完成, 耗时: ${duration}ms`);

    } catch (error) {
      this.logger.error('爬虫任务执行失败:', error);
      throw error;
    }
  }

  /**
   * 增量爬取私信
   */
  async crawlMessagesIncremental() {
    this.logger.info('开始增量爬取私信...');

    try {
      // 调用现有的 crawlDirectMessagesV2
      // 注意: 现有函数没有增量参数,这里可以通过配置控制
      const result = await crawlDirectMessagesV2(
        this.page,
        this.accountId,
        {
          // 可以传入上次爬取时间,实现增量
          sinceTime: this.lastCrawlTime.messages,
          // 其他配置...
        }
      );

      this.lastCrawlTime.messages = Date.now();

      this.logger.info(`✅ 私信爬取完成`, result);
    } catch (error) {
      this.logger.error('私信爬取失败:', error);
    }
  }

  /**
   * 增量爬取评论
   */
  async crawlCommentsIncremental() {
    this.logger.info('开始增量爬取评论...');

    try {
      // 调用现有的 crawlComments
      const result = await crawlComments(
        this.page,
        this.accountId,
        {
          sinceTime: this.lastCrawlTime.comments,
          // 其他配置...
        }
      );

      this.lastCrawlTime.comments = Date.now();

      this.logger.info(`✅ 评论爬取完成`, result);
    } catch (error) {
      this.logger.error('评论爬取失败:', error);
    }
  }

  /**
   * 停止调度器
   */
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    this.logger.info('爬虫调度器已停止');
  }

  /**
   * 更新间隔
   */
  updateInterval(minutes) {
    this.config.crawlInterval = minutes;
    this.logger.info(`更新爬虫间隔为: ${minutes} 分钟`);

    // 重启调度器
    this.stop();
    this.start();
  }

  /**
   * 获取状态
   */
  getStatus() {
    return {
      isRunning: this.isRunning,
      interval: this.config.crawlInterval,
      lastCrawlTime: this.lastCrawlTime,
      enabled: !!this.intervalId
    };
  }
}

module.exports = { DouyinCrawlScheduler };
```

**预计时间**: 4小时

---

### 阶段三: 集成到 Platform (0.5天)

#### 任务 3.1: 更新 platform.js
**文件**: `packages/worker/src/platforms/douyin/platform.js`

**说明**: 在 `startMonitoring()` 中集成实时监控和调度器

**关键代码**:
```javascript
// 在文件顶部添加导入
const { DouyinRealtimeMonitor } = require('./realtime-monitor');
const { DouyinCrawlScheduler } = require('./crawl-scheduler');

class DouyinPlatform extends PlatformBase {
  constructor(config, workerBridge, browserManager) {
    super(config, workerBridge, browserManager);

    this.loginHandler = new DouyinLoginHandler(browserManager, workerBridge.socket);

    // 新增: 存储实时监控和调度器实例
    this.realtimeMonitors = new Map(); // accountId -> monitor
    this.crawlSchedulers = new Map();  // accountId -> scheduler
  }

  /**
   * 启动监控 (重写)
   */
  async startMonitoring(accountId) {
    this.logger.info(`启动监控: ${accountId}`);

    // 获取账户配置
    const account = this.accounts.get(accountId);
    if (!account) {
      throw new Error(`账户 ${accountId} 未找到`);
    }

    // 解析监控配置
    const monitorConfig = this.parseMonitorConfig(account);

    // 获取页面
    const page = await this.browserManager.getAccountPage(accountId);
    if (!page) {
      throw new Error(`账户 ${accountId} 页面未创建`);
    }

    // 获取 DataManager
    const dataManager = this.dataManagers.get(accountId);
    if (!dataManager) {
      throw new Error(`账户 ${accountId} DataManager 未初始化`);
    }

    // 1. 启动实时监控 (如果启用)
    if (monitorConfig.enableRealtimeMonitor) {
      await this.startRealtimeMonitor(accountId, page, dataManager);
    }

    // 2. 启动爬虫调度器 (如果启用)
    if (monitorConfig.enableCrawl) {
      await this.startCrawlScheduler(accountId, page, monitorConfig);
    }

    this.logger.info(`✅ 监控启动完成: ${accountId}`);
  }

  /**
   * 启动实时监控
   */
  async startRealtimeMonitor(accountId, page, dataManager) {
    this.logger.info(`启动实时监控: ${accountId}`);

    const monitor = new DouyinRealtimeMonitor(accountId, page, dataManager);
    await monitor.start();

    this.realtimeMonitors.set(accountId, monitor);

    this.logger.info(`✅ 实时监控已启动: ${accountId}`);
  }

  /**
   * 启动爬虫调度器
   */
  async startCrawlScheduler(accountId, page, config) {
    this.logger.info(`启动爬虫调度器: ${accountId}`);

    const scheduler = new DouyinCrawlScheduler(accountId, page, config, this);
    scheduler.start();

    this.crawlSchedulers.set(accountId, scheduler);

    this.logger.info(`✅ 爬虫调度器已启动: ${accountId}`);
  }

  /**
   * 停止监控 (重写)
   */
  async stopMonitoring(accountId) {
    this.logger.info(`停止监控: ${accountId}`);

    // 停止实时监控
    const monitor = this.realtimeMonitors.get(accountId);
    if (monitor) {
      await monitor.stop();
      this.realtimeMonitors.delete(accountId);
    }

    // 停止爬虫调度器
    const scheduler = this.crawlSchedulers.get(accountId);
    if (scheduler) {
      scheduler.stop();
      this.crawlSchedulers.delete(accountId);
    }

    this.logger.info(`✅ 监控已停止: ${accountId}`);
  }

  /**
   * 解析监控配置
   */
  parseMonitorConfig(account) {
    // 默认配置
    const defaultConfig = {
      enableRealtimeMonitor: true,
      enableCrawl: true,
      crawlInterval: 5, // 分钟
      crawlMessages: true,
      crawlComments: true
    };

    // 从账户的 monitoring_config 字段读取
    let customConfig = {};
    if (account.monitoring_config) {
      try {
        customConfig = JSON.parse(account.monitoring_config);
      } catch (error) {
        this.logger.warn(`解析监控配置失败: ${accountId}`, error);
      }
    }

    // 合并配置
    return { ...defaultConfig, ...customConfig };
  }

  /**
   * 获取监控状态
   */
  getMonitoringStatus(accountId) {
    const monitor = this.realtimeMonitors.get(accountId);
    const scheduler = this.crawlSchedulers.get(accountId);

    return {
      realtime: monitor ? {
        enabled: true,
        status: monitor.checkStatus()
      } : { enabled: false },

      crawl: scheduler ? {
        enabled: true,
        status: scheduler.getStatus()
      } : { enabled: false }
    };
  }
}
```

**预计时间**: 3小时

---

### 阶段四: 配置和测试 (1天)

#### 任务 4.1: 数据库 Schema 更新
**文件**: `packages/master/src/database/schema.sql`

```sql
-- 添加 source 字段到 direct_messages 表
ALTER TABLE direct_messages ADD COLUMN source VARCHAR(20) DEFAULT 'crawl';
ALTER TABLE direct_messages ADD COLUMN captured_at BIGINT;
CREATE INDEX idx_direct_messages_source ON direct_messages(source);

-- 添加 source 字段到 comments 表
ALTER TABLE comments ADD COLUMN source VARCHAR(20) DEFAULT 'crawl';
ALTER TABLE comments ADD COLUMN captured_at BIGINT;
CREATE INDEX idx_comments_source ON comments(source);

-- 添加监控配置到 accounts 表
ALTER TABLE accounts ADD COLUMN monitoring_config TEXT;
```

**预计时间**: 1小时

---

#### 任务 4.2: 配置文件
**文件**: `config/default-config.json`

```json
{
  "monitoring": {
    "defaultConfig": {
      "enableRealtimeMonitor": true,
      "enableCrawl": true,
      "crawlInterval": 5,
      "crawlMessages": true,
      "crawlComments": true
    }
  }
}
```

**预计时间**: 1小时

---

#### 任务 4.3: 集成测试

**测试场景**:
1. 实时监控测试 - 发送私信/评论,验证立即捕获
2. 爬虫调度测试 - 验证定时执行
3. 数据去重测试 - 验证无重复数据
4. 配置更新测试 - 验证动态配置

**测试脚本**: `tests/integration/douyin-hybrid-monitoring.test.js`

**预计时间**: 4小时

---

## 📊 配置示例

### 全功能模式 (推荐)

```json
{
  "accountId": "douyin_123",
  "monitoring_config": {
    "enableRealtimeMonitor": true,
    "enableCrawl": true,
    "crawlInterval": 5,
    "crawlMessages": true,
    "crawlComments": true
  }
}
```

### 仅实时监控

```json
{
  "enableRealtimeMonitor": true,
  "enableCrawl": false
}
```

### 仅爬虫

```json
{
  "enableRealtimeMonitor": false,
  "enableCrawl": true,
  "crawlInterval": 10
}
```

---

## 🧪 测试计划

| 场景 | 测试方法 | 预期结果 |
|-----|---------|---------|
| 实时捕获私信 | 发送测试私信 | 立即收到,source=realtime |
| 实时捕获评论 | 发送测试评论 | 立即收到,source=realtime |
| 爬虫定时执行 | 等待5分钟 | 自动执行,source=crawl |
| 数据去重 | 同一消息 | 数据库只有1条 |
| 钩子重新注入 | 页面刷新 | 自动恢复监控 |
| 配置动态更新 | 修改配置 | 立即生效 |

---

## 📅 开发时间线

| 阶段 | 任务 | 工作日 | 完成日期 |
|-----|------|--------|---------|
| 阶段一 | 实时监控核心 | 1.5天 | D+1.5 |
| 阶段二 | 爬虫调度器 | 1天 | D+2.5 |
| 阶段三 | 集成到 Platform | 0.5天 | D+3 |
| 阶段四 | 配置和测试 | 1天 | D+4 |

**总计**: 4个工作日

---

## 🎯 里程碑

- [ ] **M1** (D+1.5): 实时监控核心完成,可独立运行
- [ ] **M2** (D+2.5): 爬虫调度器完成,可独立运行
- [ ] **M3** (D+3): 集成到 Platform,可协同工作
- [ ] **M4** (D+4): 测试完成,生产就绪

---

## ✅ 与现有架构的兼容性

✅ **不改动现有文件**:
- `crawl-direct-messages-v2.js` - 保持100%不变
- `crawl-comments.js` - 保持100%不变
- `crawl-contents.js` - 保持100%不变
- `douyin-data-manager.js` - 保持100%不变

✅ **只新增文件**:
- `realtime-monitor.js` - 新增
- `crawl-scheduler.js` - 新增
- `install-hooks.js` - 新增

✅ **只更新 platform.js**:
- 添加 `startRealtimeMonitor()` 方法
- 添加 `startCrawlScheduler()` 方法
- 更新 `startMonitoring()` 和 `stopMonitoring()` 方法

---

## 📋 验收标准

### 功能验收

- ✅ 实时监控能立即捕获新消息/评论
- ✅ 爬虫调度器按配置间隔执行
- ✅ 数据去重率 > 99%
- ✅ 配置可动态生效
- ✅ 页面刷新后自动恢复监控

### 性能验收

- ✅ 实时监控延迟 < 100ms
- ✅ 单账户 CPU < 5%
- ✅ 单账户内存 < 300MB
- ✅ 数据完整性 100%

---

## 🔗 相关文档

- [实时钩子监控方案-零延迟-2025-11-06.md](./实时钩子监控方案-零延迟-2025-11-06.md)
- [test-realtime-hook-monitor-v2.js](../tests/test-realtime-hook-monitor-v2.js)

---

**文档状态**: ✅ 已调整
**开发状态**: ⏳ 待开始
**优先级**: 🔥 高

