# 未读数跳动问题 - 根本原因和修复方案

**日期**: 2025-11-05
**问题**: 客户端 IM 界面显示"两组数字反复跳动"
**现象**: Tab 徽章显示 "私信 3 3" → 点击后变成 "私信 2 9"

---

## 问题现象

### 浏览器观察结果（Playwright MCP）

1. **初始状态**:
   - Tab "作品评论": "1 0" (两组数字)
   - Tab "私信": "3 3" (两组数字)
   - 左侧账户徽章: "4 3" (两组数字)

2. **点击账户后**:
   - Tab "作品评论": "1 0" → "9" (单个数字)
   - 账户徽章: "4 3" → "2"

3. **切换到私信 Tab 并点击会话后**:
   - Tab "私信": "3 3" → "2 9" (两组数字)
   - 账户徽章: "3 8"

### 为什么显示"两组数字"？

实际上不是"两组数字显示在 UI 上"，而是：
- **Tab 徽章数字（第一个数字）**: 来自服务端推送的 `topic.unreadCount`
- **列表项徽章数字（第二个数字）**: 来自客户端本地计算的 `unreadMessages.length`

当这两个数字不一致时，看起来像是"两组数字在跳"。

---

## 根本原因

### 数据流分析

```
服务端（Master）
  ↓ WebSocket 推送
  topic.unreadCount = 3 (准确值，基于完整数据)
  ↓
客户端（MonitorPage.tsx）
  ↓
1️⃣ Tab 徽章计算（Lines 73-97）
   commentUnhandledCount = Σ topic.unreadCount  ✅ 使用服务端值
   privateUnhandledCount = Σ topic.unreadCount  ✅ 使用服务端值
  ↓
2️⃣ 列表计算（Lines 147-188）
   privateMessagesByTopic
     ↓
   if (topicMessages.length > 0) {
     // ❌ 问题：客户端覆盖服务端的值
     unreadCount = unreadMessages.filter(m => !m.isRead).length
   } else {
     // ✅ 正确：使用服务端的值
     unreadCount = topic.unreadCount || 0
   }
```

### 核心问题代码

**文件**: `packages/crm-pc-im/src/pages/MonitorPage.tsx`

**Lines 170-178** (privateMessagesByTopic 计算):
```typescript
// ✅ 优先使用服务端推送的 unreadCount，如果消息已加载则使用客户端计算的
let unreadCount = topic.unreadCount || 0  // 默认使用服务端的值
if (topicMessages.length > 0) {
  // ❌ 错误逻辑：消息已加载，使用客户端计算的未读数
  const unreadMessages = privateMessages.filter(msg =>
    !msg.isRead && msg.fromId !== 'monitor_client'
  )
  unreadCount = unreadMessages.length  // ❌ 覆盖服务端的值！
}
```

### 为什么会不一致？

1. **服务端计算**（im-websocket-server.js, Line 463）:
   ```javascript
   const unreadMessages = conversationMessages.filter(m => !m.isRead);
   unreadCount: unreadMessages.length  // 基于完整的 DataStore 数据
   ```

2. **客户端计算**（MonitorPage.tsx, Lines 175-177）:
   ```typescript
   const unreadMessages = privateMessages.filter(msg =>
     !msg.isRead && msg.fromId !== 'monitor_client'
   )
   unreadCount = unreadMessages.length  // ❌ 基于部分加载的数据
   ```

**关键差异**:
- 服务端拥有**完整的消息数据**（从 DataStore 加载）
- 客户端只加载了**当前可见的部分消息**
- 客户端用不完整的数据计算，得出错误结果
- 然后**覆盖了服务端准确的值**

---

## 修复方案

### 方案 1: 完全信任服务端（推荐）

**原则**: 服务端拥有完整数据，是唯一可信的数据源。

**修改**: `packages/crm-pc-im/src/pages/MonitorPage.tsx` Lines 170-178

```typescript
// 修改前：
let unreadCount = topic.unreadCount || 0
if (topicMessages.length > 0) {
  const unreadMessages = privateMessages.filter(msg =>
    !msg.isRead && msg.fromId !== 'monitor_client'
  )
  unreadCount = unreadMessages.length  // ❌ 覆盖服务端
}

// 修改后：
// ✅ 完全信任服务端推送的 unreadCount
const unreadCount = topic.unreadCount || 0
```

**优点**:
- ✅ 唯一数据源，避免不一致
- ✅ 简单，删除冗余代码
- ✅ 性能更好（不需要客户端过滤计算）
- ✅ 服务端基于完整数据计算，更准确

**缺点**:
- 依赖服务端正确实现（目前已正确实现）

---

### 方案 2: 客户端加载完整消息后再计算（不推荐）

**思路**: 客户端加载完整消息后，再用本地计算覆盖服务端。

**问题**:
- ❌ 需要客户端加载所有消息（性能差）
- ❌ 仍然存在时间窗口不一致（加载过程中）
- ❌ 增加复杂度
- ❌ 违反单一数据源原则

---

## 实施步骤

### 1. 修改 MonitorPage.tsx

**文件**: `packages/crm-pc-im/src/pages/MonitorPage.tsx`

**修改 Lines 170-178**:

```typescript
// 构建私信列表(按作品分组,按最新消息时间倒序排列)
const privateMessagesByTopic = React.useMemo(() => {
  if (!selectedChannelId) return []

  const topicsWithPrivate: Array<{
    topic: Topic
    messageCount: number
    unreadCount: number
    lastMessage?: Message
  }> = []

  currentTopics.forEach(topic => {
    if (topic.isPrivate) {
      const topicMessages = messages[topic.id] || []
      const privateMessages = topicMessages.filter(msg =>
        msg.messageCategory === 'private'
      )

      const sortedMessages = [...privateMessages].sort((a, b) => b.timestamp - a.timestamp)

      // ✅ 修复：完全信任服务端推送的 unreadCount
      // 删除客户端计算逻辑，避免覆盖服务端的准确值
      const unreadCount = topic.unreadCount || 0

      topicsWithPrivate.push({
        topic,
        messageCount: privateMessages.length || topic.messageCount || 0,
        unreadCount: unreadCount,  // ✅ 使用服务端的值
        lastMessage: sortedMessages[0]
      })
    }
  })

  // 按最新消息时间降序排列（优先显示有消息的会话）
  return topicsWithPrivate.sort((a, b) => {
    const timeA = a.lastMessage?.timestamp || a.topic.lastMessageTime || 0
    const timeB = b.lastMessage?.timestamp || b.topic.lastMessageTime || 0
    return timeB - timeA
  })
}, [selectedChannelId, currentTopics, messages])
```

**删除的代码**（Lines 171-178）:
```typescript
// ❌ 删除这段逻辑
let unreadCount = topic.unreadCount || 0
if (topicMessages.length > 0) {
  const unreadMessages = privateMessages.filter(msg =>
    !msg.isRead && msg.fromId !== 'monitor_client'
  )
  unreadCount = unreadMessages.length  // 客户端计算覆盖服务端
}
```

---

## 验证清单

### 1. 重启服务

```bash
# 重启 Master 服务器
cd packages/master
npm start

# 重启 IM 客户端
cd packages/crm-pc-im
npm run dev
```

### 2. 测试场景

**场景 1: 初始加载**
- [ ] 打开 IM 客户端
- [ ] 观察 Tab 徽章数字是否单一
- [ ] 观察账户徽章数字是否单一

**场景 2: 点击账户**
- [ ] 点击左侧账户
- [ ] 观察右侧 Tab 徽章数字
- [ ] 确认数字不再"跳动"

**场景 3: 点击会话**
- [ ] 切换到"私信" Tab
- [ ] 点击私信会话
- [ ] 观察 Tab 徽章数字
- [ ] 确认数字正确减少（标记已读后）

**场景 4: 多次切换**
- [ ] 切换不同账户
- [ ] 观察数字是否稳定
- [ ] 确认没有"两组数字"现象

---

## 数据流验证

### 正确的数据流

```
服务端（im-websocket-server.js）
  ↓
计算 unreadCount = conversationMessages.filter(m => !m.isRead).length
  ↓
推送 topic.unreadCount = 3
  ↓
客户端（MonitorPage.tsx）
  ↓
Tab 徽章: Σ topic.unreadCount = 3
  ↓
列表项徽章: topic.unreadCount = 3
  ↓
✅ 两个徽章显示相同数字（数据源一致）
```

### 修复前的错误流

```
服务端推送 topic.unreadCount = 3
  ↓
客户端接收
  ↓
Tab 徽章: 3 ✅
  ↓
列表计算: unreadMessages.filter(!isRead).length = 9 ❌
  ↓
列表项徽章: 9 ❌
  ↓
❌ Tab 显示 3，列表显示 9（不一致！）
```

---

## 总结

### 问题根源
- 客户端用**不完整的本地数据**计算未读数
- **覆盖了服务端准确的值**
- 导致 Tab 徽章（服务端）和列表徽章（客户端）显示不同数字

### 解决方案
- **完全信任服务端推送的 `topic.unreadCount`**
- 删除客户端的冗余计算逻辑
- 保持唯一数据源原则

### 优点
- ✅ 数字稳定，不再跳动
- ✅ 数据一致（服务端 = 客户端）
- ✅ 代码简化
- ✅ 性能提升

---

**修改文件**: 1 个
**修改行数**: 约 10 行删除
**测试重点**: Tab 徽章和列表徽章数字一致性

