# 评论爬虫实现分析和讨论数据提取

**分析时间**: 2025-10-24 21:45
**分析文件**: `packages/worker/src/platforms/douyin/crawl-comments.js`
**分析目的**: 确认爬虫是否抓取讨论（回复）及其数据结构

---

## 一、当前实现方式

### 1.1 技术方案：API 拦截 ✅

**核心技术**:
```javascript
// Line 57-102: 全局 API 拦截器
page.on('response', async (response) => {
  const url = response.url();

  // ⭐ 拦截一级评论 API
  if (commentApiPattern.test(url)) {  // /comment.*list/i
    apiResponses.comments.push({...});
  }

  // ⭐ 拦截二级/三级回复 API（讨论）
  if (discussionApiPattern.test(url)) {  // /comment.*reply/i
    apiResponses.discussions.push({...});
  }
});
```

**API 拦截模式**:
- 评论 API: `/comment.*list/i` → 一级评论
- 讨论 API: `/comment.*reply/i` → 二级/三级回复

### 1.2 抓取策略

```
Step 1: 设置全局 API 拦截器
         ↓
Step 2: 导航到评论管理页面
         ↓
Step 3: 打开"选择作品"模态框
         ↓
Step 4: 获取所有视频列表
         ↓
Step 5: 批量点击有评论的视频 ← ⭐ 触发评论 API
         ↓
Step 6: 处理需要分页的视频 (has_more: true)
         ↓
Step 7: 解析拦截到的评论数据
         ↓
Step 8: 解析拦截到的讨论数据 ← ⭐ 讨论/回复
         ↓
Step 9: 返回结果
```

---

## 二、讨论（回复）数据结构

### 2.1 API 响应结构

**评论 API 响应** (一级评论):
```javascript
{
  comment_info_list: [
    {
      comment_id: "7428949857616888612",
      text: "真希望全国推广，让人生最后一程有尊严的谢幕",
      user_info: {
        user_id: "xxx",
        screen_name: "柯南1969",
        avatar_url: "https://..."
      },
      create_time: 1728234789,
      digg_count: 4,           // 点赞数
      reply_count: 2,          // ⭐ 回复数量（讨论数）
    }
  ],
  has_more: true,
  cursor: 20,
  total_count: 77
}
```

**讨论 API 响应** (二级/三级回复):
```javascript
{
  reply_list: [
    {
      reply_id: "7428955112345678901",  // 或 comment_id
      comment_id: "7428949857616888612", // 父评论 ID
      text: "回复柯南1969: 是的，我也这么觉得",
      user_info: {
        user_id: "yyy",
        screen_name: "硕果累累",
        avatar_url: "https://..."
      },
      create_time: 1728239456,
      digg_count: 0,
      reply_count: 1,    // 三级回复数量
      aweme_id: "7426789012345678901"  // 作品 ID
    }
  ],
  has_more: false,
  cursor: 0
}
```

### 2.2 爬虫提取的讨论字段

**当前提取的字段** (Line 453-467):
```javascript
{
  platform_discussion_id: reply.reply_id || reply.comment_id,  // ⭐ 讨论 ID
  parent_comment_id: parentCommentId,                          // ⭐ 父评论 ID
  work_id: reply.aweme_id || null,                             // 作品 ID
  content: reply.text || reply.content,                        // 讨论内容
  author_name: reply.user_info?.screen_name || '匿名',         // ⭐ 作者昵称
  author_id: reply.user_info?.user_id || '',                   // ⭐ 作者 ID
  author_avatar: reply.user_info?.avatar_url || '',            // ⭐ 作者头像
  create_time: createTimeSeconds,                              // 创建时间（秒）
  create_time_formatted: new Date(...).toLocaleString('zh-CN'), // 格式化时间
  like_count: parseInt(reply.digg_count) || 0,                 // 点赞数
  reply_count: parseInt(reply.reply_count) || 0,               // 三级回复数量
  detected_at: Math.floor(Date.now() / 1000),                  // 抓取时间
}
```

### 2.3 关键信息对照表

| 用户需求字段 | API 字段名 | 爬虫提取字段 | 说明 |
|-------------|-----------|------------|------|
| 讨论 ID | `reply_id` / `comment_id` | `platform_discussion_id` | ✅ 已提取 |
| 父评论 ID | URL 参数 `comment_id` | `parent_comment_id` | ✅ 已提取 |
| 作者 ID | `reply.user_info.user_id` | `author_id` | ✅ 已提取 |
| 作者昵称 | `reply.user_info.screen_name` | `author_name` | ✅ 已提取 |
| 作者头像 | `reply.user_info.avatar_url` | `author_avatar` | ✅ 已提取 |
| 讨论内容 | `reply.text` / `reply.content` | `content` | ✅ 已提取 |
| 创建时间 | `reply.create_time` | `create_time` | ✅ 已提取 |
| 点赞数 | `reply.digg_count` | `like_count` | ✅ 已提取 |
| 作品 ID | `reply.aweme_id` | `work_id` | ✅ 已提取 |

**结论**: ✅ **所有关键信息都已经在爬虫中提取了！**

---

## 三、讨论数据触发机制

### 3.1 触发条件

讨论 API 的触发需要满足以下条件之一：

1. **用户在评论管理页面点击"查看X条回复"按钮**
   - 手动触发 `/comment/reply` API
   - 返回该评论下的所有回复

2. **页面自动加载讨论数据**
   - 某些页面可能自动加载热门评论的回复
   - 取决于抖音前端实现

### 3.2 当前爬虫是否触发？

**检查代码**:

```javascript
// Line 159-184: 批量点击视频
for (let i = 0; i < maxToProcess; i++) {
  await page.evaluate((idx) => {
    const containers = document.querySelectorAll('.container-Lkxos9');
    if (idx < containers.length) {
      containers[idx].click();  // ⭐ 只点击视频，不点击"查看回复"按钮
    }
  }, video.index);

  await page.waitForTimeout(2000);
}
```

**分析**:
- ❌ 代码中**没有点击"查看X条回复"按钮**的逻辑
- ⚠️ 依赖抖音前端**自动加载**讨论数据
- ⚠️ 如果前端不自动加载，**讨论 API 不会被触发**

### 3.3 验证方法

让我们使用 MCP 来验证讨论 API 是否被触发：

```javascript
// 在点击视频后，检查是否有讨论 API 被拦截
logger.info(`Intercepted ${apiResponses.discussions.length} discussion API calls`);
```

**预期结果**:
- 如果 `apiResponses.discussions.length === 0` → ❌ 讨论 API 未触发
- 如果 `apiResponses.discussions.length > 0` → ✅ 讨论 API 已触发

---

## 四、问题诊断和解决方案

### 4.1 问题1: 讨论 API 未触发

**症状**:
```javascript
apiResponses.discussions.length === 0  // 没有拦截到任何讨论 API
```

**原因**:
1. 点击视频后，页面**不会自动加载讨论数据**
2. 需要手动点击"查看X条回复"按钮才能触发 API

**解决方案A: 自动点击"查看回复"按钮 (推荐 ⭐⭐⭐)**

```javascript
// 在点击视频后，查找并点击所有"查看回复"按钮
async function clickViewRepliesButtons(page) {
  logger.info('Looking for "查看回复" buttons...');

  // 查找所有"查看X条回复"按钮
  const replyButtons = await page.evaluate(() => {
    const buttons = [];
    const allElements = document.querySelectorAll('*');

    allElements.forEach(el => {
      const text = el.textContent || '';
      if (text.match(/查看\d+条回复/)) {
        buttons.push({
          text: text.trim(),
          xpath: getXPath(el)  // 自定义函数获取 XPath
        });
      }
    });

    return buttons;
  });

  logger.info(`Found ${replyButtons.length} "查看回复" buttons`);

  // 逐个点击按钮
  for (const button of replyButtons) {
    try {
      logger.debug(`Clicking: ${button.text}`);
      await page.evaluate((xpath) => {
        const el = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
        if (el) el.click();
      }, button.xpath);

      await page.waitForTimeout(500);  // 等待 API 响应
    } catch (error) {
      logger.warn(`Failed to click button: ${error.message}`);
    }
  }

  logger.info('Finished clicking all "查看回复" buttons');
}
```

**修改后的爬取流程**:
```javascript
// 在 Line 184 之后添加
for (let i = 0; i < maxToProcess; i++) {
  // 点击视频
  await page.evaluate((idx) => {
    containers[idx].click();
  }, video.index);

  await page.waitForTimeout(2000);

  // ⭐ 新增：点击所有"查看回复"按钮
  await clickViewRepliesButtons(page);
  await page.waitForTimeout(1000);

  // 重新打开模态框
  if (i < maxToProcess - 1) {
    await page.click('span:has-text("选择作品")');
    await page.waitForTimeout(1000);
  }
}
```

**解决方案B: 使用专门的讨论爬虫 (备选)**

创建独立的讨论爬虫：

```javascript
// packages/worker/src/platforms/douyin/crawl-discussions.js

async function crawlDiscussions(page, comments) {
  logger.info(`Crawling discussions for ${comments.length} comments`);

  const discussions = [];

  for (const comment of comments) {
    if (comment.reply_count > 0) {
      // 直接调用讨论 API
      const replies = await fetchDiscussionAPI(comment.platform_comment_id);
      discussions.push(...replies);
    }
  }

  return discussions;
}

async function fetchDiscussionAPI(commentId) {
  // 通过 evaluate 触发 API 请求
  // 或使用 axios 直接请求（需要 Cookie）
}
```

### 4.2 问题2: 数据库表结构

**检查数据库是否有讨论表**:

```sql
-- 查看是否有 discussions 或 comment_replies 表
SELECT name FROM sqlite_master WHERE type='table' AND name LIKE '%discuss%';
SELECT name FROM sqlite_master WHERE type='table' AND name LIKE '%reply%';
```

**如果没有讨论表，需要创建**:

```sql
CREATE TABLE IF NOT EXISTS discussions (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  platform_discussion_id TEXT NOT NULL,         -- 讨论 ID
  parent_comment_id TEXT NOT NULL,              -- 父评论 ID
  work_id TEXT,                                 -- 作品 ID
  account_id TEXT NOT NULL,                     -- 账户 ID
  platform TEXT DEFAULT 'douyin',               -- 平台

  -- 作者信息
  author_id TEXT NOT NULL,                      -- 作者 ID
  author_name TEXT NOT NULL,                    -- 作者昵称
  author_avatar TEXT,                           -- 作者头像 URL

  -- 讨论内容
  content TEXT NOT NULL,                        -- 讨论文本

  -- 统计信息
  like_count INTEGER DEFAULT 0,                 -- 点赞数
  reply_count INTEGER DEFAULT 0,                -- 三级回复数量

  -- 时间信息
  create_time INTEGER NOT NULL,                 -- 创建时间（秒级时间戳）
  detected_at INTEGER NOT NULL,                 -- 抓取时间（秒级时间戳）

  -- 约束
  UNIQUE (platform, account_id, platform_discussion_id),
  FOREIGN KEY (account_id) REFERENCES accounts(id) ON DELETE CASCADE,
  FOREIGN KEY (parent_comment_id) REFERENCES comments(platform_comment_id) ON DELETE CASCADE
);

-- 索引
CREATE INDEX idx_discussions_parent ON discussions(parent_comment_id);
CREATE INDEX idx_discussions_account ON discussions(account_id);
CREATE INDEX idx_discussions_work ON discussions(work_id);
CREATE INDEX idx_discussions_created ON discussions(create_time DESC);
```

### 4.3 问题3: 数据保存逻辑

**检查是否保存讨论数据**:

查找调用 `crawlComments()` 的地方：
```bash
grep -rn "crawlComments" packages/worker/src/
```

**可能的文件**:
- `packages/worker/src/platforms/douyin/platform.js`
- `packages/worker/src/handlers/task-runner.js`

**检查返回数据是否包含 discussions**:
```javascript
const result = await crawlComments(page, account, options);

// result 应该包含:
// {
//   comments: [...],
//   discussions: [...],  // ⭐ 检查是否有这个字段
//   works: [...],
//   stats: {...}
// }
```

**保存讨论数据到数据库**:
```javascript
// 保存评论
for (const comment of result.comments) {
  await commentsDAO.insertComment(comment);
}

// ⭐ 保存讨论
for (const discussion of result.discussions) {
  await discussionsDAO.insertDiscussion(discussion);
}
```

---

## 五、测试和验证

### 5.1 测试脚本1: 验证讨论 API 拦截

```javascript
// tests/测试讨论API拦截.js

const { chromium } = require('playwright');
const path = require('path');

async function testDiscussionAPIInterception() {
  console.log('📋 测试讨论 API 拦截\n');

  const userDataDir = path.join(__dirname, '../packages/worker/data/browser/worker-1/browser_xxx');

  const context = await chromium.launchPersistentContext(userDataDir, {
    headless: false,
    viewport: { width: 1280, height: 720 },
  });

  const page = await context.newPage();

  // 设置 API 拦截器
  const apiCalls = {
    comments: [],
    discussions: []
  };

  page.on('response', async (response) => {
    const url = response.url();

    if (/comment.*list/i.test(url)) {
      apiCalls.comments.push({ url, time: Date.now() });
      console.log(`✅ 拦截到评论 API: ${url.substring(0, 100)}...`);
    }

    if (/comment.*reply/i.test(url)) {
      apiCalls.discussions.push({ url, time: Date.now() });
      console.log(`🔥 拦截到讨论 API: ${url.substring(0, 100)}...`);

      try {
        const json = await response.json();
        console.log(`   回复数量: ${json.reply_list?.length || 0}`);
      } catch (e) {}
    }
  });

  // 导航到评论管理页面
  console.log('\n📍 导航到评论管理页面...');
  await page.goto('https://creator.douyin.com/creator-micro/interactive/comment', {
    waitUntil: 'networkidle',
    timeout: 30000
  });

  await page.waitForTimeout(3000);

  // 打开选择作品
  console.log('\n📍 打开选择作品模态框...');
  await page.click('span:has-text("选择作品")');
  await page.waitForTimeout(2000);

  // 点击第一个视频
  console.log('\n📍 点击第一个视频...');
  await page.evaluate(() => {
    const containers = document.querySelectorAll('.container-Lkxos9');
    if (containers.length > 0) {
      containers[0].click();
    }
  });

  await page.waitForTimeout(3000);

  // 查找并点击"查看回复"按钮
  console.log('\n📍 查找"查看回复"按钮...');
  const replyButtonCount = await page.evaluate(() => {
    const buttons = Array.from(document.querySelectorAll('*')).filter(el =>
      el.textContent && el.textContent.match(/查看\d+条回复/)
    );
    return buttons.length;
  });

  console.log(`✅ 找到 ${replyButtonCount} 个"查看回复"按钮\n`);

  if (replyButtonCount > 0) {
    console.log('📍 点击第一个"查看回复"按钮...');
    await page.evaluate(() => {
      const buttons = Array.from(document.querySelectorAll('*')).filter(el =>
        el.textContent && el.textContent.match(/查看\d+条回复/)
      );
      if (buttons.length > 0) {
        buttons[0].click();
      }
    });

    await page.waitForTimeout(2000);
  }

  // 输出统计
  console.log('\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
  console.log('📊 API 拦截统计:');
  console.log(`   评论 API: ${apiCalls.comments.length} 次`);
  console.log(`   讨论 API: ${apiCalls.discussions.length} 次`);
  console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n');

  if (apiCalls.discussions.length === 0) {
    console.log('⚠️  警告: 没有拦截到讨论 API！');
    console.log('   可能原因:');
    console.log('   1. 页面没有"查看回复"按钮');
    console.log('   2. "查看回复"按钮没有被点击');
    console.log('   3. API 模式不匹配\n');
  } else {
    console.log('✅ 成功拦截到讨论 API！\n');
  }

  await page.waitForTimeout(5000);
  await context.close();
}

testDiscussionAPIInterception().catch(console.error);
```

### 5.2 测试脚本2: 查看数据库讨论数据

```javascript
// tests/查看讨论数据.js

const Database = require('better-sqlite3');
const path = require('path');

const dbPath = path.join(__dirname, '../packages/master/data/master.db');
const db = new Database(dbPath);

console.log('📋 查看讨论数据统计\n');

// 1. 检查表是否存在
const tables = db.prepare(`
  SELECT name FROM sqlite_master
  WHERE type='table' AND name LIKE '%discuss%' OR name LIKE '%reply%'
`).all();

console.log('📊 相关表:');
if (tables.length === 0) {
  console.log('   ❌ 没有找到讨论/回复相关的表\n');
} else {
  tables.forEach(t => console.log(`   ✅ ${t.name}`));
  console.log('');
}

// 2. 如果有 discussions 表，查看统计
if (tables.some(t => t.name === 'discussions')) {
  const stats = db.prepare(`
    SELECT
      COUNT(*) as total,
      COUNT(DISTINCT parent_comment_id) as unique_parents,
      COUNT(DISTINCT author_id) as unique_authors
    FROM discussions
  `).get();

  console.log('📊 讨论统计:');
  console.log(`   总讨论数: ${stats.total}`);
  console.log(`   涉及评论数: ${stats.unique_parents}`);
  console.log(`   参与用户数: ${stats.unique_authors}\n`);

  // 3. 查看最近的讨论
  if (stats.total > 0) {
    const recentDiscussions = db.prepare(`
      SELECT
        author_name,
        content,
        like_count,
        datetime(create_time, 'unixepoch', 'localtime') as created_at
      FROM discussions
      ORDER BY create_time DESC
      LIMIT 5
    `).all();

    console.log('📝 最近 5 条讨论:');
    recentDiscussions.forEach((d, i) => {
      console.log(`\n  ${i + 1}. ${d.author_name} (${d.created_at})`);
      console.log(`     "${d.content}"`);
      console.log(`     点赞: ${d.like_count}`);
    });
  }
} else {
  console.log('⚠️  数据库中没有 discussions 表');
  console.log('   需要创建表或修改 schema\n');
}

db.close();
```

---

## 六、完整实现方案

### 6.1 修改评论爬虫 - 添加点击"查看回复"逻辑

**文件**: `packages/worker/src/platforms/douyin/crawl-comments.js`

**修改位置**: Line 184 之后

```javascript
// 在点击视频后，添加点击"查看回复"按钮的逻辑
for (let i = 0; i < maxToProcess; i++) {
  const video = videosToClick[i];
  logger.info(`[${i + 1}/${maxToProcess}] Clicking: ${video.title.substring(0, 50)}...`);

  try {
    // 1. 点击视频
    await page.evaluate((idx) => {
      const containers = document.querySelectorAll('.container-Lkxos9');
      if (idx < containers.length) {
        containers[idx].click();
      }
    }, video.index);

    // 2. 等待评论加载
    await page.waitForTimeout(2000);

    // 3. ⭐ 新增：点击所有"查看回复"按钮
    logger.debug('  Looking for "查看回复" buttons...');
    const replyButtonsClicked = await page.evaluate(() => {
      let clicked = 0;
      const allElements = Array.from(document.querySelectorAll('*'));

      allElements.forEach(el => {
        const text = el.textContent || '';
        if (text.match(/查看\d+条回复/) && el.offsetParent !== null) {  // 可见元素
          try {
            el.click();
            clicked++;
          } catch (e) {
            // 忽略点击失败
          }
        }
      });

      return clicked;
    });

    if (replyButtonsClicked > 0) {
      logger.info(`  ✅ Clicked ${replyButtonsClicked} "查看回复" buttons`);
      await page.waitForTimeout(1500);  // 等待讨论 API 响应
    } else {
      logger.debug('  No "查看回复" buttons found or all hidden');
    }

    // 4. 重新打开模态框以便点击下一个
    if (i < maxToProcess - 1) {
      await page.click('span:has-text("选择作品")', { timeout: 5000 });
      await page.waitForTimeout(1000);
    }
  } catch (error) {
    logger.error(`Failed to click video ${i}: ${error.message}`);
  }
}
```

### 6.2 创建讨论数据访问对象 (DAO)

**文件**: `packages/master/src/database/discussions-dao.js` (已存在，需检查)

**需要实现的方法**:
```javascript
class DiscussionsDAO {
  insertDiscussion(discussion) { ... }
  getDiscussionsByCommentId(commentId) { ... }
  getRecentDiscussions(limit) { ... }
}
```

### 6.3 保存讨论数据

**文件**: `packages/worker/src/platforms/douyin/platform.js` 或调用爬虫的地方

```javascript
const result = await crawlComments(page, account, options);

logger.info(`Crawled ${result.comments.length} comments, ${result.discussions.length} discussions`);

// 保存评论
for (const comment of result.comments) {
  await this.saveComment(comment);
}

// ⭐ 保存讨论
for (const discussion of result.discussions) {
  await this.saveDiscussion(discussion);
}
```

---

## 七、总结

### 7.1 当前状态

| 功能 | 状态 | 说明 |
|------|------|------|
| API 拦截器设置 | ✅ 完成 | Line 57-102 |
| 评论 API 拦截 | ✅ 完成 | `/comment.*list/` |
| 讨论 API 拦截 | ✅ 完成 | `/comment.*reply/` |
| 讨论数据提取 | ✅ 完成 | Line 433-483 |
| 讨论字段提取 | ✅ 完整 | 所有关键字段都已提取 |
| 自动点击"查看回复" | ❌ 缺失 | **需要添加** |
| 数据库表结构 | ⚠️ 待确认 | 需检查是否有 discussions 表 |
| 数据保存逻辑 | ⚠️ 待确认 | 需检查是否保存 discussions |

### 7.2 关键发现

1. ✅ **爬虫已实现讨论抓取功能**
   - 使用 API 拦截方式
   - 提取了所有关键字段（ID、昵称、头像等）

2. ⚠️ **可能存在的问题**
   - 没有自动点击"查看回复"按钮
   - 依赖前端自动加载讨论数据
   - 如果前端不自动加载，讨论 API 不会触发

3. 🔍 **需要验证**
   - 数据库是否有 discussions 表
   - 爬虫返回的 discussions 是否被保存
   - 实际运行时是否拦截到讨论 API

### 7.3 立即行动项

1. **运行测试脚本1** - 验证讨论 API 是否被拦截
   ```bash
   node tests/测试讨论API拦截.js
   ```

2. **运行测试脚本2** - 查看数据库讨论数据
   ```bash
   node tests/查看讨论数据.js
   ```

3. **如果讨论 API 未触发** - 实施方案 6.1 (添加点击"查看回复"逻辑)

4. **如果数据库无讨论表** - 创建 discussions 表

5. **确保数据保存** - 检查并修改数据保存逻辑

---

**报告生成时间**: 2025-10-24 21:50
**状态**: ✅ 分析完成
**结论**: 爬虫已实现讨论抓取，但可能需要添加自动点击"查看回复"按钮的逻辑
**下一步**: 运行测试脚本验证 → 根据结果实施改进方案
