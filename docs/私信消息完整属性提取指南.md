# 私信消息完整属性提取指南

**目的**: 检查私信消息中是否包含头像、昵称等用户信息

**日期**: 2025-10-24

---

## 问题背景

当前私信爬虫可以提取：
- ✅ `serverId` (消息ID)
- ✅ `conversationId` (会话ID)
- ✅ `content.text` (消息文本)
- ✅ `isFromMe` (消息方向)
- ✅ `type` (消息类型)
- ✅ `createdAt` (创建时间)

**待确认**: React Fiber 中是否还包含头像、昵称等用户信息？

---

## 手动测试步骤（推荐）

### 步骤 1: 打开抖音私信页面

1. 打开 Chrome 浏览器（使用已登录的账户）
2. 手动导航到抖音创作者中心私信页面
3. 点击任意一个会话，显示消息列表

### 步骤 2: 打开开发者工具

按 `F12` 打开开发者工具，切换到 `Console` 面板

### 步骤 3: 运行完整属性检查代码

复制下面的代码，粘贴到控制台并运行：

```javascript
// ==========================================
// 测试代码：提取私信消息的所有属性
// ==========================================

console.log('🔍 开始分析私信消息的所有属性\n');

// 1. 查找所有可能的消息元素
const allElements = document.querySelectorAll('[class*="message"], [class*="item"], [role*="article"]');
console.log(`✅ 找到 ${allElements.length} 个潜在消息元素\n`);

// 2. 提取并分析前 5 条消息
let analyzed = 0;
const messages = [];

allElements.forEach((element, index) => {
  // 查找 React Fiber 键
  const fiberKey = Object.keys(element).find(key => key.startsWith('__reactFiber') || key.startsWith('__reactInternalInstance'));
  if (!fiberKey) return;

  let current = element[fiberKey];
  let depth = 0;
  let found = false;

  // 向上遍历 React Fiber 树
  while (current && depth < 20 && !found) {
    if (current.memoizedProps) {
      const props = current.memoizedProps;

      // 检查是否有消息相关数据
      if (props.conversationId || props.serverId || props.content || props.message) {
        analyzed++;

        // 只详细分析前 5 条消息
        if (analyzed <= 5) {
          console.log(`\n${'='.repeat(60)}`);
          console.log(`📝 消息 ${analyzed} (元素索引: ${index}, Fiber 深度: ${depth})`);
          console.log(`${'='.repeat(60)}\n`);

          // 核心消息属性
          console.log('【核心属性】');
          console.log(`  serverId: ${props.serverId}`);
          console.log(`  conversationId: ${props.conversationId}`);
          console.log(`  messageId: ${props.messageId}`);
          console.log(`  isFromMe: ${props.isFromMe}`);
          console.log(`  type: ${props.type}`);

          // 消息内容
          console.log('\n【消息内容】');
          console.log(`  content:`, props.content);
          console.log(`  text: ${props.content?.text?.substring(0, 50)}...`);

          // 用户信息
          console.log('\n【用户信息】');
          console.log(`  user:`, props.user);
          console.log(`  sender:`, props.sender);
          console.log(`  senderInfo:`, props.senderInfo);
          console.log(`  fromUser:`, props.fromUser);
          console.log(`  toUser:`, props.toUser);

          // 头像
          console.log('\n【头像】');
          console.log(`  avatar:`, props.avatar);
          console.log(`  avatarUrl:`, props.avatarUrl);
          console.log(`  senderAvatar:`, props.senderAvatar);

          // 昵称
          console.log('\n【昵称】');
          console.log(`  nickname:`, props.nickname);
          console.log(`  senderNickname:`, props.senderNickname);
          console.log(`  userName:`, props.userName);
          console.log(`  name:`, props.name);

          // 所有可用的属性键
          console.log('\n【所有属性键】');
          const allKeys = Object.keys(props);
          console.log(`  总计 ${allKeys.length} 个属性:`);
          console.log(`  ${allKeys.join(', ')}`);

          // 详细打印每个属性的类型
          console.log('\n【属性详情】');
          allKeys.forEach(key => {
            const value = props[key];
            const type = Array.isArray(value) ? 'array' : typeof value;
            const preview = typeof value === 'object' && value !== null
              ? `{${Object.keys(value).slice(0, 3).join(', ')}${Object.keys(value).length > 3 ? '...' : ''}}`
              : String(value).substring(0, 30);
            console.log(`  ${key} (${type}): ${preview}`);
          });
        }

        messages.push({
          serverId: props.serverId,
          text: props.content?.text,
          hasUser: !!(props.user || props.sender || props.senderInfo || props.fromUser),
          hasAvatar: !!(props.avatar || props.avatarUrl || props.senderAvatar),
          hasNickname: !!(props.nickname || props.senderNickname || props.userName || props.name),
          allPropsKeys: Object.keys(props)
        });

        found = true;
      }
    }

    current = current.return;
    depth++;
  }
});

// 3. 统计分析结果
console.log(`\n\n${'='.repeat(60)}`);
console.log('📊 统计结果');
console.log(`${'='.repeat(60)}\n`);

console.log(`总元素数: ${allElements.length}`);
console.log(`有效消息数: ${analyzed}`);

const hasUserInfo = messages.filter(m => m.hasUser).length;
const hasAvatar = messages.filter(m => m.hasAvatar).length;
const hasNickname = messages.filter(m => m.hasNickname).length;

console.log(`\n包含用户信息的消息: ${hasUserInfo}/${messages.length} ${hasUserInfo > 0 ? '✅' : '❌'}`);
console.log(`包含头像的消息: ${hasAvatar}/${messages.length} ${hasAvatar > 0 ? '✅' : '❌'}`);
console.log(`包含昵称的消息: ${hasNickname}/${messages.length} ${hasNickname > 0 ? '✅' : '❌'}`);

// 4. 输出完整数据供复制
console.log(`\n\n${'='.repeat(60)}`);
console.log('📋 完整数据（可复制）');
console.log(`${'='.repeat(60)}\n`);

console.log('messages =', JSON.stringify(messages, null, 2));

console.log(`\n✅ 测试完成！`);
```

---

## 预期结果分析

### 场景 1: 包含完整用户信息 ✅

```
包含用户信息的消息: 5/5 ✅
包含头像的消息: 5/5 ✅
包含昵称的消息: 5/5 ✅
```

**结论**: React Fiber 包含完整用户信息，可以直接提取。

**下一步**: 修改 `crawl-direct-messages-v2.js` 中的 `extractCompleteMessageObjects` 函数，添加用户信息提取逻辑。

### 场景 2: 部分包含用户信息 ⚠️

```
包含用户信息的消息: 3/5 ⚠️
包含头像的消息: 0/5 ❌
包含昵称的消息: 3/5 ⚠️
```

**结论**: 用户信息不完整或不稳定。

**下一步**: 需要组合多种数据源（React Fiber + API + 会话列表）来获取完整用户信息。

### 场景 3: 不包含用户信息 ❌

```
包含用户信息的消息: 0/5 ❌
包含头像的消息: 0/5 ❌
包含昵称的消息: 0/5 ❌
```

**结论**: React Fiber 中没有用户信息。

**下一步**: 需要从以下位置获取用户信息：
1. 会话列表（conversations）- 包含用户头像和昵称
2. API 拦截（如果可用）
3. DOM 解析（会话详情页面）

---

## 可能的用户信息来源

### 来源 1: 会话列表元素

会话列表中通常包含：
- 用户头像 URL
- 用户昵称
- 用户ID

**提取方式**: 在点击会话前，先保存会话列表的用户信息映射。

### 来源 2: 页面 DOM 元素

消息详情页面可能包含：
- 头像 `<img>` 元素
- 昵称 `<span>` 或 `<div>` 元素

**提取方式**: 使用选择器查找头像和昵称元素。

### 来源 3: API 拦截

如果抖音通过 WebSocket 或 HTTP API 传输用户信息，可以拦截获取。

**提取方式**:
- WebSocket 消息监听
- HTTP 请求拦截（目前已失效）

---

## conversationId 解析（已知方案）

即使消息中没有直接的用户信息，我们仍可以从 `conversationId` 解析用户ID：

```javascript
// conversationId 格式: "0:1:106228603660:3930122882131587"
//                       前缀:类型:用户ID:会话ID

function parseConversationId(conversationId) {
  const parts = conversationId.split(':');
  return {
    prefix: parts[0],           // "0"
    type: parts[1],             // "1"
    userId: parts[2],           // "106228603660" ← 用户ID
    realConvId: parts[3]        // "3930122882131587"
  };
}
```

**优势**: 可靠、稳定
**劣势**: 只有用户ID，没有昵称和头像

---

## 下一步行动方案

### 方案 A: React Fiber 包含完整信息（最理想）

1. 修改 `extractCompleteMessageObjects` 函数
2. 提取 `props.user` 或 `props.sender` 中的头像和昵称
3. 测试验证

### 方案 B: React Fiber 只有部分信息

1. 从 React Fiber 提取可用的用户信息
2. 从会话列表补充缺失的信息
3. 建立用户ID到用户信息的映射表

### 方案 C: React Fiber 没有用户信息

1. 实现会话列表用户信息提取
2. 在爬取消息前，先提取会话的用户信息
3. 通过 conversationId 关联消息和用户
4. 可选：研究 WebSocket 拦截方案

---

## 测试脚本

上面的浏览器控制台代码可以：

1. ✅ 检查是否有用户信息
2. ✅ 检查是否有头像
3. ✅ 检查是否有昵称
4. ✅ 列出所有可用的属性
5. ✅ 输出完整数据供分析

---

## 请运行测试并反馈结果

请按照上面的步骤，在抖音私信页面的浏览器控制台运行测试代码，并告诉我：

1. 包含用户信息的消息数量
2. 包含头像的消息数量
3. 包含昵称的消息数量
4. 【所有属性键】中列出的所有键名

根据结果，我会调整爬虫代码以提取完整的用户信息。

---

**记录者**: Claude Code
**创建时间**: 2025-10-24
**状态**: ⏸️ 等待测试结果
