# 时间戳问题完整修复报告

**日期**: 2025-11-03
**问题**: IM 客户端显示会话时间为 "01/21" (1970年1月21日)
**影响**: 所有私信会话的时间显示错误

---

## 问题概述

用户反馈 IM 客户端中显示的会话时间全部错误，显示为 "01/21"，实际应该显示 2025年11月3日。

### 核心原则

用户提出的时间戳处理标准：

> **"无论抓取什么格式，入库必须统一，出库后在进行 im 端的转换，以免混乱"**

- **入库统一**: Worker 抓取时标准化为毫秒级时间戳
- **存储一致**: 数据库始终存储毫秒级时间戳 (INTEGER, 13位)
- **传输不变**: DataStore → CacheDAO → Database 保持毫秒级
- **出库转换**: IM 客户端根据需要转换显示格式

---

## Phase 1: Worker 时间戳标准化

**Commit**: f7ac7be

### 问题发现

数据库中 44 条消息的 `created_at` 都是秒级时间戳 (10位)，导致日期显示为 1970年。

```sql
SELECT created_at, datetime(created_at, 'unixepoch') FROM cache_messages LIMIT 1;
-- created_at: 1762130997 (秒级)
-- 日期: 1970-01-21
```

### 根本原因

[crawl-direct-messages-v2.js:1044]
```javascript
created_at: Math.floor(new Date(props.timestamp || props.createdAt).getTime() / 1000)
```

如果 `props.timestamp` 已经是毫秒级 (1762130997000)，除以 1000 会变成秒级。

### 修复方案

创建 `normalizeTimestamp()` 函数统一处理各种时间戳格式：

```javascript
/**
 * 将各种格式的时间戳标准化为毫秒级时间戳
 *
 * 支持的输入格式:
 * - 毫秒级时间戳 (13位数字): 1730612345678
 * - 秒级时间戳 (10位数字): 1730612345 → 转换为 1730612345000
 * - ISO 8601 字符串: "2025-11-03T14:30:00.000Z"
 * - Date 对象
 */
function normalizeTimestamp(timestamp) {
  if (!timestamp) return Date.now();

  if (timestamp instanceof Date) {
    return timestamp.getTime();
  }

  if (typeof timestamp === 'number') {
    // 秒级时间戳 (10位) → 毫秒级
    if (timestamp < 10000000000) {
      return timestamp * 1000;
    }
    return Math.floor(timestamp);  // 已经是毫秒级
  }

  if (typeof timestamp === 'string') {
    const num = Number(timestamp);
    if (!isNaN(num)) {
      return normalizeTimestamp(num);
    }

    const date = new Date(timestamp);
    if (!isNaN(date.getTime())) {
      return date.getTime();
    }
  }

  console.warn(`[normalizeTimestamp] Unable to parse: ${timestamp}`);
  return Date.now();
}
```

### 修复位置

[crawl-direct-messages-v2.js]
1. 第 1100 行: `created_at: normalizeTimestamp(props.timestamp || props.createdAt)`
2. 第 481 行: `created_at: Date.now()`
3. 第 646 行: `created_at: Date.now()`
4. 第 1286 行: `created_at: msg.created_at || Date.now()`

---

## Phase 2: CacheDAO 持久化层修复

**Commit**: 3c44a1a

### 问题发现

用户关键洞察：

> **"入库可能是正确的，但是我们始终调用的是内存数据啊，内存数据是有问题的，在推送或者抓取到全局对象内，他们的时间就应该是正确的才对"**

尽管 Worker 已经修复，但数据库中的消息时间戳仍然是秒级！

### 根本原因

[cache-dao.js:390-398]
```javascript
// 统一时间戳格式：确保 created_at 是秒级时间戳（整数）
let createdAtTimestamp = message.createdAt || now;
if (typeof createdAtTimestamp === 'string') {
  // ISO 8601 字符串 → 秒级时间戳
  createdAtTimestamp = Math.floor(new Date(createdAtTimestamp).getTime() / 1000);
} else if (createdAtTimestamp > 100000000000) {
  // 毫秒级时间戳 → 秒级时间戳
  createdAtTimestamp = Math.floor(createdAtTimestamp / 1000);  // ❌ BUG!
}
```

**矛盾**:
- 注释说: "确保 created_at 是秒级时间戳"
- schema.sql 定义: `created_at INTEGER NOT NULL -- 消息创建时间 (业务时间, 毫秒)`

CacheDAO 错误地将 Worker 发送的毫秒级时间戳转换为秒级！

### 修复方案

[cache-dao.js:388-405]
```javascript
const transaction = this.db.transaction((messages) => {
  for (const message of messages) {
    // 保持毫秒级时间戳 (13位数字)
    // Worker 已经通过 normalizeTimestamp() 统一为毫秒级
    const createdAtTimestamp = message.createdAt || now;

    this.preparedStmts.upsertMessage.run(
      message.id,
      accountId,
      message.conversationId || '',
      JSON.stringify(message),
      createdAtTimestamp,  // ✅ 直接使用毫秒级
      now,
      now
    );
    count++;
  }
});
```

### 数据清理

由于数据已被污染，需要清理：

```bash
# 1. 清空所有 cache 表
node tests/clean-all-cache-tables.js

# 结果:
✅ cache_comments: 删除 9 条记录
✅ cache_messages: 删除 44 条记录
✅ cache_conversations: 删除 37 条记录
✅ cache_contents: 删除 20 条记录
```

---

## Phase 3: IM WebSocket 字段映射修复

**Commit**: 67dd31a

### 问题发现

即使 Phase 1 和 Phase 2 都修复了，IM 客户端仍然显示 "01/21"！

### 诊断过程

创建诊断脚本 `tests/check-conversation-timestamp-fields.js`:

```javascript
// 查询数据库
const conversations = db.prepare(`
  SELECT * FROM cache_conversations
  WHERE account_id = ?
  ORDER BY last_message_time DESC
  LIMIT 5
`).all(accountId);

console.log('数据库字段:');
console.log(`  last_message_time: ${first.last_message_time}`);
console.log(`    → 转换为日期: ${new Date(first.last_message_time).toLocaleString('zh-CN')}`);
console.log(`  updated_at: ${first.updated_at}`);
console.log(`    → 转换为日期: ${new Date(first.updated_at).toLocaleString('zh-CN')}`);
```

**输出结果**:
```
数据库字段:
  last_message_time: 1762152909651
    → 转换为日期: 2025/11/3 14:55:09 ✅ 正确!
  updated_at: 1762153009326
    → 转换为日期: 2025/11/3 14:56:49 ✅ 正确!
  created_at: undefined
    → 转换为日期: Invalid Date

JSON data 字段:
  lastMessageTime: 1762152909651
    → 转换为日期: 2025/11/3 14:55:09 ✅ 正确!
```

数据库和内存数据都是正确的毫秒级时间戳！

### 根本原因

[im-websocket-server.js:387]
```javascript
const topic = {
  id: conversation.conversationId,
  channelId: channelId,
  title: conversation.userName || '未知用户',
  description: `私信会话`,
  createdTime: conversation.createdAt || Date.now(),
  lastMessageTime: conversation.updatedAt || Date.now(),  // ❌ 错误字段!
  messageCount: conversationMessages.length,
  unreadCount: conversation.unreadCount || 0,
  isPinned: false,
  isPrivate: true
};
```

**问题**: 使用了 `conversation.updatedAt` 而不是 `conversation.lastMessageTime`！

### DataStore 对象结构

根据 [data-store.js:_loadConversationsFromDB()]:

```javascript
const conversationObj = {
  accountId: row.account_id,
  conversationId: row.user_id,
  userName: userData.userName,
  avatarUrl: userData.avatarUrl,
  // ... 其他字段
  lastMessageTime: row.last_message_time,  // ✅ 正确字段!
  unreadCount: userData.unreadCount || 0,
  createdAt: row.created_at,
  updatedAt: row.updated_at
};
```

### 修复方案

[im-websocket-server.js:387]
```javascript
const topic = {
  id: conversation.conversationId,
  channelId: channelId,
  title: conversation.userName || '未知用户',
  description: `私信会话`,
  createdTime: conversation.createdAt || Date.now(),
  lastMessageTime: conversation.lastMessageTime || Date.now(),  // ✅ 修复!
  messageCount: conversationMessages.length,
  unreadCount: conversation.unreadCount || 0,
  isPinned: false,
  isPrivate: true
};
```

---

## 完整数据流验证

```
┌─────────────────────────────────────────────────────────────┐
│                   时间戳数据流 (毫秒级)                      │
└─────────────────────────────────────────────────────────────┘

1. 抖音平台
   └─> timestamp: 1762152909651 (毫秒级)

2. Worker (Phase 1 修复)
   └─> normalizeTimestamp(timestamp)
   └─> created_at: 1762152909651 ✅

3. DataStore (内存)
   └─> message.createdAt: 1762152909651 ✅
   └─> conversation.lastMessageTime: 1762152909651 ✅

4. CacheDAO (Phase 2 修复)
   └─> 保持毫秒级，不再除以 1000
   └─> INSERT ... VALUES (1762152909651) ✅

5. Database (SQLite)
   └─> cache_messages.created_at: 1762152909651 ✅
   └─> cache_conversations.last_message_time: 1762152909651 ✅

6. IM WebSocket (Phase 3 修复)
   └─> topic.lastMessageTime: conversation.lastMessageTime
   └─> = 1762152909651 ✅

7. IM Client
   └─> new Date(1762152909651).toLocaleString('zh-CN')
   └─> "2025/11/3 14:55:09" ✅
```

---

## 关键文件修改

### 1. Worker 层
- **文件**: `packages/worker/src/platforms/douyin/crawl-direct-messages-v2.js`
- **修改**: 新增 `normalizeTimestamp()` 函数 (35-89 行)
- **修复**: 4 处时间戳赋值位置

### 2. 持久化层
- **文件**: `packages/master/src/persistence/cache-dao.js`
- **修改**: 移除毫秒级→秒级的错误转换 (388-405 行)
- **关键**: 保持 Worker 传递的毫秒级时间戳不变

### 3. IM WebSocket 层
- **文件**: `packages/master/src/communication/im-websocket-server.js`
- **修改**: 第 387 行字段名修正
- **修复**: `conversation.updatedAt` → `conversation.lastMessageTime`

### 4. 测试脚本
- `tests/fix-message-timestamps-to-milliseconds.js` - 修复消息表时间戳
- `tests/fix-invalid-conversation-timestamps.js` - 修复会话表超大时间戳
- `tests/final-timestamp-verification.js` - 全面验证时间戳格式
- `tests/check-conversation-timestamp-fields.js` - 诊断 conversation 对象结构

---

## 时间戳标准

### 统一标准

| 位置 | 字段 | 类型 | 格式 | 示例 |
|------|------|------|------|------|
| Worker | `created_at` | Number | 毫秒级 (13位) | 1762152909651 |
| DataStore | `createdAt`, `lastMessageTime` | Number | 毫秒级 (13位) | 1762152909651 |
| Database | `created_at`, `last_message_time` | INTEGER | 毫秒级 (13位) | 1762152909651 |
| IM WebSocket | `createdTime`, `lastMessageTime` | Number | 毫秒级 (13位) | 1762152909651 |
| IM Client | Display | String | 用户本地时区 | "2025/11/3 14:55:09" |

### 转换规则

```javascript
// ✅ 正确: 秒级 → 毫秒级
if (timestamp < 10000000000) {
  timestamp = timestamp * 1000;
}

// ❌ 错误: 毫秒级 → 秒级 (绝对不要这样做!)
if (timestamp > 100000000000) {
  timestamp = timestamp / 1000;  // ❌ 违反统一标准!
}

// ✅ 正确: 保持毫秒级
const createdAtTimestamp = message.createdAt || Date.now();
```

---

## 经验总结

### 1. 问题定位策略

**自上而下排查**:
```
IM Client (显示错误)
  ↓ 查看接口返回
IM WebSocket (发送什么数据?)
  ↓ 检查内存数据
DataStore (内存中的时间戳正确吗?)
  ↓ 查看数据库
Database (存储的时间戳正确吗?)
  ↓ 追踪数据来源
CacheDAO (入库时有转换吗?)
  ↓ 查看原始数据
Worker (抓取的时间戳格式?)
```

### 2. 用户的关键洞察

用户在 Phase 2 的关键指引：

> **"入库可能是正确的，但是我们始终调用的是内存数据啊，内存数据是有问题的"**

这个洞察引导我们发现 CacheDAO 在**入库时就错误转换了时间戳**，而不是数据库存储有问题。

### 3. 字段命名的重要性

Phase 3 的问题根源是**字段名混淆**：

- `updatedAt`: 记录的更新时间 (metadata)
- `lastMessageTime`: 最后一条消息的时间 (业务数据)

这两个字段含义完全不同，但都是时间戳，容易混淆。

**教训**: 使用明确的字段名，避免 `updated_at` / `last_message_time` 这种容易混淆的命名。

### 4. 注释与代码的一致性

Phase 2 发现的问题：

```javascript
// 注释说: 确保 created_at 是秒级时间戳
// 代码: createdAtTimestamp = timestamp / 1000;
// Schema: created_at INTEGER -- 毫秒级时间戳

// ❌ 注释、代码、Schema 三者不一致!
```

**教训**: 注释、代码实现、数据库 Schema 必须保持一致。

### 5. 渐进式修复的价值

三个 Phase 的修复顺序：
1. Phase 1: 修复数据源 (Worker)
2. Phase 2: 修复持久化 (CacheDAO)
3. Phase 3: 修复输出 (IM WebSocket)

每个 Phase 都有独立的 Git commit，方便追踪和回滚。

---

## 验证清单

- [x] Worker 抓取的时间戳是毫秒级
- [x] DataStore 内存数据是毫秒级
- [x] CacheDAO 不修改时间戳格式
- [x] Database 存储的是毫秒级
- [x] IM WebSocket 使用正确的字段名
- [x] IM Client 显示正确的日期

---

## 相关 Commits

| Commit | Phase | 描述 |
|--------|-------|------|
| f7ac7be | Phase 1 | Worker normalizeTimestamp() 函数 |
| 3c44a1a | Phase 2 | CacheDAO 移除错误的秒级转换 |
| 67dd31a | Phase 3 | IM WebSocket 字段名修正 |

---

## 后续建议

### 1. 添加单元测试

```javascript
describe('normalizeTimestamp', () => {
  it('should convert seconds to milliseconds', () => {
    expect(normalizeTimestamp(1762152909)).toBe(1762152909000);
  });

  it('should keep milliseconds unchanged', () => {
    expect(normalizeTimestamp(1762152909651)).toBe(1762152909651);
  });

  it('should parse ISO 8601 strings', () => {
    const timestamp = normalizeTimestamp('2025-11-03T14:55:09.651Z');
    expect(timestamp).toBe(1762152909651);
  });
});
```

### 2. 添加 TypeScript 类型

```typescript
interface Conversation {
  conversationId: string;
  userName: string;
  lastMessageTime: number;  // 毫秒级时间戳
  updatedAt: number;         // 记录更新时间
  createdAt: number;         // 记录创建时间
}

interface Topic {
  id: string;
  title: string;
  lastMessageTime: number;  // 使用 conversation.lastMessageTime
  createdTime: number;      // 使用 conversation.createdAt
}
```

### 3. Schema 验证

在 `schema-validator.js` 中添加时间戳格式验证：

```javascript
function validateTimestampFormat(tableName, columnName) {
  const stmt = db.prepare(`SELECT ${columnName} FROM ${tableName} LIMIT 1000`);
  const rows = stmt.all();

  for (const row of rows) {
    const timestamp = row[columnName];
    if (timestamp < 10000000000 || timestamp > 10000000000000) {
      throw new Error(
        `Invalid timestamp in ${tableName}.${columnName}: ${timestamp} ` +
        `(expected 13-digit milliseconds)`
      );
    }
  }
}
```

### 4. 监控和告警

添加时间戳格式监控：

```javascript
function monitorTimestampFormats() {
  const tables = ['cache_messages', 'cache_conversations'];

  for (const table of tables) {
    const invalidCount = db.prepare(`
      SELECT COUNT(*) as count
      FROM ${table}
      WHERE created_at < 10000000000 OR created_at > 10000000000000
    `).get().count;

    if (invalidCount > 0) {
      logger.error(`Found ${invalidCount} invalid timestamps in ${table}`);
      // 发送告警
    }
  }
}
```

---

**修复完成**: 2025-11-03
**总计修改**: 3 个核心文件 + 4 个测试脚本
**影响范围**: Worker → DataStore → CacheDAO → Database → IM WebSocket → IM Client
**状态**: ✅ 全部修复完成
