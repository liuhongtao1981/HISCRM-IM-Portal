# 私信爬虫修复方案 - 最终确认版

## 时间: 2025-11-05

## 🎯 核心发现（通过 MCP 浏览器实际测试）

### 关键事实

1. **消息加载时机**: 所有会话的消息在**页面首次加载时**一次性获取
2. **触发的 API**: `/v2/message/get_by_user_init`（仅在页面加载时触发一次）
3. **点击行为**: 点击会话**不触发新的 API 请求**，只是从内存读取显示
4. **数据格式**: API 响应是**二进制 Protobuf 格式**

### 测试验证

**测试 1**: 点击"实在人"会话（索引 0）
- ❌ 未触发任何 API 请求
- ✅ 消息立即显示（从缓存读取）

**测试 2**: 点击"萍918"会话（索引 3，首次打开）
- ❌ 未触发任何 API 请求
- ✅ 消息立即显示（从缓存读取）

**结论**: 数据在页面加载时就已经全部获取完成。

---

## ❌ 之前文档中的错误假设

### 错误 1: 需要逐个点击会话

**错误理解**:
```
for (let i = 0; i < 41; i++) {
  点击会话 i
    ↓
  触发 API: /v2/message/get_by_user_init  ❌ 错误！
    ↓
  获取该会话的消息
}
```

**实际情况**:
```
页面加载一次
  ↓
触发 API: /v2/message/get_by_user_init（仅一次）✅
  ↓
返回所有 41 个会话的消息
  ↓
点击会话只是切换显示 ✅
```

### 错误 2: 需要解决虚拟列表滚动问题

**之前的方案**:
- 滚动到每个会话
- 让虚拟列表渲染目标元素
- 点击会话触发 API

**实际上**:
- ✅ 不需要滚动
- ✅ 不需要点击
- ✅ 只需要在页面加载时捕获 API 响应

### 错误 3: API 端点混淆

**之前认为**:
- `/v1/im/message/history` - 历史消息 API ❌
- `/v1/message/get_by_conversation` - 会话消息 API ❌

**实际上**:
- `/v2/message/get_by_user_init` - **唯一的消息 API** ✅
- 其他 API 可能不存在或未使用

---

## ✅ 正确的解决方案

### 唯一需要修复的问题

**问题**: API 拦截器无法解析二进制 Protobuf 响应

**位置**: `packages/worker/src/platforms/base/api-interceptor-manager.js` Line 87-98

**当前代码**:
```javascript
async parseJSON(response) {
  try {
    return await response.json();  // ❌ Protobuf 无法解析为 JSON
  } catch {
    try {
      const text = await response.text();
      return JSON.parse(text);
    } catch {
      return null;  // ❌ 返回 null，导致数据丢失
    }
  }
}
```

**结果**:
1. `/v2/message/get_by_user_init` 返回 Protobuf 二进制
2. `parseJSON()` 解析失败，返回 `null`
3. `onMessageInitAPI(body)` 收到 `body = null`
4. `if (!body || !body.data || !body.data.messages) return;` ← 直接退出
5. `apiData.init` 为空
6. 最终 `totalMessages = 0` ❌

---

## 🔧 修复方案

### 方案 A: 解析二进制响应（推荐）

#### 步骤 1: 修改 API 拦截器支持二进制

**文件**: `packages/worker/src/platforms/base/api-interceptor-manager.js`

**修改 `parseJSON()` 为 `parseResponse()`**:

```javascript
/**
 * 解析响应（支持 JSON 和二进制）
 */
async parseResponse(response) {
  const contentType = response.headers()['content-type'] || '';
  const url = response.url();

  // 1. 优先尝试 JSON
  try {
    const json = await response.json();
    return json;
  } catch (jsonError) {
    // JSON 解析失败，可能是二进制
  }

  // 2. 获取原始二进制数据
  try {
    const buffer = await response.body();

    logger.info(`[API Interceptor] 收到二进制响应: ${url}`);
    logger.info(`[API Interceptor] Content-Type: ${contentType}`);
    logger.info(`[API Interceptor] Buffer size: ${buffer.length} bytes`);

    return {
      __binary: true,
      buffer: buffer,
      contentType: contentType,
      url: url
    };
  } catch (bufferError) {
    logger.error(`[API Interceptor] 无法获取响应数据: ${bufferError.message}`);
    return null;
  }
}
```

**更新 `enable()` 方法**:

```javascript
async enable() {
  this.responseListener = async (response) => {
    try {
      const url = response.url();
      const status = response.status();

      // 跳过重定向
      if (status === 301 || status === 302) {
        // ...
        return;
      }

      // 检查是否匹配任何注册的模式
      for (const [pattern, handlers] of this.handlers.entries()) {
        if (minimatch(url, pattern)) {
          logger.info(`✅ [MATCH] ${pattern} -> ${url.substring(0, 100)}...`);

          // 使用新的 parseResponse 方法
          const body = await this.parseResponse(response);  // ← 修改这里

          // 调用所有注册的处理器，传入 response 对象
          for (const handler of handlers) {
            try {
              await handler(body, response);  // ← 同时传入 body 和 response
            } catch (error) {
              logger.error(`Handler failed for ${pattern}:`, error);
            }
          }
        }
      }
    } catch (error) {
      logger.error(`Response listener error:`, error);
    }
  };

  this.page.on('response', this.responseListener);
  logger.info(`Enabled ${this.handlers.size} API patterns (using response event)`);
}
```

#### 步骤 2: 修改回调函数处理二进制

**文件**: `packages/worker/src/platforms/douyin/crawl-direct-messages-v2.js`

**修改 `onMessageInitAPI()` 函数** (Line 106-123):

```javascript
/**
 * API 回调：消息初始化
 * 由 platform.js 注册到 APIInterceptorManager
 */
async function onMessageInitAPI(body, response) {
  logger.info(`[API] onMessageInitAPI 被调用`);

  // ========================================
  // 处理二进制响应（Protobuf）
  // ========================================
  if (body && body.__binary) {
    logger.info(`[API] 收到二进制响应:`);
    logger.info(`  - URL: ${body.url}`);
    logger.info(`  - Content-Type: ${body.contentType}`);
    logger.info(`  - Size: ${body.buffer.length} bytes`);

    // 保存二进制数据到文件，以便后续分析
    const fs = require('fs');
    const path = require('path');
    const timestamp = Date.now();
    const savePath = path.join(__dirname, '../../data/binary', `protobuf_${timestamp}.bin`);

    // 确保目录存在
    const saveDir = path.dirname(savePath);
    if (!fs.existsSync(saveDir)) {
      fs.mkdirSync(saveDir, { recursive: true });
    }

    fs.writeFileSync(savePath, body.buffer);
    logger.info(`[API] 二进制数据已保存到: ${savePath}`);

    // TODO: 实现 Protobuf 解码
    // 方案 1: 使用 protobufjs 动态解码
    // 方案 2: 提取 .proto 定义文件后解码
    // 方案 3: 从页面 React 状态提取（降级方案）

    logger.warn(`[API] ⚠️ Protobuf 解码尚未实现，暂时跳过`);
    logger.warn(`[API] ⚠️ 建议使用降级方案：从 DOM/React Fiber 提取数据`);

    return;
  }

  // ========================================
  // 处理 JSON 响应（如果有）
  // ========================================
  if (!body || !body.data || !body.data.messages) {
    logger.warn(`[API] 响应数据格式不正确:`, body ? Object.keys(body) : 'null');
    return;
  }

  // 使用 DataManager（如果可用）
  if (globalContext.dataManager && body.data.messages.length > 0) {
    try {
      const messages = globalContext.dataManager.batchUpsertMessages(
        body.data.messages,
        DataSource.API
      );
      logger.info(`✅ [API] 初始化消息 -> DataManager: ${messages.length} 条`);
    } catch (error) {
      logger.error(`[API] 初始化消息处理失败:`, error);
    }
  }

  // 保留旧逻辑用于调试
  apiData.init.push(body);
  logger.debug(`收集到初始化消息: ${body.data.messages.length} 条`);
}
```

#### 步骤 3: 验证二进制数据捕获

**运行爬虫**:
```bash
cd packages/worker
npm start
```

**预期日志**:
```
[API Interceptor] 收到二进制响应: https://imapi.snssdk.com/v2/message/get_by_user_init
[API Interceptor] Content-Type: application/x-protobuf
[API Interceptor] Buffer size: XXXXX bytes
[API] 二进制数据已保存到: packages/worker/data/binary/protobuf_1234567890.bin
```

**验证文件**:
```bash
ls -lh packages/worker/data/binary/
# 应该看到 .bin 文件
```

---

### 方案 B: 从 React 状态提取（降级方案）

如果 Protobuf 解析困难，直接从页面提取数据。

**新增函数**: `extractMessagesFromDOM()`

```javascript
/**
 * 从页面 DOM/React Fiber 提取所有消息
 * @param {Page} page - Playwright page 对象
 * @param {Object} account - 账户信息
 * @returns {Promise<Array>} 所有消息
 */
async function extractMessagesFromDOM(page, account) {
  logger.info('[DOM] 开始从 DOM/React Fiber 提取消息');

  const messages = await page.evaluate(() => {
    // 方法 1: 尝试从全局变量提取
    if (window.__INITIAL_STATE__ || window.__NEXT_DATA__) {
      const state = window.__INITIAL_STATE__ || window.__NEXT_DATA__;
      // 尝试查找消息数据
      // ...
    }

    // 方法 2: 从 React Fiber 提取
    const root = document.querySelector('#root');
    if (!root) return [];

    const fiberKey = Object.keys(root).find(k => k.startsWith('__reactFiber$'));
    if (!fiberKey) return [];

    const fiber = root[fiberKey];

    // 递归遍历 Fiber 树
    function traverseFiber(node, depth = 0) {
      if (depth > 20) return null;  // 防止无限循环

      // 检查当前节点的 props 和 state
      const props = node.memoizedProps || {};
      const state = node.memoizedState;

      // 查找包含消息数据的节点
      if (props.messages && Array.isArray(props.messages)) {
        return props.messages;
      }

      if (state && state.messages && Array.isArray(state.messages)) {
        return state.messages;
      }

      // 递归子节点
      if (node.child) {
        const result = traverseFiber(node.child, depth + 1);
        if (result) return result;
      }

      // 递归兄弟节点
      if (node.sibling) {
        const result = traverseFiber(node.sibling, depth + 1);
        if (result) return result;
      }

      return null;
    }

    const messagesData = traverseFiber(fiber);
    return messagesData || [];
  });

  logger.info(`[DOM] 从 React Fiber 提取到 ${messages.length} 条消息`);

  // 转换为标准格式
  const formattedMessages = messages.map(msg => ({
    id: msg.id || msg.message_id || generateMessageId(),
    account_id: account.id,
    conversation_id: msg.conversation_id,
    platform_message_id: msg.id || msg.message_id,
    content: msg.content || msg.text || '',
    platform_sender_id: msg.sender_id || msg.from_id,
    platform_sender_name: msg.sender_name || msg.from_name,
    created_at: msg.create_time ? msg.create_time * 1000 : Date.now(),
    detected_at: Date.now(),
    is_new: true,
    push_count: 0
  }));

  return formattedMessages;
}
```

**在主函数中使用**:

```javascript
async function crawlDirectMessagesV2(page, account, dataManager) {
  try {
    // 导航到页面
    await page.goto('https://creator.douyin.com/creator-micro/data/following/chat');
    await page.waitForTimeout(5000);  // 等待页面加载完成

    // 方案 A: 从 API 拦截器获取（如果可用）
    if (apiData.init.length > 0) {
      logger.info(`✅ 从 API 获取数据: ${apiData.init.length} 个响应`);
      // 处理 API 数据...
    } else {
      // 方案 B: 从 DOM 提取（降级）
      logger.warn(`⚠️ API 数据为空，使用 DOM 提取方案`);
      const messages = await extractMessagesFromDOM(page, account);

      if (messages.length > 0) {
        logger.info(`✅ 从 DOM 提取到 ${messages.length} 条消息`);

        // 存储到数据库
        if (dataManager) {
          dataManager.batchUpsertMessages(messages, DataSource.DOM);
        }
      }
    }

    // 返回结果...
  } catch (error) {
    logger.error(`[crawlDirectMessagesV2] 失败:`, error);
    throw error;
  }
}
```

---

## 📊 修复方案对比

| 方案 | 优点 | 缺点 | 难度 | 推荐度 |
|-----|------|------|------|--------|
| **A: 解析二进制** | 完整、准确、可靠 | 需要 Protobuf 定义 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **B: DOM 提取** | 简单、快速实现 | 可能不完整、不稳定 | ⭐ | ⭐⭐⭐ |

---

## 🎯 最终修复步骤

### 阶段 1: 捕获二进制数据（立即可做）

1. 修改 `api-interceptor-manager.js` 的 `parseResponse()` 方法
2. 修改 `onMessageInitAPI()` 保存二进制文件
3. 运行爬虫，验证二进制数据已保存

**预期时间**: 30 分钟

**验证标准**:
- ✅ 日志显示"收到二进制响应"
- ✅ 文件 `protobuf_*.bin` 已保存
- ✅ 文件大小 > 0

### 阶段 2A: 实现 Protobuf 解码（可选）

1. 安装 `protobufjs`: `npm install protobufjs`
2. 从页面源码提取 `.proto` 定义
3. 实现解码逻辑
4. 验证解码结果

**预期时间**: 2-4 小时

**验证标准**:
- ✅ 成功解码二进制数据
- ✅ 提取到消息列表
- ✅ 消息结构完整（id, content, sender, time）

### 阶段 2B: 实现 DOM 提取（降级）

1. 实现 `extractMessagesFromDOM()` 函数
2. 从 React Fiber 遍历提取数据
3. 验证数据完整性

**预期时间**: 1-2 小时

**验证标准**:
- ✅ 提取到所有会话的消息
- ✅ 数据格式正确
- ✅ `totalMessages > 0`

### 阶段 3: 测试和验证

1. 运行完整的爬虫流程
2. 检查数据库中的消息数量
3. 验证消息内容完整

**验证清单**:
- [ ] 运行 `npm start` 启动 Worker
- [ ] 观察日志输出
- [ ] 检查 `totalMessages` 不为 0
- [ ] 运行 `node tests/check-dm-database.js`
- [ ] 确认 `cache_direct_messages` 表有数据
- [ ] 抽查几条消息内容是否正确

---

## 📝 总结

### 核心结论

1. **不需要滚动虚拟列表** ✅
2. **不需要逐个点击会话** ✅
3. **只需要修复一个问题**: API 拦截器无法解析二进制 ✅

### 最简单的实现路径

```
修改 api-interceptor-manager.js
  ↓
捕获二进制响应（保存到文件）
  ↓
方案 A: 解码 Protobuf
或
方案 B: 从 DOM 提取
  ↓
完成！✅
```

### 预期效果

**修复前**:
- API 响应: Protobuf 二进制
- 解析结果: `null`
- 消息数量: 0 ❌

**修复后**:
- API 响应: Protobuf 二进制
- 解析结果: 41 个会话的所有消息 ✅
- 消息数量: 数百到数千条 ✅

---

## 相关文件

### 需要修改的文件

1. **`packages/worker/src/platforms/base/api-interceptor-manager.js`**
   - Line 87-98: 修改 `parseJSON()` 为 `parseResponse()`
   - Line 63: 更新 `enable()` 调用新方法

2. **`packages/worker/src/platforms/douyin/crawl-direct-messages-v2.js`**
   - Line 106-123: 修改 `onMessageInitAPI()` 处理二进制
   - 新增: `extractMessagesFromDOM()` 函数（可选）

### 不需要修改的文件

- ~~`scrollConversationListToLoadAll()`~~ - 不需要滚动
- ~~`openConversationByIndex()`~~ - 不需要点击
- ~~虚拟列表相关代码~~ - 完全不相关

---

## 附录：其他已生成的文档

之前生成的 4 份文档中关于"虚拟列表滚动"和"逐个点击"的内容**可以忽略**，因为基于错误的假设。

保留有用的部分：
- ✅ API 端点分析
- ✅ 二进制响应处理
- ✅ Protobuf 解码方案

可以删除的部分：
- ❌ 虚拟列表滚动代码
- ❌ `scrollVirtualListToIndex()` 函数
- ❌ 逐个点击会话的 for 循环
