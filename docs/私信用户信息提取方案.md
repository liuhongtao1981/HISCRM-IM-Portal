# 私信用户信息提取方案

**测试日期**: 2025-10-25
**状态**: ✅ 已验证可行

---

## 🎯 核心结论

### ✅ React Fiber 中可以提取的用户信息

| 字段 | 类型 | 可用性 | 说明 |
|------|------|--------|------|
| **sender** | string | ✅ 100% | 发送者用户ID |
| **avatar** | string | ⚠️ 仅对方消息 | 头像URL（100x100） |
| **nickname** | string | ⚠️ 仅对方消息 | 用户昵称 |
| **isFromMe** | boolean | ✅ 100% | 消息方向 |

---

## 📋 数据示例

### 示例 1: 自己发送的消息

```javascript
{
  "serverId": "7550509169683400713",
  "conversationId": "0:1:2270953921061816:2851498123342840",
  "isFromMe": true,

  // ✅ 有 sender
  "sender": "2270953921061816",

  // ❌ 无 avatar 和 nickname
  "avatar": undefined,
  "nickname": undefined
}
```

### 示例 2: 对方发送的消息

```javascript
{
  "serverId": "7550509225496708667",
  "conversationId": "0:1:2270953921061816:2851498123342840",
  "isFromMe": false,

  // ✅ 有 sender
  "sender": "2851498123342840",

  // ✅ 有 avatar 和 nickname
  "avatar": "https://p11.douyinpic.com/aweme/100x100/aweme-avatar/...",
  "nickname": "夕阳正好"
}
```

---

## 🔍 conversationId 结构分析

### 格式

```
conversationId = "0:1:2270953921061816:2851498123342840"
                  │ │ │                └─ 会话ID
                  │ │ └──────────────────── 当前账户的用户ID
                  │ └────────────────────── 类型标识
                  └──────────────────────── 前缀
```

### 关键发现

1. **conversationId 的第三部分是当前账户的用户ID**
2. **sender 字段是实际发送者的用户ID**
3. **当 isFromMe = true 时，sender 等于 conversationId 的第三部分**
4. **当 isFromMe = false 时，sender 是对方的用户ID（不在 conversationId 中）**

---

## 💡 实现方案

### 方案：建立用户信息缓存

```javascript
async function extractMessagesWithUserInfo(page, account) {
  // 1. 提取消息
  const rawMessages = await page.evaluate(() => {
    const allElements = document.querySelectorAll('[class*="message"], [class*="item"]');
    const messages = [];

    allElements.forEach((element) => {
      const fiberKey = Object.keys(element).find(key =>
        key.startsWith('__reactFiber')
      );

      if (!fiberKey) return;

      let current = element[fiberKey];
      let depth = 0;

      while (current && depth < 20) {
        if (current.memoizedProps) {
          const props = current.memoizedProps;

          if (props.conversationId && props.serverId) {
            messages.push({
              serverId: props.serverId,
              conversationId: props.conversationId,
              sender: props.sender,              // ✅ 发送者ID
              avatar: props.avatar,              // ⚠️ 仅对方消息
              nickname: props.nickname,          // ⚠️ 仅对方消息
              isFromMe: props.isFromMe,
              content: props.content,
              type: props.type,
              createdAt: props.createdAt
            });
            break;
          }
        }

        current = current.return;
        depth++;
      }
    });

    return messages;
  });

  // 2. 建立用户信息映射表
  const userInfoMap = new Map();

  rawMessages.forEach(message => {
    // 如果是对方消息且有头像和昵称，保存到映射表
    if (!message.isFromMe && message.avatar && message.nickname) {
      userInfoMap.set(message.sender, {
        avatar: message.avatar,
        nickname: message.nickname
      });
    }
  });

  // 3. 为所有消息填充用户信息
  const messagesWithUserInfo = rawMessages.map(message => {
    const userInfo = userInfoMap.get(message.sender) || {};

    return {
      platform_message_id: message.serverId,
      conversation_id: parseConversationId(message.conversationId).realConvId,
      platform_sender_id: message.sender,           // ✅ 新增
      sender_avatar: userInfo.avatar || null,       // ✅ 新增
      sender_nickname: userInfo.nickname || null,   // ✅ 新增
      content: message.content?.text,
      direction: message.isFromMe ? 'outbound' : 'inbound',
      message_type: message.type,
      created_at: new Date(message.createdAt).getTime() / 1000
    };
  });

  return messagesWithUserInfo;
}

// 辅助函数：解析 conversationId
function parseConversationId(conversationId) {
  const parts = conversationId.split(':');
  return {
    prefix: parts[0],
    type: parts[1],
    accountUserId: parts[2],      // 当前账户的用户ID
    realConvId: parts[3]          // 真实会话ID
  };
}
```

---

## 📊 数据完整性

### 测试结果（19条消息）

| 指标 | 结果 | 说明 |
|------|------|------|
| 有 sender | ✅ 19/19 (100%) | 所有消息都有发送者ID |
| 有 avatar | ⚠️ 8/19 (42%) | 仅对方消息有头像 |
| 有 nickname | ⚠️ 8/19 (42%) | 仅对方消息有昵称 |

### 为什么只有 42%？

- **自己发送的消息**（isFromMe = true）：11条，无 avatar 和 nickname
- **对方发送的消息**（isFromMe = false）：8条，有 avatar 和 nickname

这是正常的，因为 React 不需要为自己的消息重复显示自己的头像和昵称。

---

## 🛠️ 数据库字段

### 建议在 direct_messages 表中添加：

```sql
-- 新增字段
platform_sender_id   TEXT,     -- 发送者用户ID
sender_avatar        TEXT,     -- 发送者头像URL
sender_nickname      TEXT      -- 发送者昵称
```

### 完整字段列表

```sql
CREATE TABLE direct_messages (
  id                   TEXT PRIMARY KEY,
  account_id           TEXT NOT NULL,
  platform             TEXT NOT NULL,
  conversation_id      TEXT NOT NULL,
  platform_message_id  TEXT,
  platform_sender_id   TEXT,          -- ✅ 新增
  sender_avatar        TEXT,          -- ✅ 新增
  sender_nickname      TEXT,          -- ✅ 新增
  content              TEXT,
  direction            TEXT,
  message_type         TEXT,
  created_at           INTEGER,
  is_read              INTEGER DEFAULT 0,
  status               TEXT DEFAULT 'sent',
  -- ... 其他字段
);
```

---

## ✅ 优势

1. **sender 字段 100% 可用** - 所有消息都有发送者ID
2. **对方的头像和昵称可靠** - 从对方消息中提取
3. **实现简单** - 直接从 React Fiber 读取
4. **性能好** - 无需额外的网络请求

---

## ⚠️ 限制

1. **自己的消息无头像和昵称** - 需要从其他地方获取（账户信息）
2. **依赖 React Fiber** - 如果抖音更改前端实现可能失效

---

## 🔄 与会话列表数据的关系

会话列表中也包含用户信息，可以作为补充数据源：

```javascript
// 会话列表提取（点击会话前）
const conversationList = await page.evaluate(() => {
  // 从会话列表元素提取
  return {
    userId: "...",
    avatar: "...",
    nickname: "..."
  };
});

// 存储到映射表
userInfoMap.set(conversationList.userId, {
  avatar: conversationList.avatar,
  nickname: conversationList.nickname
});
```

---

## 🎯 推荐实现步骤

1. ✅ **修改 crawl-direct-messages-v2.js**
   - 提取 `sender`、`avatar`、`nickname` 字段
   - 建立用户信息映射表
   - 为所有消息填充用户信息

2. ⏸️ **更新数据库 schema**
   - 添加新字段到 `direct_messages` 表
   - 更新 DAO 文件

3. ⏸️ **测试验证**
   - 运行完整的私信抓取测试
   - 验证数据完整性

4. ⏸️ **可选优化**
   - 从会话列表预加载用户信息
   - 添加自己账户的头像和昵称

---

**总结**: ✅ 可以提取发送者用户ID (sender)，对方消息还包含头像和昵称，实现简单可靠！

**下一步**: 修改 `crawl-direct-messages-v2.js` 添加用户信息提取逻辑
