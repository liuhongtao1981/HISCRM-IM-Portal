# 评论列表只显示 1 条 - 修复方案

## 问题现象

- **Tab 未读数**：显示 8 条（正确）✅
- **评论列表**：只显示 1 条（错误）❌
- **预期**：应该显示所有有未读评论的作品（8 个作品）

## 问题原因

### 原来的逻辑

**文件**：`packages/crm-pc-im/src/pages/MonitorPage.tsx`
**位置**：Lines 110-144

```typescript
const unreadCommentsByTopic = React.useMemo(() => {
  // 遍历该账户的所有作品
  currentTopics.forEach(topic => {
    // ❌ 问题：依赖客户端的消息缓存
    const topicMessages = messages[topic.id] || []
    const unreadMessages = topicMessages.filter(msg => ...)

    // 只有当 messages[topic.id] 中有未读消息时，才显示这个作品
    if (unreadMessages.length > 0) {
      topicsWithUnread.push({ topic, unreadCount, lastUnreadMessage })
    }
  })
}, [selectedChannelId, currentTopics, messages])
```

### 问题分析

1. **`messages[topic.id]` 的数据来源**：只有当用户**点击了该作品**后，才会从服务端加载消息并存入 `messages[topic.id]`

2. **导致的问题**：
   - 如果用户没有点击某个作品，`messages[topic.id]` 是空的
   - 即使该作品有未读消息（`topic.unreadCount > 0`），也不会显示在列表中
   - 只有用户点击过的作品才会出现在列表中

3. **数据不一致**：
   - Tab 未读数来自 `topic.unreadCount`（服务端计算）：**8 条**
   - 列表显示的作品来自 `messages[topic.id]`（客户端缓存）：**1 条**（只点击过 1 个作品）

### 数据流对比

**Tab 未读数的数据流**（正确）：
```
Master DataStore
  ↓
getTopicsFromDataStore()
  ↓
计算 topic.unreadCount
  ↓
推送给客户端
  ↓
Tab 显示：8 条 ✅
```

**评论列表的数据流**（错误）：
```
用户点击作品 A
  ↓
emit('monitor:request_messages', { topicId: A })
  ↓
服务端返回作品 A 的消息
  ↓
存入 messages[A]
  ↓
列表显示：1 条（只有作品 A）❌
```

## 修复方案

### 核心原则

**评论列表应该直接使用服务端返回的 `topic.unreadCount`，不依赖客户端的消息缓存**

### 代码修改

**文件**：`packages/crm-pc-im/src/pages/MonitorPage.tsx`

**修改 1**：Lines 110-153 - 修改 `unreadCommentsByTopic` 计算逻辑

```typescript
const unreadCommentsByTopic = React.useMemo(() => {
  if (!selectedChannelId) return []

  const topicsWithUnread: Array<{
    topic: Topic
    unreadCount: number
    lastUnreadMessage?: Message  // ✅ 可选字段
  }> = []

  // 遍历该账户的所有作品
  currentTopics.forEach(topic => {
    // ✅ 修复: 直接使用服务端返回的 unreadCount，不依赖客户端 messages 缓存
    // 评论作品 (isPrivate = false) 且有未读数
    if (!topic.isPrivate && topic.unreadCount && topic.unreadCount > 0) {
      // 尝试获取该作品的消息（如果已加载）
      const topicMessages = messages[topic.id] || []
      const unreadMessages = topicMessages.filter(msg =>
        (msg.messageCategory === 'comment' || !msg.messageCategory) &&
        !msg.isRead &&
        msg.fromId !== 'monitor_client'
      )

      // 如果有加载的消息，取最新的一条；否则为 undefined
      let lastUnreadMessage: Message | undefined = undefined
      if (unreadMessages.length > 0) {
        const sortedUnread = [...unreadMessages].sort((a, b) => b.timestamp - a.timestamp)
        lastUnreadMessage = sortedUnread[0]
      }

      topicsWithUnread.push({
        topic,
        unreadCount: topic.unreadCount,  // ✅ 使用服务端的 unreadCount
        lastUnreadMessage
      })
    }
  })

  // 按最新消息时间降序排列
  return topicsWithUnread.sort((a, b) => {
    const aTime = a.lastUnreadMessage?.timestamp || a.topic.lastMessageTime || 0
    const bTime = b.lastUnreadMessage?.timestamp || b.topic.lastMessageTime || 0
    return bTime - aTime
  })
}, [selectedChannelId, currentTopics, messages])
```

**修改 2**：Lines 708-730 - 修改渲染逻辑，处理 `lastUnreadMessage` 可能为 `undefined` 的情况

```typescript
title={
  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
    <Text strong style={{ fontSize: 15 }}>
      {item.topic.title}
    </Text>
    <Text type="secondary" style={{ fontSize: 12 }}>
      {formatTime(item.lastUnreadMessage?.timestamp || item.topic.lastMessageTime)}
    </Text>
  </div>
}
description={
  <div>
    {item.lastUnreadMessage ? (
      <Text type="secondary" style={{ fontSize: 13 }}>
        {item.lastUnreadMessage.fromName}: {truncateText(item.lastUnreadMessage.content, 50)}
      </Text>
    ) : (
      <Text type="secondary" style={{ fontSize: 13 }}>
        {item.unreadCount} 条未读评论
      </Text>
    )}
  </div>
}
```

## 修改说明

### 1. 判断条件改变

**修改前**：
```typescript
if (unreadMessages.length > 0) {  // 依赖客户端消息缓存
  topicsWithUnread.push(...)
}
```

**修改后**：
```typescript
if (!topic.isPrivate && topic.unreadCount && topic.unreadCount > 0) {  // 依赖服务端数据
  topicsWithUnread.push(...)
}
```

### 2. 数据来源改变

**修改前**：
```typescript
unreadCount: unreadMessages.length  // 从客户端消息缓存计算
```

**修改后**：
```typescript
unreadCount: topic.unreadCount  // 直接使用服务端计算的值
```

### 3. 消息详情可选

**修改前**：
```typescript
lastUnreadMessage: Message  // 必须字段
```

**修改后**：
```typescript
lastUnreadMessage?: Message  // 可选字段
```

### 4. 渲染逻辑适配

**修改前**：
```typescript
{item.lastUnreadMessage.fromName}: {item.lastUnreadMessage.content}
```

**修改后**：
```typescript
{item.lastUnreadMessage ? (
  {item.lastUnreadMessage.fromName}: {item.lastUnreadMessage.content}
) : (
  {item.unreadCount} 条未读评论
)}
```

## 数据流对比

### 修复前（错误）

```
服务端推送 topics
  ↓
topic.unreadCount = 8
  ↓
Tab 显示：8 条 ✅
  ↓
评论列表逻辑
  ↓
遍历 topics，检查 messages[topic.id]
  ↓
只有 1 个 topic 的消息已加载
  ↓
列表显示：1 条 ❌
```

### 修复后（正确）

```
服务端推送 topics
  ↓
topic.unreadCount = 8
  ↓
Tab 显示：8 条 ✅
  ↓
评论列表逻辑
  ↓
遍历 topics，检查 topic.unreadCount > 0
  ↓
找到 8 个有未读的 topics
  ↓
列表显示：8 条 ✅
  ↓
如果用户点击过某个作品，显示最新消息内容
如果没有点击过，显示 "X 条未读评论"
```

## 优势

### 1. 数据一致性

- Tab 未读数和列表显示的作品数量保持一致
- 都依赖服务端的 `topic.unreadCount`

### 2. 用户体验

- 用户无需点击作品即可看到所有有未读消息的作品
- 点击过的作品会显示最新消息内容
- 未点击过的作品显示未读数量

### 3. 性能优化

- 不需要预加载所有作品的消息
- 只在用户点击时才加载消息详情
- 减少服务端压力和网络传输

## 验证方法

### 1. 刷新 IM 客户端

```bash
在浏览器中按 Ctrl+F5 强制刷新
```

### 2. 测试步骤

1. 点击某个账户
2. 观察评论 Tab 的未读数（例如：8）
3. 观察评论列表显示的作品数量

**预期结果**：
- Tab 未读数：8 条
- 评论列表：8 个作品（即使没有点击过）
- 点击过的作品显示最新消息内容
- 未点击过的作品显示 "X 条未读评论"

## 总结

### 问题本质

**评论列表依赖客户端消息缓存，而不是服务端的未读数统计**

### 解决方案

**改为直接使用服务端的 `topic.unreadCount`，不依赖客户端消息缓存**

### 修改文件

1. ✅ `packages/crm-pc-im/src/pages/MonitorPage.tsx` - Lines 110-153 (计算逻辑)
2. ✅ `packages/crm-pc-im/src/pages/MonitorPage.tsx` - Lines 708-730 (渲染逻辑)

### 核心原则

**服务端数据是唯一真相来源，客户端只负责展示**

## 版本信息

- **修复日期**：2025-11-05
- **影响范围**：评论列表显示不完整
- **破坏性变更**：无（向后兼容）
- **测试状态**：✅ 代码已修复，等待测试验证
