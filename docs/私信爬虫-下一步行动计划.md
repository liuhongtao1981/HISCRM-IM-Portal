# 私信爬虫 - 下一步行动计划

## 当前状态总结 (2025-11-05 13:53)

### ✅ 已完成

1. **二进制Protobuf检测** - 100%完成
   - ✅ API拦截器成功检测Protobuf响应
   - ✅ 保存buffer和元数据（`__isBinary` 标记）
   - ✅ 自动切换到DOM提取模式
   - ✅ 日志清晰记录10次Protobuf响应（175KB-268KB）

2. **API会话列表提取** - 100%完成
   - ✅ 从12个API响应中提取220个会话
   - ✅ DataManager成功入库40个会话（去重后）
   - ✅ 会话数据结构正确

3. **系统启动** - 100%完成
   - ✅ Master服务成功启动（端口3000）
   - ✅ Worker1成功注册并分配1个账户
   - ✅ 私信爬虫自动执行完成（9秒耗时）

### ❌ 发现问题

**DOM提取返回0个会话**：
- 目标：滚动提取220个会话
- 实际：批次0-9提取0个，批次10-19提取0个
- 原因：选择器失效或页面加载不完全

### 🔍 待诊断

需要运行诊断脚本确认根本原因：
- 文件：`tests/debug-dom-extraction-issue.js`
- 目的：找出正确的选择器和DOM结构

---

## 下一步行动（优先级排序）

### 🔴 优先级1: 诊断DOM提取失败原因

**目标**：找出为什么 `extractVisibleConversations()` 返回0个会话

**步骤**：
```bash
cd e:/HISCRM-IM-main
node tests/debug-dom-extraction-issue.js
```

**需要手动操作**：
1. 扫码登录抖音创作者中心
2. 导航到"私信管理"页面
3. 等待60秒让脚本自动诊断

**预期输出**：
- 原始选择器 `[role="listitem"]` 能否找到元素
- 虚拟列表容器 `.ReactVirtualized__Grid` 是否存在
- 正确的会话元素选择器是什么
- innerScrollContainer的子元素数量

**成功标准**：
- 找到能提取会话的有效选择器
- 确认虚拟列表容器正确
- 理解DOM结构

---

### 🟠 优先级2: 修复DOM提取函数

**基于诊断结果，选择修复方案**：

#### 方案A: 修复选择器（最可能）

如果 `[role="listitem"]` 失效，使用 `.ReactVirtualized__Grid__innerScrollContainer > div`：

```javascript
// 文件：packages/worker/src/platforms/douyin/crawl-direct-messages-v2.js
// 函数：extractVisibleConversations() (Line 247-332)

async function extractVisibleConversations(page) {
  const result = await page.evaluate(() => {
    const conversations = [];
    const messages = [];

    // 新方法：通过innerScrollContainer
    const innerContainer = document.querySelector('.ReactVirtualized__Grid__innerScrollContainer');

    if (innerContainer) {
      const items = Array.from(innerContainer.children);

      items.forEach((item, index) => {
        // 提取所有文本节点
        const allTexts = Array.from(item.querySelectorAll('div, span'))
          .map(el => el.textContent?.trim())
          .filter(t => t && t.length > 0 && t.length < 200);

        // 识别用户名（第一个较长的非日期文本）
        const userName = allTexts.find(t =>
          t.length > 2 &&
          !t.match(/^\d{2}-\d{2}$/) &&
          !t.includes('昨天') &&
          !t.includes('星期')
        );

        if (!userName) return;

        // 提取最后一条消息
        const messageTexts = allTexts.filter(text =>
          text !== userName &&
          !text.match(/^\d{2}-\d{2}$/) &&
          !text.includes('昨天') &&
          !text.includes('星期') &&
          text !== '置顶' &&
          text !== '已读' &&
          text !== '删除'
        );

        const lastMessage = messageTexts[messageTexts.length - 1];

        const conversationId = `conv_${index}_${Date.now()}`;

        conversations.push({
          id: conversationId,
          userName,
          lastMessage,
          index
        });

        if (lastMessage) {
          messages.push({
            conversationId,
            content: lastMessage,
            userName,
            index
          });
        }
      });
    }

    return {
      conversations,
      messages,
      totalItems: conversations.length
    };
  });

  logger.info(`[DOM提取] 成功提取 ${result.conversations.length} 个会话, ${result.messages.length} 条消息预览`);
  return result;
}
```

#### 方案B: 增加等待时间

```javascript
// 文件：packages/worker/src/platforms/douyin/crawl-direct-messages-v2.js
// 函数：scrollVirtualListToIndex() (Line 145)

// 修改前
await page.waitForTimeout(200);

// 修改后
await page.waitForTimeout(500);  // 200ms → 500ms
```

#### 方案C: 等待元素可见

```javascript
// 文件：packages/worker/src/platforms/douyin/crawl-direct-messages-v2.js
// 函数：scrollVirtualListToIndex() (Line 145)

// 替代固定延迟
try {
  await page.waitForSelector('.ReactVirtualized__Grid__innerScrollContainer > div', {
    state: 'visible',
    timeout: 1000
  });
} catch {
  // 超时继续（可能元素已存在）
}
```

#### 方案D: 页面加载后增加等待

```javascript
// 文件：packages/worker/src/platforms/douyin/crawl-direct-messages-v2.js
// 函数：crawlDirectMessagesV2() (主函数，导航后)

// 导航到私信页面
await page.goto('https://creator.douyin.com/im/chat?...');

// 等待虚拟列表出现
await page.waitForSelector('.ReactVirtualized__Grid', {
  state: 'visible',
  timeout: 10000
});

// 额外等待React渲染
await page.waitForTimeout(3000);  // 2s → 3s

logger.info('[Phase 8] Navigated to message page and waited for virtual list');
```

---

### 🟡 优先级3: 重启Worker验证修复

**步骤**：

1. 停止当前Worker进程
```bash
taskkill /F /PID 15568  # Worker1的PID
```

2. 清空旧日志（可选）
```bash
rm packages/worker/logs/crawl-direct-messages-v2.log
rm packages/worker/logs/monitor-task.log
```

3. Master会自动重启Worker（WorkerLifecycleManager）

4. 等待爬虫执行（约15-30秒后自动触发）

5. 检查日志
```bash
tail -f packages/worker/logs/crawl-direct-messages-v2.log
```

**成功标准**：
```
[DOM提取-滚动] 处理批次 0-9
[DOM提取] 成功提取 17 个会话, 17 条消息预览  ✅
[DOM提取-滚动] 批次 0-9: 提取 17 个, 累计唯一 17 个  ✅
...
[DOM提取-滚动] ✅ 完成！共提取 41 个唯一会话, 41 条消息
```

---

### 🟢 优先级4: 验证完整数据

**检查Master数据库**：
```bash
cd packages/master
sqlite3 data/master.db

SELECT COUNT(*) FROM conversations WHERE account_id = 'acc-98296c87-2e42-447a-9d8b-8be008ddb6e4';
-- 预期：41个会话

SELECT COUNT(*) FROM direct_messages WHERE account_id = 'acc-98296c87-2e42-447a-9d8b-8be008ddb6e4';
-- 预期：41条消息（每个会话1条预览）

SELECT sender_name, content, timestamp_server FROM direct_messages
WHERE account_id = 'acc-98296c87-2e42-447a-9d8b-8be008ddb6e4'
ORDER BY timestamp_server DESC
LIMIT 5;
-- 查看最新5条消息
```

**检查Worker缓存**：
```bash
cd packages/worker
sqlite3 data/worker1-cache.db

SELECT COUNT(*) FROM cache_conversations;
-- 预期：41个会话

SELECT COUNT(*) FROM cache_messages;
-- 预期：41条消息
```

---

### 🔵 优先级5: 更新文档

**成功后需要更新的文档**：

1. **修复报告**：`docs/私信爬虫DOM提取0会话问题-修复报告.md`
   - 记录诊断结果
   - 记录采用的修复方案
   - 记录验证结果

2. **会话总结更新**：`docs/私信爬虫改进-会话总结.md`
   - 添加DOM提取修复章节
   - 更新最终测试结果

3. **技术总结**：`docs/私信爬虫0消息问题-完整解决方案总结.md`
   - 添加DOM提取失败和修复过程

---

## 时间线预估

| 任务 | 预计时间 | 累计 |
|------|---------|------|
| 1. 运行诊断脚本 | 15分钟 | 15分钟 |
| 2. 修复DOM提取函数 | 10分钟 | 25分钟 |
| 3. 重启Worker验证 | 5分钟 | 30分钟 |
| 4. 验证完整数据 | 5分钟 | 35分钟 |
| 5. 更新文档 | 10分钟 | 45分钟 |

**总计**：约45分钟完成全部修复和验证

---

## 风险和备选方案

### 风险1: 诊断脚本无法找到正确选择器

**备选方案**：
- 使用MCP浏览器手动分析DOM结构
- 使用Chrome DevTools检查元素
- 查看抖音前端源码（webpack bundle）

### 风险2: 修复后仍然提取0个会话

**备选方案**：
- 放弃DOM提取，直接使用API数据（220个会话）
- 实现点击会话提取详细消息的方案（长期）
- 尝试逆向Protobuf二进制（长期）

### 风险3: 抖音更新反爬机制

**备选方案**：
- 增加随机延迟
- 使用更保守的爬取策略（减少频率）
- 切换到移动端API

---

## 决策点

### 决策1: 是否需要滚动提取？

**当前数据**：
- API已提取220个会话
- DataManager入库40个会话（去重后）
- 每个会话只有最后一条消息预览

**如果不修复DOM提取**：
- ✅ 优势：已经有40个会话数据
- ❌ 劣势：无法提取每个会话的完整消息历史

**如果修复DOM提取**：
- ✅ 优势：可以滚动提取全部220个会话
- ✅ 优势：为未来点击提取做准备
- ❌ 劣势：需要额外开发时间

**建议**：继续修复，因为滚动提取是后续点击提取的基础。

### 决策2: 修复方案选择

**基于诊断结果决定**：
- 如果选择器问题 → 方案A（最可能）
- 如果等待时间问题 → 方案B或C
- 如果页面加载问题 → 方案D
- 可能需要组合多个方案

---

## 联系和协作

**需要用户确认**：
1. 是否继续修复DOM提取？
2. 是否接受45分钟的修复时间？
3. 是否需要我直接运行诊断脚本（需要扫码登录）？

**当前状态**：
- Master服务：✅ 运行中（后台Bash进程 `c348de`）
- Worker1：✅ 运行中（PID 15568）
- 诊断脚本：📝 已创建，等待运行
- 修复方案：📋 已准备，等待诊断结果

---

**文档时间**: 2025-11-05 13:53
**下次更新**: 诊断脚本运行完成后
**状态**: 等待用户决策和诊断脚本执行
