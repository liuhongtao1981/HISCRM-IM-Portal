# 登录状态问题完整解决方案

## 问题总结

### 用户反馈
> "登录不登录，并不是库里存的，而是worker 要进行登录检测呀"
> "OK，登录成功后，蜘蛛任务，貌似没有执行，看下日志"

### 问题现象

用户登录成功后，爬虫任务没有执行，Worker 日志持续显示错误：
```
Account missing platform_user_id - please login first to obtain douyin_id
```

### 诊断结果

运行 `tests/诊断登录检测问题.js` 发现核心矛盾：

| 项目 | 数据库状态 | 实际情况 | 结论 |
|------|----------|---------|------|
| platform_user_id | ✅ 1864722759 | 登录时正确获取并保存 | 正常 |
| login_status | ❌ not_logged_in | 被 Worker 误覆盖 | **异常** |
| Storage Cookies | ✅ 56 个有效 | 关键 cookies 都存在 | 正常 |
| Cookies 有效期 | ✅ 2025/10/31 | 未过期 | 正常 |
| Worker 检测 | ❌ 未登录 | 使用旧配置检测 | **异常** |

## 根本原因

### 问题链条

```
1. Master 登录成功 (18:39:07)
   ├─ 更新数据库: login_status = 'logged_in' ✅
   └─ 更新数据库: platform_user_id = '1864722759' ✅

2. Worker 配置未同步 ❌
   ├─ Worker 内存中仍是旧配置（无 platform_user_id）
   └─ 原因：没有配置热更新机制

3. Worker 定期检测 (18:39:08 开始，每分钟一次)
   ├─ 使用旧配置进行检测
   ├─ 判断：无 platform_user_id = 未登录
   └─ 执行错误操作：更新数据库 login_status = 'not_logged_in' ❌

4. 数据库状态被覆盖
   ├─ login_status: 'logged_in' → 'not_logged_in'
   └─ 但 platform_user_id 仍然存在（矛盾状态）

5. Worker 重启 (18:59:31)
   ├─ 从数据库加载配置
   ├─ 读取到: login_status = 'not_logged_in'
   └─ 继续报错："missing platform_user_id"

6. 恶性循环 ♻️
   └─ Worker 持续检测为未登录 → 爬虫任务不执行
```

### 代码层面分析

#### 问题代码 1：Worker 盲目覆盖登录状态

**位置**：`packages/worker/src/handlers/monitor-task.js:162-180`

```javascript
// 检查 platform_user_id
if (!this.account.platform_user_id) {
  logger.warn(`Account ${this.account.id} missing platform_user_id - please login first`);

  // ❌ 问题：直接把数据库的 login_status 改为 not_logged_in
  // 没有考虑可能是配置未同步的情况
  this.accountStatusReporter.recordError(this.account.id, 'Account missing platform_user_id...');
  this.accountStatusReporter.updateAccountStatus(this.account.id, {
    worker_status: 'offline',
    login_status: 'not_logged_in'  // ⚠️ 覆盖了 Master 刚设置的 logged_in
  });

  return;
}

// 检查登录状态
const loginStatus = await platform.checkLoginStatus(page);
if (!loginStatus || !loginStatus.isLoggedIn) {
  logger.warn(`Account ${this.account.id} is NOT logged in`);

  // ❌ 同样的问题
  this.accountStatusReporter.updateAccountStatus(this.account.id, {
    worker_status: 'offline',
    login_status: 'not_logged_in'
  });

  return;
}
```

#### 问题代码 2：缺少配置热更新机制

**现象**：Master 更新数据库后，Worker 内存中的配置不会自动刷新

**影响**：
- Worker 使用过时的配置进行决策
- 导致误判和错误操作

## 解决方案

### 方案 1：配置热更新机制 ✅（已实现）

**详见**：[爬虫任务配置热更新机制实现报告.md](./爬虫任务配置热更新机制实现报告.md)

#### 核心机制

```
┌──────────────────────────────────────────────────────────┐
│  配置热更新流程                                           │
└──────────────────────────────────────────────────────────┘

1. 用户扫码登录成功
   ↓
2. Worker 发送 login:success 给 Master
   payload: { cookies, userInfo, fingerprint }
   ↓
3. Master 更新数据库
   UPDATE accounts SET
     login_status = 'logged_in',
     platform_user_id = '1864722759',
     last_login_time = 1730375947,
     cookies_valid_until = 1730980747
   ↓
4. ⭐ Master 发送配置更新通知
   Event: MASTER_ACCOUNT_CONFIG_UPDATE
   Payload: {
     account_id: "acc-xxx",
     reason: "login_success",
     updated_fields: ["platform_user_id", "login_status", "user_info"]
   }
   ↓
5. ⭐ Worker 接收通知，重新加载配置
   - 调用 workerRegistration.register() 获取最新配置
   - 更新 accountsCache.set(accountId, updatedAccount)
   - 通知 taskRunner.updateAccountConfig()
   ↓
6. ⭐ Worker 下次检测使用新配置
   - this.account.platform_user_id = '1864722759' ✅
   - 检测通过，爬虫任务正常执行 ✅
```

#### 实现文件

1. **协议层** (`packages/shared/protocol/messages.js`)
   - 新增：`MASTER_ACCOUNT_CONFIG_UPDATE`
   - 新增：`MASTER_ACCOUNT_CONFIG_UPDATE_ACK`

2. **Master 端** (`packages/master/src/login/login-handler.js`)
   - 修改：构造函数接收 `workerNamespace`
   - 新增：`handleLoginSuccess()` 中发送配置更新通知

3. **Worker 端**
   - `socket-client.js`: 监听配置更新消息
   - `index.js`: 实现 `reloadAccountConfig()` 函数
   - `task-runner.js`: 实现 `updateAccountConfig()` 方法

#### 测试方法

```bash
# 1. 启动 Master 和 Worker
cd packages/master && npm start
cd packages/worker && npm start

# 2. 执行登录操作（Admin UI 扫码登录）

# 3. 观察日志
# Master 应显示：
[login-handler] Sent config update notification to Worker worker-1

# Worker 应显示：
[socket-client] 📥 Received account config update notification from Master
[worker] 🔄 Reloading configuration for account acc-xxx...
[worker] ✅ Account config reloaded for acc-xxx
[task-runner] ✅ Updated account config in MonitorTask for acc-xxx

# 4. 验证爬虫任务执行
node tests/测试爬虫任务执行.js
```

### 方案 2：修复 Worker 检测逻辑 🔧（待实现）

#### 改进思路

Worker 不应该在检测到本地配置缺失时，盲目地把数据库改为 `not_logged_in`。

应该：
1. 检测到本地配置缺少 platform_user_id
2. **先查询数据库**，看数据库是否有
3. 如果数据库有 → 配置未同步 → 重新加载配置
4. 如果数据库也没有 → 确实未登录 → 更新为 not_logged_in

#### 改进代码

**文件**：`packages/worker/src/handlers/monitor-task.js`

```javascript
// ⭐ 改进版：智能检测 + 配置重载
async checkAndReloadConfigIfNeeded() {
  // 检查本地配置是否缺少 platform_user_id
  if (!this.account.platform_user_id) {
    logger.warn(`[MonitorTask] Local config missing platform_user_id for ${this.account.id}`);

    try {
      // ⭐ 先尝试重新加载配置
      const updatedAccount = await this.reloadAccountConfig(this.account.id);

      if (updatedAccount && updatedAccount.platform_user_id) {
        // 成功重新加载，使用新配置
        logger.info(`✅ Config reloaded with platform_user_id: ${updatedAccount.platform_user_id}`);
        this.account = updatedAccount;
        return true; // 配置已更新，可以继续
      } else {
        // 数据库也没有，确实未登录
        logger.warn(`❌ Database also missing platform_user_id - truly not logged in`);
        this.accountStatusReporter.updateAccountStatus(this.account.id, {
          worker_status: 'offline',
          login_status: 'not_logged_in'
        });
        return false; // 未登录，不能继续
      }
    } catch (error) {
      logger.error(`Failed to reload config:`, error);
      return false;
    }
  }

  return true; // 配置完整，可以继续
}

async run() {
  try {
    // ⭐ 运行前先检查并重载配置
    const configOk = await this.checkAndReloadConfigIfNeeded();
    if (!configOk) {
      logger.info(`Pausing monitoring for ${this.account.id} - config incomplete`);
      return;
    }

    // 继续执行原有的监控逻辑
    // ...
  } catch (error) {
    logger.error(`MonitorTask run error:`, error);
  }
}
```

### 方案 3：Master 端防御 🛡️（待实现）

#### 改进思路

Master 不应该允许 Worker 随意覆盖关键字段，特别是当数据库状态明确时。

#### 改进代码

**文件**：`packages/master/src/worker_manager/account-status-updater.js`

```javascript
/**
 * ⭐ 智能更新账户状态（防御性验证）
 */
updateAccountStatus(accountId, updates) {
  try {
    // ⭐ 防御性检查：如果 Worker 想改为 not_logged_in，先验证数据库
    if (updates.login_status === 'not_logged_in') {
      const account = this.db.prepare(`
        SELECT platform_user_id, login_status, cookies_valid_until
        FROM accounts
        WHERE id = ?
      `).get(accountId);

      if (account) {
        const now = Math.floor(Date.now() / 1000);

        // 情况1：数据库有 platform_user_id 且状态为 logged_in
        if (account.platform_user_id && account.login_status === 'logged_in') {
          logger.warn(`🛡️ Rejected Worker's attempt to set login_status=not_logged_in for ${accountId}`);
          logger.warn(`   Reason: Database shows logged_in with platform_user_id=${account.platform_user_id}`);

          // 移除这个错误的更新
          delete updates.login_status;

          // ⭐ 反而通知 Worker 重新加载配置
          this.notifyWorkerToReloadConfig(accountId, 'config_mismatch');
        }

        // 情况2：Cookies 仍在有效期内
        else if (account.cookies_valid_until && account.cookies_valid_until > now) {
          logger.warn(`🛡️ Rejected Worker's attempt to set login_status=not_logged_in for ${accountId}`);
          logger.warn(`   Reason: Cookies still valid until ${new Date(account.cookies_valid_until * 1000).toLocaleString('zh-CN')}`);

          delete updates.login_status;
          this.notifyWorkerToReloadConfig(accountId, 'cookies_still_valid');
        }
      }
    }

    // 构建 UPDATE SQL
    const fields = [];
    const values = [];

    for (const [key, value] of Object.entries(updates)) {
      fields.push(`${key} = ?`);
      values.push(value);
    }

    if (fields.length === 0) {
      logger.debug(`No fields to update for account ${accountId}`);
      return;
    }

    const sql = `UPDATE accounts SET ${fields.join(', ')} WHERE id = ?`;
    values.push(accountId);

    const stmt = this.db.prepare(sql);
    const result = stmt.run(...values);

    logger.info(`✅ Updated account status for ${accountId}: ${JSON.stringify(updates)}`);

  } catch (error) {
    logger.error(`Failed to update account status for ${accountId}:`, error);
  }
}

/**
 * ⭐ 通知 Worker 重新加载配置
 */
notifyWorkerToReloadConfig(accountId, reason) {
  try {
    const { MASTER_ACCOUNT_CONFIG_UPDATE, createMessage } = require('@hiscrm-im/shared/protocol/messages');

    // 查找账户分配的 Worker
    const account = this.db.prepare('SELECT assigned_worker_id FROM accounts WHERE id = ?').get(accountId);
    if (!account || !account.assigned_worker_id) {
      logger.warn(`Cannot notify Worker for ${accountId} - no assigned Worker`);
      return;
    }

    // 找到 Worker 的 socket 连接
    const workerSocket = this.workerNamespace.sockets.get(account.assigned_worker_id);
    if (workerSocket) {
      const message = createMessage(MASTER_ACCOUNT_CONFIG_UPDATE, {
        account_id: accountId,
        reason: reason,
        updated_fields: ['platform_user_id', 'login_status', 'cookies_valid_until'],
      });

      workerSocket.emit(MASTER_ACCOUNT_CONFIG_UPDATE, message);
      logger.info(`📤 Sent config reload notification to Worker ${account.assigned_worker_id} for account ${accountId}`);
    }

  } catch (error) {
    logger.error(`Failed to notify Worker for ${accountId}:`, error);
  }
}
```

## 临时修复（已执行）✅

### 修复数据库状态

运行脚本：`tests/修复登录状态.js`

```bash
$ node tests/修复登录状态.js

================================================================================
修复登录状态
================================================================================

📊 1. 检查需要修复的账户:
--------------------------------------------------------------------------------
找到 1 个需要修复的账户:

[1] 账户 ID: acc-98296c87-2e42-447a-9d8b-8be008ddb6e4
    平台用户ID: 1864722759 ✅
    当前登录状态: not_logged_in ❌

🔧 2. 开始修复:
--------------------------------------------------------------------------------
✅ [1/1] 修复成功: douyin-test

修复完成！
```

### SQL 执行

```sql
UPDATE accounts
SET login_status = 'logged_in'
WHERE id = 'acc-98296c87-2e42-447a-9d8b-8be008ddb6e4'
  AND platform_user_id IS NOT NULL;
```

## 下一步操作

### 1. 重启 Worker ⚠️

数据库已修复，但 Worker 内存中的配置仍是旧的，需要重启：

```bash
# 终止当前 Worker 进程
# 然后重新启动
cd packages/worker && npm start
```

### 2. 观察 Worker 行为

Worker 重启后应该：
- ✅ 加载 `login_status: logged_in` 的配置
- ✅ 检测通过（有 platform_user_id）
- ✅ 爬虫任务正常执行

### 3. 验证爬虫任务执行

```bash
# 等待 1-2 分钟后运行
node tests/测试爬虫任务执行.js
```

**预期结果**：
- ✅ 账户状态显示 `logged_in`
- ✅ 监控任务存在且状态为 `active`
- ✅ 数据库中开始出现新的评论/私信数据

### 4. 测试配置热更新机制

1. **模拟配置被覆盖**：
   ```sql
   UPDATE accounts
   SET login_status = 'not_logged_in'
   WHERE id = 'acc-98296c87-2e42-447a-9d8b-8be008ddb6e4';
   ```

2. **再次登录**：在 Admin UI 点击登录，扫码确认

3. **观察日志**：

   **Master 日志应显示**：
   ```
   [login-handler] Login success for session xxx
   [login-handler] Updated platform_user_id to: 1864722759
   [login-handler] Sent config update notification to Worker worker-1
   ```

   **Worker 日志应显示**：
   ```
   [socket-client] 📥 Received account config update notification from Master
   [worker] 🔄 Reloading configuration for account acc-xxx...
   [worker] ✅ Account config reloaded for acc-xxx
   [task-runner] ✅ Updated account config in MonitorTask for acc-xxx
   ```

4. **验证自动恢复**：
   - Worker 不再报错
   - 爬虫任务自动恢复执行
   - 无需手动重启 Worker

## 总结

### 问题本质

**配置不一致导致的数据混乱**：

1. Master 在数据库中更新了账户配置
2. Worker 内存中的配置没有同步更新
3. Worker 使用旧配置进行决策，得出错误结论
4. Worker 把错误结论写回数据库，覆盖了 Master 的正确更新
5. 形成恶性循环

### 解决方案对比

| 方案 | 优先级 | 状态 | 效果 |
|------|--------|------|------|
| 配置热更新机制 | ⭐⭐⭐ | ✅ 已实现 | 根本解决问题，实现实时配置同步 |
| Worker 检测逻辑改进 | ⭐⭐ | 🔧 待实现 | 提升健壮性，智能处理配置缺失 |
| Master 防御性验证 | ⭐ | 🛡️ 待实现 | 保护数据库，拒绝不合理更新 |
| 数据库状态修复 | 🚑 | ✅ 已执行 | 临时修复当前问题 |

### 长期改进建议

1. **配置管理**
   - 实现配置版本号机制
   - Worker 定期检查配置版本，自动同步

2. **状态监控**
   - 监控 `platform_user_id` 存在但 `login_status = not_logged_in` 的异常状态
   - 自动发出告警并尝试修复

3. **日志增强**
   - 记录所有 login_status 变更，包括变更来源
   - 便于追踪问题和审计

4. **测试覆盖**
   - 添加集成测试：登录 → 配置同步 → 爬虫执行
   - 模拟 Worker 重启场景，验证配置持久化

---

**文档时间**：2025-10-24 19:15
**文档作者**：Claude Code
**文档版本**：1.0
