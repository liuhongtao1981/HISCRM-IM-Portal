# 登录检测导致爬虫窗口刷新问题分析

**问题时间**: 2025-10-24 21:10
**问题描述**: 执行任务时,爬虫窗口一直刷新
**状态**: ✅ 根本原因已找到

---

## 问题确认

### 用户反馈

用户截图显示抖音创作者中心的私信管理页面处于加载状态,并反馈:
> "执行任务的时候,会一直刷新我的任务tab"

###实际情况 (日志分析)

**爬虫任务执行频率**: 每 15-30 秒一次
```
20:11:50 → 下次 19.4s
20:12:09 → 下次 17.6s
20:12:30 → 下次 16.6s
20:35:52 → 下次 24.4s
```

**页面导航频率** (crawl-direct-messages-v2.log):
```
20:11:28 - Navigated to message page
20:36:00 - Navigated to message page
```
→ **间隔 24 分钟!** 说明爬虫函数内的 `page.goto()` 并不频繁

---

## 根本原因

### 登录检测每次都导航页面

**问题代码** (`packages/worker/src/handlers/monitor-task.js:180-188`):

```javascript
// 每次爬虫任务执行前都会执行登录检测
async execute() {
  // ...

  // 获取登录检测窗口
  const { tabId, page, shouldClose } = await this.browserManager.tabManager.getPageForTask(this.account.id, {
    tag: TabTag.LOGIN_CHECK,
    persistent: false,     // 检测完关闭
    shareable: true,       // ⚠️ 可以复用登录窗口
    forceNew: false        // ⚠️ 优先复用已有窗口
  });

  // ❌ 每次都导航到创作中心
  if (!page.url().includes('creator.douyin.com')) {
    logger.info('Navigating to creator center for login check...');
    await page.goto('https://creator.douyin.com/', {
      waitUntil: 'domcontentloaded',
      timeout: 30000
    });
    await page.waitForTimeout(2000);
  }

  // 检查登录状态
  const loginStatus = await this.platformInstance.checkLoginStatus(page);

  // 关闭登录检测窗口
  if (loginCheckTabId && shouldClose) {
    await this.browserManager.tabManager.closeTab(this.account.id, loginCheckTabId);
  }
}
```

### 问题流程

```
T0: 爬虫任务执行
  ↓
获取 LOGIN_CHECK 窗口 (shareable=true, forceNew=false)
  ↓
TabManager 查找可复用窗口:
  - 查找 LOGIN_CHECK 标签 → 没找到
  - ⚠️ shareable=true，查找可共享的窗口
  - 找到 SPIDER_DM 窗口 (正在显示私信页面)
  ↓
复用 SPIDER_DM 窗口
  ↓
❌ 导航到首页: page.goto('https://creator.douyin.com/')
  ↓
用户看到: 私信页面 → 刷新到首页
  ↓
检查登录状态
  ↓
关闭 LOGIN_CHECK 窗口 (实际是 SPIDER_DM 窗口)
  ↓
下次爬虫任务:
  - crawlDirectMessages() 获取 SPIDER_DM 窗口
  - TabManager 创建新的 SPIDER_DM 窗口
  - page.goto('creator-micro/data/following/chat')
  ↓
用户看到: 首页 → 刷新到私信页面
  ↓
循环...
```

**用户看到的效果**:
- 每 15-30 秒切换一次页面
- 私信页面 ↔ 首页 ↔ 私信页面
- "一直刷新"

---

## 为什么会复用爬虫窗口?

### TabManager 的查找逻辑

```javascript
// packages/worker/src/browser/tab-manager.js:69-82

async getPageForTask(accountId, options = {}) {
  const { tag, persistent, shareable, forceNew } = options;

  // 1. 如果可以公用，尝试查找已有的可公用窗口
  if (shareable && !forceNew) {
    const existingTab = this.findTabByTag(accountId, tag);  // ← 先找同 tag
    if (existingTab) {
      return { /* 复用 */ };
    }
  }

  // 2. 如果不强制新建，尝试查找已有的同 tag 窗口
  if (!forceNew) {
    const existingTab = this.findTabByTag(accountId, tag);  // ← 再找同 tag
    if (existingTab) {
      return { /* 复用 */ };
    }
  }

  // 3. 创建新窗口
  const { tabId, page } = await this.createTab(accountId, tag, persistent);
  return { tabId, page, release: async () => { /*...*/ } };
}
```

**问题**: 当前逻辑只查找同 tag 的窗口,不会跨 tag 复用。

**但是**,在登录检测中,代码期望 `shareable=true` 可以复用登录窗口:

```javascript
// monitor-task.js:170-175
const { tabId, page, shouldClose } = await this.browserManager.tabManager.getPageForTask(this.account.id, {
  tag: TabTag.LOGIN_CHECK,
  persistent: false,
  shareable: true,       // ← 期望复用 LOGIN 窗口
  forceNew: false
});
```

**实际情况**: 由于登录窗口已经 release() 并关闭,LOGIN_CHECK 找不到可复用的窗口,就创建新窗口。但是...

**等等!** 让我重新看日志:

```
20:12:10 - Navigating to creator center for login check...
20:12:30 - Navigating to creator center for login check...
20:12:50 - Navigating to creator center for login check...
20:35:52 - Navigating to creator center for login check...
```

每次都在导航!这说明每次都在创建新的 LOGIN_CHECK 窗口。

但是爬虫窗口呢?让我查看爬虫窗口是否被关闭了:

从日志看:
```
20:12:13 - Spider DM tab retrieved successfully
20:12:13 - page.goto: Target page, context or browser has been closed ❌
```

**爬虫窗口被关闭了!** 这是因为登录窗口 release() 后,浏览器关闭,导致所有窗口都关闭。

---

## 两个层面的问题

### 问题1: 登录窗口 release() 导致浏览器关闭

**原因**: 我们刚才修改了 platform.js,登录成功后调用 `release()`:

```javascript
// platform.js:105
await release();  // 登录窗口 release
  ↓
// TabManager 检测到是临时窗口
releaseTab() → closeTab()
  ↓
// 检测到是最后一个窗口
// 由于是临时窗口,允许关闭
page.close()
  ↓
浏览器退出 (所有窗口关闭)
```

**影响**:
- 爬虫窗口还没创建
- 浏览器就退出了
- 爬虫任务启动时,需要重新创建浏览器和窗口

### 问题2: 登录检测每次导航页面

即使浏览器正常运行,登录检测也会导航页面:

```javascript
// monitor-task.js:181-188
if (!page.url().includes('creator.douyin.com')) {
  await page.goto('https://creator.douyin.com/', {  // ← 每次都导航
    waitUntil: 'domcontentloaded',
    timeout: 30000
  });
}
```

**但是**: 由于每次都创建新的 LOGIN_CHECK 窗口,初始 URL 是 `about:blank`,所以每次都会触发导航。

---

## 解决方案

### 方案A: 优化登录检测逻辑 (推荐 ⭐⭐⭐)

**核心思路**: 使用爬虫窗口检测登录,不额外创建窗口

```javascript
// packages/worker/src/handlers/monitor-task.js

async execute() {
  if (!this.isRunning) return;

  this.executionCount++;
  logger.info(`Executing monitor task for account ${this.account.id} (count: ${this.executionCount})`);

  try {
    // ⭐ 改进: 使用爬虫窗口检测登录,不创建额外窗口
    logger.info(`Checking login status using spider window...`);

    // 获取或创建私信爬虫窗口 (持久化)
    const { page: dmPage } = await this.browserManager.tabManager.getPageForTask(this.account.id, {
      tag: TabTag.SPIDER_DM,
      persistent: true,
      shareable: false,
      forceNew: false
    });

    // 智能导航: 只在不在创作中心时导航
    if (!dmPage.url().includes('creator.douyin.com')) {
      logger.info('Navigating to creator center for login check...');
      await dmPage.goto('https://creator.douyin.com/', {
        waitUntil: 'domcontentloaded',
        timeout: 30000
      });
      await dmPage.waitForTimeout(2000);
    } else {
      logger.info('Already on creator center, skipping navigation');
    }

    // 检查登录状态
    const loginStatus = await this.platformInstance.checkLoginStatus(dmPage);

    if (!loginStatus.isLoggedIn) {
      logger.warn(`✗ Account ${this.account.id} is NOT logged in, skipping crawl`);
      // ...
      return;
    }

    logger.info(`✓ Account ${this.account.id} is logged in, starting crawl...`);

    // ⭐ 爬虫窗口已经存在且在正确页面,直接开始爬取
    // 不需要关闭窗口
    // 不需要额外导航

    // 2. 并行运行爬虫任务
    logger.info(`Starting parallel crawling: spider1 (DM) and spider2 (Comments)`);
    const results = await Promise.all([
      // ...爬虫任务
    ]);

    // ...
  } catch (error) {
    logger.error(`Monitor execution failed:`, error);
  } finally {
    // 调度下一次执行
    this.scheduleNext();
  }
}
```

**优点**:
- ✅ 不创建额外窗口
- ✅ 不额外导航页面
- ✅ 爬虫窗口保持在私信页面
- ✅ 用户体验最佳

**缺点**:
- ⚠️ 如果爬虫窗口未创建,需要等待创建

### 方案B: 登录检测使用独立窗口

**核心思路**: 创建专门的登录检测窗口,不影响爬虫窗口

```javascript
// monitor-task.js

async execute() {
  // ...

  // ⭐ 使用独立的登录检测窗口
  const { page: checkPage, release } = await this.browserManager.tabManager.getPageForTask(this.account.id, {
    tag: TabTag.LOGIN_CHECK,
    persistent: false,     // 检测完关闭
    shareable: false,      // ← 不复用,独立窗口
    forceNew: true         // ← 强制新建
  });

  try {
    // 导航到首页检测登录
    await checkPage.goto('https://creator.douyin.com/', {
      waitUntil: 'domcontentloaded',
      timeout: 30000
    });

    // 检查登录状态
    const loginStatus = await this.platformInstance.checkLoginStatus(checkPage);

    if (!loginStatus.isLoggedIn) {
      logger.warn(`✗ Account is NOT logged in`);
      return;
    }

    logger.info(`✓ Account is logged in`);
  } finally {
    // ⭐ 使用 release() 自动关闭临时窗口
    await release();
  }

  // 继续爬虫任务...
}
```

**优点**:
- ✅ 不影响爬虫窗口
- ✅ 逻辑清晰

**缺点**:
- ❌ 每次创建/关闭窗口,开销大
- ❌ 额外的页面导航,检测风险高

### 方案C: 减少登录检测频率

**核心思路**: 不是每次都检测登录,只在必要时检测

```javascript
// monitor-task.js

class MonitorTask {
  constructor(/*...*/) {
    // ...
    this.lastLoginCheckTime = 0;
    this.loginCheckInterval = 5 * 60 * 1000;  // 5 分钟检测一次
  }

  async execute() {
    // ...

    // ⭐ 只在必要时检测登录
    const now = Date.now();
    const shouldCheckLogin = (now - this.lastLoginCheckTime) > this.loginCheckInterval;

    if (shouldCheckLogin) {
      logger.info(`Checking login status (last check: ${Math.floor((now - this.lastLoginCheckTime) / 1000)}s ago)...`);

      // 检测登录...

      this.lastLoginCheckTime = now;
    } else {
      logger.debug(`Skipping login check (last check: ${Math.floor((now - this.lastLoginCheckTime) / 1000)}s ago)`);
    }

    // 继续爬虫任务...
  }
}
```

**优点**:
- ✅ 大幅减少登录检测
- ✅ 减少页面导航
- ✅ 降低检测风险

**缺点**:
- ⚠️ 如果账户在5分钟内退出登录,可能延迟发现

---

## 推荐实施方案

### 短期方案: 方案A (使用爬虫窗口检测)

**实施步骤**:
1. 修改 `monitor-task.js` 的 `execute()` 方法
2. 使用 SPIDER_DM 窗口检测登录
3. 添加智能导航判断
4. 测试验证

**预期效果**:
- 不再创建 LOGIN_CHECK 窗口
- 不再额外导航页面
- 爬虫窗口保持在私信页面
- 用户看不到页面刷新

### 长期方案: 方案A + 方案C (智能检测)

**实施步骤**:
1. 实现方案A (使用爬虫窗口)
2. 添加方案C (减少检测频率)
3. 错误重试时强制检测登录
4. 配置化检测策略

**优势**:
- 效率最高
- 用户体验最佳
- 检测风险最低

---

## 关于登录窗口关闭问题

### 当前问题

登录成功后调用 `release()`,由于是最后一个窗口,浏览器会退出:

```javascript
// platform.js:105
await release();
  ↓
releaseTab() → closeTab()
  ↓
// 临时窗口,允许关闭
page.close()
  ↓
浏览器退出
```

### 解决方案

**方案1**: 登录成功后,先创建爬虫窗口,再 release 登录窗口

```javascript
// platform.js startLogin()

if (loginStatus.isLoggedIn) {
  const userInfo = await this.extractUserInfo(loginPage);

  // ⭐ 先创建爬虫窗口
  logger.info('Pre-creating spider windows...');
  const { page: dmPage } = await this.browserManager.tabManager.getPageForTask(accountId, {
    tag: TabTag.SPIDER_DM,
    persistent: true,
    shareable: false,
    forceNew: false
  });

  const { page: commentPage } = await this.browserManager.tabManager.getPageForTask(accountId, {
    tag: TabTag.SPIDER_COMMENT,
    persistent: true,
    shareable: false,
    forceNew: false
  });

  // 现在可以安全地 release 登录窗口
  await release();

  // ...
}
```

**方案2**: 不 release 登录窗口,转换为 PLACEHOLDER

```javascript
// 不调用 release(),让 closeTab() 自动转换为 PLACEHOLDER
```

**推荐**: 方案1 - 预创建爬虫窗口

---

## 相关文件

需要修改的文件:
1. `packages/worker/src/handlers/monitor-task.js` - 登录检测逻辑
2. `packages/worker/src/platforms/douyin/platform.js` - 登录窗口关闭逻辑 (可选)

需要测试的场景:
1. 首次启动 Worker - 验证登录和爬虫正常
2. 爬虫运行中 - 验证不刷新页面
3. 账户退出登录 - 验证能及时检测到
4. 长时间运行 - 验证稳定性

---

**报告生成时间**: 2025-10-24 21:10
**问题状态**: ✅ 根本原因已找到
**推荐方案**: 方案A (使用爬虫窗口检测登录)
**下一步**: 等待用户确认后实施
